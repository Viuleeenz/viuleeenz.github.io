<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Security Undisguised</title><link>https://Viuleeenz.github.io/</link><description>Recent content on Security Undisguised</description><generator>Hugo</generator><language>en</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Wed, 22 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://Viuleeenz.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>From one to many - one IOC to hunt them ALL</title><link>https://Viuleeenz.github.io/posts/2025/08/from-one-to-many-one-ioc-to-hunt-them-all/</link><pubDate>Thu, 28 Aug 2025 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2025/08/from-one-to-many-one-ioc-to-hunt-them-all/</guid><description>&lt;p>&lt;em>If you are a threat researcher reading a blog post about a novel threat that could potentially impact your organization, or if you need to investigate this threat to enrich your internal telemetry for better tracking and detection, how would you proceed?&lt;/em>&lt;/p>
&lt;p>This was the question that come up in my mind, out of the blue, reading an article from Unit42 where they start to talk about a novel malware sold in the underground named &lt;a href="https://unit42.paloaltonetworks.com/new-malware-gremlin-stealer-for-sale-on-telegram/">Gremlin stealer&lt;/a>. As always the article is very well detailed, carefully explaining the malware’s characteristics and objectives while also providing the SHA-256 hash of the analyzed sample.&lt;/p></description></item><item><title>Symbolic Execution for fun and Flare-On</title><link>https://Viuleeenz.github.io/posts/2024/12/symbolic-execution-for-fun-and-flare-on/</link><pubDate>Fri, 27 Dec 2024 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2024/12/symbolic-execution-for-fun-and-flare-on/</guid><description>&lt;p>Emulation is my passion. I apply it as much as I can in countless scenarios—sometimes for practical purposes, and sometimes just for fun. Recently, I’ve been diving into &lt;strong>angr&lt;/strong>, and after weeks of banging my head against it, a few questions crossed my mind:&lt;/p>
&lt;p>Has anyone ever tried using angr for something meaningful, only to end up frustrated because nothing seemed to work? Or followed an angr tutorial based on CTF code, thinking, &lt;em>“Wow, this looks easy—I’ve got this!”&lt;/em>—only to realize you’re in way over your head?&lt;/p></description></item><item><title>Emulating inline decryption for triaging C++ malware</title><link>https://Viuleeenz.github.io/posts/2024/05/emulating-inline-decryption-for-triaging-c-malware/</link><pubDate>Thu, 16 May 2024 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2024/05/emulating-inline-decryption-for-triaging-c-malware/</guid><description>&lt;h2 id="what-we-need-to-know">What we need to know?&lt;/h2>
&lt;p>C and C++ binaries share several commonalities, however, some additional features and complexities introduced by C++ can make reverse engineering C++ binaries more challenging compared to C binaries. Some of the most important features are:&lt;/p>
&lt;p>&lt;strong>Name Mangling&lt;/strong>: C++ compilers often use name mangling to encode additional information about functions and classes into the symbol names in the binary. This can make it more challenging to understand the code&amp;rsquo;s structure and functionality by simply looking at symbol names.&lt;/p></description></item><item><title>Understanding API Hashing and build a rainbow table for LummaStealer</title><link>https://Viuleeenz.github.io/posts/2024/03/understanding-api-hashing-and-build-a-rainbow-table-for-lummastealer/</link><pubDate>Sun, 24 Mar 2024 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2024/03/understanding-api-hashing-and-build-a-rainbow-table-for-lummastealer/</guid><description>&lt;p>Understanding PEB and Ldr structures represents a starting point when we are dealing with API hashing. However, before proceeding to analyze a sample it’s always necessary to recover obfuscated, encrypted or hashed data. Because of that, through this blogpost I would like to continue what I have started in the &lt;a href="https://viuleeenz.github.io/posts/2024/02/understanding-peb-and-ldr-structures-using-ida-and-lummastealer/">previous post&lt;/a>, using emulation to create a rainbow table for LummaStealer and then write a little resolver script that is going to use the information extracted to resolve all hashes.&lt;/p></description></item><item><title>Understanding PEB and LDR Structures using IDA and LummaStealer</title><link>https://Viuleeenz.github.io/posts/2024/02/understanding-peb-and-ldr-structures-using-ida-and-lummastealer/</link><pubDate>Sun, 04 Feb 2024 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2024/02/understanding-peb-and-ldr-structures-using-ida-and-lummastealer/</guid><description>&lt;p>In this post I’m going to explain how Process Environment Block (PEB) is parsed by malware devs and how that structure is abused. Instead of going too deep into a lot of details, I would like to follow an easier approach pairing the theory with a practical real example using IDA and LummaStealer, without overwhelming the reader with a lot of technical details trying to simplify the data structure involved in the process. At the end of the theory part, I’m going to &lt;strong>apply PEB and all related structures in IDA&lt;/strong>, inspecting malware parsing capabilities that are going to be applied for resolving hashed APIs.&lt;/p></description></item><item><title>Applied Emulation - Decrypting Ursnif strings with Unicorn</title><link>https://Viuleeenz.github.io/posts/2023/12/applied-emulation-decrypting-ursnif-strings-with-unicorn/</link><pubDate>Wed, 20 Dec 2023 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2023/12/applied-emulation-decrypting-ursnif-strings-with-unicorn/</guid><description>&lt;h3 id="introduction">Introduction&lt;/h3>
&lt;p>Here we go with another chapter of the Applied Emulation series. In the previous blogpost we have talked about emulation and more specifically, the usage of &lt;em>Dumpulator&lt;/em> to perform a quick triage. However, in this blogpost we are going to use a completely different approach, taking advantage of &lt;strong>static analysis to&lt;/strong> &lt;strong>understand and emulate a string decryption algorithm through &lt;a href="https://www.unicorn-engine.org/">Unicorn&lt;/a>&lt;/strong>. As always, I would like to give a practical example on a real case scenario. Because of that, I have chosen to analyze an &lt;strong>Ursnif&lt;/strong> sample.&lt;/p></description></item><item><title>Applied Emulation - Analysis of MarsStealer</title><link>https://Viuleeenz.github.io/posts/2023/11/applied-emulation-analysis-of-marsstealer/</link><pubDate>Wed, 15 Nov 2023 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2023/11/applied-emulation-analysis-of-marsstealer/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>&lt;strong>Emulation is a technique that could be very handy and effective&lt;/strong> when we have to deal with &lt;strong>malware triage&lt;/strong>, &lt;strong>configuration extractor&lt;/strong> and &lt;strong>deobfuscate part of the code without rewriting complex algorithms&lt;/strong>. Even if it seems magic (and it&amp;rsquo;s not unfortunately) it&amp;rsquo;s still not possible to apply emulation on random code. However, if applied correctly this method could really speed up our malware analysis and triage. Through this blogpost I would like to give an overview about emulation usage and apply it in a real case scenario.&lt;/p></description></item><item><title>Vidar - payload inspection with static analysis</title><link>https://Viuleeenz.github.io/posts/2023/10/vidar-payload-inspection-with-static-analysis/</link><pubDate>Wed, 25 Oct 2023 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2023/10/vidar-payload-inspection-with-static-analysis/</guid><description>&lt;h2 id="behind-this-post">Behind this post&lt;/h2>
&lt;p>Through this blogpost I’m going to talk about one of the latest Vidar samples that I had a chance to analyze. The payload is actually part of a campaign delivered in July 2023 using PEC mails and this analysis comes from a post related to &lt;a href="https://cert-agid.gov.it/tag/vidar/">Cert-Agid&lt;/a> in the same period. Even if the payload seems to be out of time, it&amp;rsquo;s still a valid example for further analysis of more recents ones.&lt;/p></description></item><item><title>Agent Tesla - Building an effective decryptor</title><link>https://Viuleeenz.github.io/posts/2023/08/agent-tesla-building-an-effective-decryptor/</link><pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2023/08/agent-tesla-building-an-effective-decryptor/</guid><description>&lt;h3 id="general-information-and-preface">General Information and preface&lt;/h3>
&lt;p>Agent Tesla, according to the &lt;a href="https://cert.europa.eu/static/threat-intelligence/TLP-CLEAR-CB-23-08.pdf">data&lt;/a> provided by CERT-EU, is one the most prominent threats that are hitting European cyberspace. Because of that, I found that it could be quite interesting understanding its behavior. However, as I usually prefer, instead of focusing on the infection chain or information about TA methodologies, sharing knowledge that were already provided by more authoritative sources, I preferred to focus mostly on malware analysis and in this specific case to the latest encryption algorithm adopted. Then, upon the knowledge acquired, I would like to write a decryptor script that extracts payload configuration.&lt;/p></description></item><item><title>IDA-Python - Locate a function independently from its offset</title><link>https://Viuleeenz.github.io/posts/2023/06/ida-python-locate-a-function-independently-from-its-offset/</link><pubDate>Tue, 27 Jun 2023 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2023/06/ida-python-locate-a-function-independently-from-its-offset/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>Analyzing samples statically could be not an easy going taks, especially when you deal with heavily obfuscated or encrypted data. Because of that, it’s useful to find out the decryption/deobfuscation routine and write a little script that makes sense of strings or function names before starting to analyze the whole sample.&lt;/p>
&lt;p>The idea behind this technique was inspired by the infinite amount of tweaking I have made to run multiple Ida-python scripts that were heavily machine-setting dependents. The idea is very simple and it’s based on pattern matching as for YARA rules. The scope here is to create a kind of signature for a function that we would like to locate (e.g., deobfuscation routine) and apply its execution to its parameters in order to simplify our analysis &lt;strong>without tweaking specific parameters&lt;/strong> making it &lt;strong>independent from the function offset&lt;/strong>. I have already got good results experimenting with malware samples (e.g, Qbot) and custom binaries from CTFs as well as other samples that used some sort of obfuscation. Because of that, I decided to create this post to share this approach that could be useful for writing better scripts.&lt;/p></description></item><item><title>Extracting DDosia targets from process memory</title><link>https://Viuleeenz.github.io/posts/2023/05/extracting-ddosia-targets-from-process-memory/</link><pubDate>Mon, 08 May 2023 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2023/05/extracting-ddosia-targets-from-process-memory/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>This post is part of an analysis that I have carried out during my spare time, motivated by a friend that asked me to have a look at the DDosia project related to the NoName057(16) group. The reason behind this request was caused by DDosia client changes for performing the DDos attacks. Because of that, all procedures used so far for monitoring NoName057(16) activities did not work anymore.&lt;/p>
&lt;p>Before starting to reverse DDosia Windows sample, I preferred to gather as much information as possible about NoName057(16) TTPs and a few references to their samples.&lt;/p></description></item><item><title>Dynamic Binary Instrumentation for Malware Analysis</title><link>https://Viuleeenz.github.io/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/</link><pubDate>Tue, 14 Mar 2023 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/</guid><description>&lt;h2 id="introduction">&lt;strong>Introduction&lt;/strong>&lt;/h2>
&lt;p>Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary.&lt;/p></description></item><item><title>Manually unpacking of packed executable</title><link>https://Viuleeenz.github.io/posts/2021/09/manually-unpacking-of-packed-executable/</link><pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2021/09/manually-unpacking-of-packed-executable/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>In this post, I will show how to manually unpack a simple executable that has been packed with WinUPack.
However, the goal of this post is to provide a general approach to start reversing code and, in general, packers.
Because of that it will be hard to cover all the techniques and strategies that could be applied,
but I will try to give the rights hints and the mindset to approach these challenges.&lt;/p></description></item><item><title>Whitepapers</title><link>https://Viuleeenz.github.io/whitepapers/</link><pubDate>Wed, 22 Oct 2025 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/whitepapers/</guid><description/></item><item><title> About me|this blog|meaning of life</title><link>https://Viuleeenz.github.io/about/</link><pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/about/</guid><description>&lt;p>Who am I? My name is Alessandro Strino and since my adolescence everything related to security has captured my attention, however, starting as OffSec addicted, I moved to malware analysis a few years later, where I have also started to write patches or exploits for fun and no profit. My nickname is a reference to an Italian movie called “Eccezzziunale… veramente” (1985). It was a funny-battlecry from the main characters that became iconic even years later.&lt;/p></description></item></channel></rss>