<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Security Undisguised</title>
        <link>https://Viuleeenz.github.io/posts/</link>
        <description>Recent content in Posts on Security Undisguised</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Sun, 24 Mar 2024 00:00:00 +0000</lastBuildDate>
        <atom:link href="https://Viuleeenz.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Understanding API Hashing and build a rainbow table for LummaStealer</title>
            <link>https://Viuleeenz.github.io/posts/2024/03/understanding-api-hashing-and-build-a-rainbow-table-for-lummastealer/</link>
            <pubDate>Sun, 24 Mar 2024 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2024/03/understanding-api-hashing-and-build-a-rainbow-table-for-lummastealer/</guid>
            <description>Understanding PEB and Ldr structures represents a starting point when we are dealing with API hashing. However, before proceeding to analyze a sample it‚Äôs always necessary to recover obfuscated, encrypted or hashed data. Because of that, through this blogpost I would like to continue what I have started in the previous post, using emulation to create a rainbow table for LummaStealer and then write a little resolver script that is going to use the information extracted to resolve all hashes.</description>
            <content type="html"><![CDATA[<p>Understanding PEB and Ldr structures represents a starting point when we are dealing with API hashing. However, before proceeding to analyze a sample it‚Äôs always necessary to recover  obfuscated, encrypted or hashed data. Because of that, through this blogpost I would like to continue what I have started in the <a href="https://viuleeenz.github.io/posts/2024/02/understanding-peb-and-ldr-structures-using-ida-and-lummastealer/">previous post</a>, using emulation to create a rainbow table for LummaStealer and then write a little resolver script that is going to use the information extracted to resolve all hashes.</p>
<blockquote>
<p>üí°<em>It‚Äôs worth mentioning that I‚Äôm trying to create self-contained posts. Of course, previous information will give a more comprehensive understanding of the whole process, however, the goal for this post is to have a guide that could be applied overtime even on different samples not related to LummaStealer.</em></p>
</blockquote>
<h2 id="resolving-hashes">Resolving Hashes</h2>
<p>Starting from where we left in the last post, we could explore the function routine that is in charge of <strong>collecting function names from a DLL and then perform a hashing algorithm</strong> to find a match with the input name.</p>
<p><img src="/img/api_hashing/api_hashing_overview.png" alt="Figure 1: LummaStealer API Hashing overview"></p>
<p>Figure 1: LummaStealer API Hashing overview</p>
<p>At the first glance, this function could be disorienting, however, understanding that <strong>ecx</strong> contains the module <strong>BaseAddress</strong> (explained in the previous article) ****it is possible to set a comment that is going to make the whole function easier to understand. Moreover, it has been also divided in three main parts( first two are going to be detailed in the next sections):</p>
<ol>
<li>Collecting exported function within a PE file;</li>
<li>Hashing routine;</li>
<li>Compare hashing result until a match is found, otherwise return 0; (<em>skipped because of a simple comparing routine</em>)</li>
</ol>
<h3 id="collecting-exported-function-within-a-pe-file">Collecting exported function within a PE file</h3>
<p>The first box starts with the instruction <strong>mov edi, ecx</strong> where <strong>ecx</strong> is a <em>BaseAddress</em> of a module that is going to be analyzed. This is a fundamental instruction that gives us a chance to infere the subsequent value of <strong>edi</strong> and <strong>ebx</strong>. In fact, if we rename values associated to these registers, it should be clear that this code is going to collect exported functions names through <strong>AddressOfNames</strong> and <strong>AddressOfNameOrdinals</strong> pointers.</p>
<p><img src="/img/api_hashing/resolving_structures_names.png" alt="Figure 2: Resolving structures names"></p>
<p>Figure 2: Resolving structures names</p>
<p>Those structures are very important in order to understand what is happening in the code. For now, you could think about those structures as <em>support structures</em> that could be chained together in order to collect the actual function pointer (after a match is found!)  within the <strong>Address of a Function structure</strong>.</p>
<blockquote>
<p>üí° <em>At the end of this article I created a dedicated sections to explain those structures and their connections.</em></p>
</blockquote>
<p>Another step that could misleading is related  to the following instruction:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> ebx,[eax<span style="color:#f92672">+</span>edi<span style="color:#f92672">+</span>IMAGE_NT_HEADERS.OptionaHeader.DataDirectory.VirtualAddress]
</span></span></code></pre></div><p>where <strong>ebx</strong> becomes a pointer for <strong>IMAGE_EXPORT_DIRECTORY</strong>.</p>
<p>In order to explain this instruction its useful to have a look at <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32">IMAGE_OPTIONAL_HEADERS</a> documentation, where Microsoft states that <strong>DataDirectory</strong> is pointer to a dedicated structure called <a href="https://learn.microsoft.com/en-us/windows/desktop/api/winnt/ns-winnt-image_data_directory">IMAGE_DATA_DIRECTORY</a> that could be addressed through a <strong>number</strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span> <span style="color:#a6e22e">typedef</span> struct _IMAGE_OPTIONAL_HEADER <span style="color:#960050;background-color:#1e0010">{</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">...</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">IMAGE_DATA_DIRECTORY</span> DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]<span style="color:#75715e">;</span>
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">}</span>
</span></span></code></pre></div><p>With that information let‚Äôs do some math unveiling the magic behind this assignment.</p>
<ul>
<li><strong>eax</strong> corresponds to the <strong>IMAGE_NT_HEADERS</strong> (because of its previous assignment)</li>
</ul>
<p>From there we have a <strong>0x78</strong> offset to sum. If we sum the first 18 bytes from <strong>eax</strong>, it‚Äôs possible to jump to the <strong>IMAGE_OPTIONAL_HEADER</strong>. Using the 60 bytes remaining to reach the next field within this structure, we could see that we are directly pointing to DataDirectory.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#a6e22e">typedef</span> struct <span style="color:#f92672">**</span>_IMAGE_NT_HEADERS<span style="color:#f92672">**</span> <span style="color:#960050;background-color:#1e0010">{</span>
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000</span> <span style="color:#66d9ef">DWORD</span>                   Signature<span style="color:#75715e">;</span>
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0004</span> IMAGE_FILE_HEADER       FileHeader<span style="color:#75715e">;</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">...</span>
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0018</span> IMAGE_OPTIONAL_HEADER32 OptionalHeader<span style="color:#75715e">;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">}</span> <span style="color:#a6e22e">IMAGE_NT_HEADERS32</span>, <span style="color:#f92672">*</span>PIMAGE_NT_HEADERS32<span style="color:#75715e">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">typedef</span> struct <span style="color:#f92672">**</span>_IMAGE_OPTIONAL_HEADER<span style="color:#f92672">**</span> <span style="color:#960050;background-color:#1e0010">{</span>
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000</span> <span style="color:#66d9ef">WORD</span>                 Magic<span style="color:#75715e">;</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">...</span>
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x001C</span> <span style="color:#66d9ef">DWORD</span>                ImageBase<span style="color:#75715e">;</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">...</span>
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0060</span> IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]<span style="color:#75715e">;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">}</span> <span style="color:#a6e22e">IMAGE_OPTIONAL_HEADER32</span>, <span style="color:#f92672">*</span>PIMAGE_OPTIONAL_HEADER32<span style="color:#75715e">;</span>
</span></span></code></pre></div><p>From here, we don‚Äôt have additional bytes to sum, it means that we are pointing to the first structure pointed by DataDirectory, that is, according to the documentation the <strong>IMAGE_DIRECTORY_ENTRY_EXPORT</strong> also known as <strong>Export Directory</strong>.</p>
<blockquote>
<p>üí° <em>See Reference section to find out a more clear image about the whole PE structure</em></p>
</blockquote>
<h3 id="retrieve-the-function-pointer">Retrieve the function pointer</h3>
<p>Once the code in charge to collect and compare exported functions has been completed, and a match is found, it&rsquo;s time to retrieve the actual function pointer using the structures mentioned above (<strong>AddressOfNamesOrdinals</strong> and <strong>AddressOfFunctions</strong>). In fact, as you can see from the code related to the third box (that has been renamed accordingly), once the match if found, the structure <strong>AddressOfNameOrdinals</strong> it&rsquo;s used to retrieve the functions number that is going to be used to address the structure <strong>AddressOfFunctions</strong> that contains the actual function pointers.</p>
<p><img src="/img/api_hashing/collect_api_pointer.png" alt="Figure 3: Collect the actual function pointer"></p>
<p>Figure 3: Collect the actual function pointer</p>
<h3 id="analyze-the-hashing-routine">Analyze the hashing routine</h3>
<p>Through the information collected so far, this code should be childishly simple.</p>
<p><strong>ecx</strong> contains the hash name extracted from the export table that is going to forward as input to the hash function (identified, <em>in this case, as <a href="https://github.com/abrandoned/murmur2/blob/master/MurmurHash2.c">murmur2</a></em>). The function itself is quite long but does not take too much time to be understood and reimplemented. However, the purpose of this article is to emulate this code in order to find out the values of all hardcoded hashes.</p>
<p><img src="/img/api_hashing/murmur2_hashing_routine.png" alt="Figure 4: MurMur2 hashing routine">
Figure 4: MurMur2 hashing routine</p>
<p>As we have <a href="https://viuleeenz.github.io/posts/2023/12/applied-emulation-decrypting-ursnif-strings-with-unicorn/">already done</a>, we could select the function opcodes (without the return instruction) and put them in our code emulator routine. It‚Äôs worth mentioning that, <strong>ecx</strong> contains the function name that is going to be used as argument for hashing routine, because of that, it‚Äôs important to assign that register properly.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">MurMurHash2</span>(func_name):
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">=</span> bytes<span style="color:#f92672">.</span>fromhex(<span style="color:#e6db74">&#39;56 57 8B F9 8B D7 8D 4A 01 8A 02 42 84 C0 75 F9 2B D1 8B F2 83 F6 20 83 FA 04 7C 4D 53 8B DA C1 EB 02 6B C3 FC 03 D0 0F B6 4F 03 0F B6 47 02 C1 E1 08 0B C8 69 F6 95 E9 D1 5B 0F B6 47 01 C1 E1 08 0B C8 0F B6 07 C1 E1 08 83 C7 04 0B C8 69 C9 95 E9 D1 5B 8B C1 C1 E8 18 33 C1 69 C8 95 E9 D1 5B 33 F1 83 EB 01 75 BF 5B 83 EA 01 74 1C 83 EA 01 74 0E 83 EA 01 75 1D 0F B6 47 02 C1 E0 10 33 F0 0F B6 47 01 C1 E0 08 33 F0 0F B6 07 33 C6 69 F0 95 E9 D1 5B 8B C6 C1 E8 0D 33 C6 69 C8 95 E9 D1 5B 5F 5E 8B C1 C1 E8 0F 33 C1&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span> <span style="color:#75715e"># skip code </span>
</span></span><span style="display:flex;"><span>    uc<span style="color:#f92672">.</span>mem_write(data_base, func_name)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Set function argument</span>
</span></span><span style="display:flex;"><span>    uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_ECX, data_base)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span> <span style="color:#75715e"># skip code</span>
</span></span><span style="display:flex;"><span>    uc<span style="color:#f92672">.</span>emu_start(target_base, target_end, timeout<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, count<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span> <span style="color:#75715e"># skip code</span>
</span></span><span style="display:flex;"><span>    EAX <span style="color:#f92672">=</span> uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EAX)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EAX
</span></span></code></pre></div><p>Let‚Äôs take a test. Using the <strong>LoadLibraryW</strong> name, we get back <strong>0xab87776c</strong>. If we explore a little bit our code, we will find almost immediately this value! it is called each time a new hash needs to be resolved.</p>
<p><img src="/img/api_hashing/loadLibrary_hash.png" alt="Figure 5: LoadLibraryW Hash"></p>
<p>Figure 5: LoadLibraryW Hash</p>
<p>This behavior is a clear indication that before proceeding to extract exported functions, we need to load the associated library (DLL) in memory. With that information we could be sure that our emulator works fine.</p>
<h3 id="build-a-rainbow-table">Build a rainbow table</h3>
<p>Building a rainbow table can be done in a few lines of code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>filter <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;ntdll.dll&#39;</span>]
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_all_export_function_from_dlls</span>():
</span></span><span style="display:flex;"><span>    exported_func <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> dirpath, dirnames, filenames <span style="color:#f92672">in</span> os<span style="color:#f92672">.</span>walk(<span style="color:#e6db74">&#34;C:</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Windows</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">System32&#34;</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> filename <span style="color:#f92672">in</span> [f <span style="color:#66d9ef">for</span> f <span style="color:#f92672">in</span> filenames <span style="color:#66d9ef">if</span> f <span style="color:#f92672">in</span> filter]:
</span></span><span style="display:flex;"><span>            path_to_dll <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>join(dirpath, filename)
</span></span><span style="display:flex;"><span>            pe <span style="color:#f92672">=</span> pefile<span style="color:#f92672">.</span>PE(path_to_dll)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> export <span style="color:#f92672">in</span> pe<span style="color:#f92672">.</span>DIRECTORY_ENTRY_EXPORT<span style="color:#f92672">.</span>symbols:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> export<span style="color:#f92672">.</span>name:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>: 
</span></span><span style="display:flex;"><span>                    exported_func[hex(MurMurHash2(export<span style="color:#f92672">.</span>name))] <span style="color:#f92672">=</span> export<span style="color:#f92672">.</span>name
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> exported_func
</span></span></code></pre></div><p>The code presented above should be pretty clear, however, I would like to point out the role of the <em><strong>filter</strong></em> variable*.* Emulation brings a lot of advantages to reverse engineering, nevertheless, it also has a drawback related to performance. In fact, code that contains an emulation routine could be tremendously slow, and if you don‚Äôt pay attention it could take forever. Using a filter variable keeps our code more flexible, resolving tailored functions names without wasting time.</p>
<blockquote>
<p>üí°<em>Of course, in this case we could look for libraries names used within the code. However, we could not be so lucky in the future. Because of that, I prefer to show a way that could be used in multiple situations.</em></p>
</blockquote>
<h2 id="automation">Automation</h2>
<p>Now that we have built almost all fundamental components, it‚Äôs time to combine everything in a single and effective script file. What we are still missing is a regular expression that is going to look for hashes and forward them to the MurMur2 emulator.</p>
<p>Observing the code, an easy pattern to follow involves a register and an immediate values:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> REG, IMM
</span></span></code></pre></div><p>Implementing this strategy and filtering results only on <em>kernel32.dll,</em> we are able to extract all referenced hashes:</p>
<p><img src="/img/api_hashing/hashes_resolved.png" alt="Figure 6: Some hashes related to Kernel32.dll "></p>
<p>Figure 6: Some hashes related to Kernel32.dll</p>
<h2 id="conclusion">Conclusion</h2>
<p>As always, going deep in each section requires an entire course and at the moment it‚Äôs an impossible challenge. However, through this blog post I tried to scratch the surface giving some essential concepts (that could be applied straightaway) to make reversing time a lot more fun.</p>
<p>Another important thing to highlight here, is related to combine emulation and scripting techniques. Emulation is great, however, writing a script that contains some emulated routine could be a challenging task if we think about efficiency. Writing a single script for a single sample its not a big deal and it won‚Äôt have a great impact in a single analysis, however, doing it a scale is a different kettle of fish.</p>
<p>That said, it‚Äôs time to conclude, otherwise, even reading this post could be a challenging task! :)</p>
<p>Have fun and keep reversing!</p>
<h2 id="references">References:</h2>
<p>Windows PE file format:</p>
<ul>
<li><a href="https://raw.githubusercontent.com/corkami/pics/master/binary/pe102/pe102.svg">PE file overview</a></li>
</ul>
<p>LummaStealer Hash resolver:</p>
<ul>
<li><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/LummaStealer/lummaStealer_v2_hash_resolver.py">lummaStealer_v2_hash_resolver.py</a></li>
</ul>
<p>LummaSteler sample:</p>
<ul>
<li><a href="https://bazaar.abuse.ch/sample/277d7f450268aeb4e7fe942f70a9df63aa429d703e9400370f0621a438e918bf/">MalwareBazaar</a></li>
</ul>
<h2 id="bonus">Bonus</h2>
<p>In order to understand how API Hashing works it‚Äôs very useful to make your hand dirty on low level components. However, once you have some experience, it is also very helpful to have some tools that speed up your analysis. An amazing project is <a href="https://github.com/OALabs/hashdb">HashDB</a> maintained by OALabs. It is a simple and effective plugin for IDA that is going to resolve hashes, if the routine is implemented. If you want to try out this plugin for this LummaStealer sample, my pull request has already been  merged ;)</p>
<h2 id="appendix-1---addressofnames">Appendix 1 - AddressOfNames</h2>
<p>The algorithm to retrieve the <strong>RVA</strong> associated to a function is quite straightforward:</p>
<ol>
<li>Iterate over the <strong>AddressOfNames</strong> structures.</li>
<li>Once you find a match with a specific function, suppose at <em>i</em> position, the loader is going to use index <em>i</em> to address the structure <strong>AddressOfNamesOrdinals</strong>.
<ol>
<li>k = AddressOfNamesOrdinals[i]</li>
</ol>
</li>
<li>After collecting the value stored in <strong>AddressOfNamesOrdinals</strong> (2.a) we could use that value to address <strong>AddressOfFunctions</strong>, collecting the actual RVA of the function we were looking for.
<ol>
<li><code>function_rva</code> = AddressOfFunctions[k]</li>
</ol>
</li>
</ol>
<p><img src="/img/api_hashing/functions_and_names_pointers.png" alt="Figure 7: How to retrieve functions names and pointers"></p>
<p>Figure 7: How to retrieve functions names and pointers</p>
<blockquote>
<p>üí°<em>If you want to experiment a little bit more with this concept, I suggest to take the kernel32.dll library and follows this algorithm using <a href="https://github.com/hasherezade/pe-bear">PE-Bear</a></em></p>
</blockquote>
]]></content>
        </item>
        
        <item>
            <title>Understanding PEB and LDR Structures using IDA and LummaStealer</title>
            <link>https://Viuleeenz.github.io/posts/2024/02/understanding-peb-and-ldr-structures-using-ida-and-lummastealer/</link>
            <pubDate>Sun, 04 Feb 2024 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2024/02/understanding-peb-and-ldr-structures-using-ida-and-lummastealer/</guid>
            <description>In this post I‚Äôm going to explain how Process Environment Block (PEB) is parsed by malware devs and how that structure is abused. Instead of going too deep into a lot of details, I would like to follow an easier approach pairing the theory with a practical real example using IDA and LummaStealer, without overwhelming the reader with a lot of technical details trying to simplify the data structure involved in the process.</description>
            <content type="html"><![CDATA[<p>In this post I‚Äôm going to explain how Process Environment Block (PEB) is parsed by malware devs and how that structure is abused. Instead of going too deep into a lot of details, I would like to follow an easier approach pairing the theory with a practical real example using IDA and LummaStealer, without overwhelming the reader with a lot of technical details trying to simplify the data structure involved in the process. At the end of the theory part, I‚Äôm going to <strong>apply PEB and all related structures in IDA</strong>, inspecting malware parsing capabilities that are going to be applied for resolving hashed APIs.</p>
<p>Let‚Äôs start.</p>
<h3 id="peb-structure">PEB Structure</h3>
<p>The PEB is a crucial data structure that contains various <strong>information</strong> about a <strong>running process</strong>. Unlike other Windows structure (e.g., EPROCESS, ETHREAD, etc..), it exists in the user address space and is available for every process at a <strong>fixed</strong> address in memory (PEB can be found at <code>fs:[0x30]</code> in the Thread Environment Block (TEB) for x86 processes as well as at <code>gs:[0x60]</code> for x64 processes). Some of documented fields that it‚Äôs worth knowing are:</p>
<ul>
<li>BeingDebugged: Whether the process is being debugged;</li>
<li><strong>Ldr</strong>: A pointer to a <code>PEB_LDR_DATA</code> structure providing information about loaded modules;</li>
<li>ProcessParameters: A pointer to a <code>RTL_USER_PROCESS_PARAMETERS</code> structure providing information about process startup parameters;</li>
<li>PostProcessInitRoutine: A pointer to a callback function called after DLL initialization but before the main executable code is invoked</li>
</ul>
<h3 id="image-loader-aka-ldr">Image Loader aka Ldr</h3>
<p>When a process is started on the system, the kernel creates a process object to represent it and performs various kernel-related initialization tasks. However, these tasks do not result in the execution of the application, but in the <strong>preparation of its context and environment</strong>. This work is performed by the <em><strong>image loader</strong></em> (<strong>Ldr</strong>).</p>
<p>The loader is responsible for several main tasks, including:</p>
<ul>
<li>Parsing the import address table (IAT) of the application to look for all DLLs that it requires (and then recursively parsing the IAT of each DLL), followed by parsing the export table of the DLLs to make sure the function is actually present.</li>
<li>Loading and unloading DLLs at runtime, as well as on demand, and maintaining a list of all
loaded modules (the module database).</li>
</ul>
<p><img src="/img/peb_parsing/list_structure.png" alt="Figure 1: PEB, LDR_DATA and LDR_MODULE interactions"></p>
<p>Figure 1: PEB, LDR_DATA and LDR_MODULE interactions</p>
<p>At first glance, these structures might seem a little bit confusing. However, let&rsquo;s simplify them to make them more understandable. We could think about them as a <strong>list where the structure PEB_LDR_DATA is the head of the list</strong> and <strong>each module information is accessed through a double linked list</strong> (<em>InOrderLoaderModuleList</em> in this case) that points to <strong>LDR_MODULE</strong>.</p>
<h3 id="how-those-structures-are-abused">How those structures are abused</h3>
<p>Most of the times when we see <strong>PEB and LDR_MODULE structure parsing</strong> we are dealing with malwares that are potentially using <strong>API Hashing technique.</strong> Shellcode will typically walk through those structures in order to find the base address of loaded dlls and extract all their exported functions, collecting names and <strong>pointers to the functions that are intended to call</strong>, avoiding to leave direct reference of them within the malware file.</p>
<p>This is a simple trick that tries to evade some basic protections mechanism that could arise when we see clear references to malware-related functions such as: <em>VirtualAlloc, VirtualProtect, CreateProcessInterW, ResumeThread, etc‚Ä¶</em></p>
<h3 id="api-hashing">API Hashing</h3>
<p>By employing API hashing, malware creators can ensure that specific Windows APIs remain hidden from casual observation. Through this approach, malware developers try to add an extra layer of complexity by concealing suspicious Windows API calls within the Import Address Table (IAT) of PE.</p>
<p>API hashing technique is pretty straightforward and it could be divided in three main steps:</p>
<ol>
<li><em>Malware developers prepare a set of hashes corresponding to WINAPI functions.</em></li>
<li><em>When an API needs to be called, it looks for loaded modules through the PEB.Ldr structure.</em></li>
<li><em>Then, when a module is find, it goes through all the functions performing the hash function until the result matches with the given input.</em></li>
</ol>
<p><img src="/img/peb_parsing/api_hashing_overview.png" alt="Figure 2: API Hashing Overview"></p>
<p>Figure 2: API Hashing Overview</p>
<p>Now that we have a more understanding of the basic concepts related to API hashing, PEB and Ldr structures, let‚Äôs try to put them in practice using LummaStealer as an example.</p>
<h3 id="parsing-peb-and-ldr-with-lummastealer">Parsing PEB and LDR with LummaStealer</h3>
<p>Opening up the sample in IDA and scrolling a little after the main function it is possible to bump into very interesting functions that perform some actions on a couple of parameters that are quite interesting and correlated to explanation so far.</p>
<p><img src="/img/peb_parsing/sus_hash.png" alt="Figure 3: Wrapper function for hash resolving routine in LummaStealer"></p>
<p>Figure 3: Wrapper function for hash resolving routine in LummaStealer</p>
<p>Before function <em><strong>call sub_4082D3</strong></em> (highlighted) we could see some mov operation of two values:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span> <span style="color:#a6e22e">mov</span> edx, aKernel32Dll_0
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">...</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">mov</span> ecx, <span style="color:#ae81ff">0x7328f505</span>
</span></span></code></pre></div><p>Those parameters are quite interesting because:</p>
<ul>
<li>The former represents an interesting dll that contains some useful functions such as <em>LoadLibrary, VirtualAlloc, etc..</em></li>
<li>The latter appears to be a hash (maybe correlated to the previous string).</li>
</ul>
<p>If we would like to make an educated guess, it is possible that this function is going to find a function (within <em>kernel32.dll</em>) whose hash corresponds to the input hash. However, let‚Äôs try to understand if and how those parameters are manipulated in the function call, validating also our idea.</p>
<p><img src="/img/peb_parsing/code_compare.png" alt="Figure 4: Parsing PEB and LDR_MODULE for API hash routine. "></p>
<p>Figure 4: Parsing PEB and LDR_MODULE for API hash routine.</p>
<p>Through Figure 6, you can see the exact same code, before (left side) and after (right side) renaming structures. Examining the code a little bit we should be able to recall the concepts already explained in the previous sections.</p>
<p>Let‚Äôs examine the first block of code. Starting from the top of the code we could spot the instruction <code>mov eax, (large)fs:30h</code>  that is going to collect the <strong>PEB pointer</strong>, storing its value in <strong>eax.</strong> Then, right after this instruction we could see <strong>eax</strong> <strong>used with an offset</strong>(<strong>0xC</strong>). In order to understand what is going on, its possible to collect the PEB structure  and look for the 0xC offset. Doing that, it‚Äôs clear that <strong>eax is going to collect the Ldr pointer</strong>. The last instruction of the first block is <code>mov edi, [eax+10h]</code> . This is a crucial instruction that needs a dedicated explanation:</p>
<p>If you are going to look at <strong>PEB_LDR_DATA</strong> you will see that 0x10 offset (for x64 bit architecture)  points to <strong>InLoadOrderModuleList</strong> (that contains, according to its description, <code>pointers to previous and next LDR_MODULE in initialization order</code>). Through this instruction, malware is going to take a <strong>LDR_MODULE</strong> structure (as explained in Figure 3), settling all the requirements to parse it.</p>
<p>Without going too deep in the code containing the loop (this could be left as an exercise), it is possible to see that the next three blocks are going to find the <em>kernel32.dll</em> iterating over the <strong>LDR_MODULE</strong> structure parameters.</p>
<p>At the very end of the code, we could see the last block calling a function using the dll pointers retrieved through the loop, using another hash value. This behavior give us another chance for a couple of insight:</p>
<ul>
<li>This code is a candidate to settle all parameters that are going to be used for API hash resolving routine (as illustrated in the API Hashing section), since that its output will be used as a function call.</li>
<li>The string <em>kernel32.dll</em> gave us some hints about possible candidate functions (e.g., <em>LoadLibraryA, VirtualAlloc, etc..</em>).</li>
</ul>
<p>With this last consideration, it&rsquo;s time to conclude this post avoiding adding more layers of complexity, losing our focus on PEB and related structures.</p>
<h3 id="function-recap">Function recap</h3>
<p>Before concluding, let‚Äôs try to sum up, what we have seen so far, in order to make the analysis even more clear:</p>
<ol>
<li>The function <code>4082D3</code> takes <strong>two parameters</strong> that are a hash <strong>value</strong> and a string containing a <strong>dll library</strong>.</li>
<li>Iterating over the loaded modules, it looks for the module name containing the hardcoded <strong>kernel32.dll</strong>.</li>
<li>Once the module is found, it invokes another function (<code>40832A</code>), passing a pointer to the base address of the module and a hash value.</li>
<li>The function returns a pointer to a function that takes as an argument the <strong>dll name passed to</strong> 4082D3. This behavior suggests that some sort of <em>LoadLibrary</em> has been resolved on point 3.</li>
<li>As a final step, the function <code>40832A</code> is called once again, using the hash value passed as a parameter in the function <code>4082D3</code> and a base address retrieved from the point 4.</li>
</ol>
<p>Following all the steps it&rsquo;s easy to spot that the <code>40832A</code> function is the actual API hash resolving routine and the function <code>4082D3</code> has been used to settle all the required variables.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Through this blog post I tried to explain a little bit better how the PEB and related structures are parsed and abused by malwares. However, I also tried to show how malware analysis could be carried out examining the code and renaming structures accordingly. This brief introduction will be also used as a starting point for the next article where I would like to take the same sample and emulate the API hashing routine in order to resolve all hashes, making this sample ready to be analyzed.</p>
<h3 id="note-about-simplification">Note about simplification</h3>
<p>It‚Äôs worth mentioning that to make those steps easier, there has been a simplification. In fact, PEB_LDR_DATA contains three different structures that could be used to navigate modules, but for this blogpost, their use could be ignored. Another structure that is worth mentioning it‚Äôs LDR_DATA_TABLE_ENTRY that could be considered a corresponding to the LDR_MODULE structure.</p>
<h3 id="references">References:</h3>
<p>Undocumented Windows Internal Structures:</p>
<ul>
<li><a href="http://undocumented.ntinternals.net/">The Undocumented Functions</a></li>
<li><a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntpsapi_x/peb_ldr_data.htm">PEB_LDR_DATA</a></li>
</ul>
<p>LummaSteler sample:</p>
<ul>
<li><a href="https://bazaar.abuse.ch/sample/277d7f450268aeb4e7fe942f70a9df63aa429d703e9400370f0621a438e918bf/">MalwareBazaar</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Applied Emulation - Decrypting Ursnif strings with Unicorn</title>
            <link>https://Viuleeenz.github.io/posts/2023/12/applied-emulation-decrypting-ursnif-strings-with-unicorn/</link>
            <pubDate>Wed, 20 Dec 2023 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2023/12/applied-emulation-decrypting-ursnif-strings-with-unicorn/</guid>
            <description>Introduction Here we go with another chapter of the Applied Emulation series. In the previous blogpost we have talked about emulation and more specifically, the usage of Dumpulator to perform a quick triage. However, in this blogpost we are going to use a completely different approach, taking advantage of static analysis to understand and emulate a string decryption algorithm through Unicorn. As always, I would like to give a practical example on a real case scenario.</description>
            <content type="html"><![CDATA[<h3 id="introduction">Introduction</h3>
<p>Here we go with another chapter of the Applied Emulation series. In the previous blogpost we have talked about emulation and more specifically, the usage of <em>Dumpulator</em> to perform a quick triage. However, in this blogpost we are going to use a completely different approach, taking advantage of <strong>static analysis to</strong> <strong>understand and emulate a string decryption algorithm through <a href="https://www.unicorn-engine.org/">Unicorn</a></strong>. As always, I would like to give a practical example on a real case scenario. Because of that, I have chosen to analyze an <strong>Ursnif</strong> sample.</p>
<p>It‚Äôs worth mentioning that this sample is part of weekly challenges related to the <a href="https://courses.zero2auto.com/">Zero2Auto</a> course. However, instead of automating the full code extraction, as requested by the challenge, I found even more interesting going into unexplored paths applying emulation instead.</p>
<h3 id="unicorn-challenges">Unicorn challenges</h3>
<p>Using pure static analysis came with few limitations, in fact, Unicorn is a CPU emulator framework that does not have built in capabilities to invoke syscall directly. Because of that we need to overcome at least a couple of challenges before emulating our code:</p>
<ul>
<li>
<p>The first and probably the most challenging constraint is that we are going to emulate CPU instructions, instead of using direct calls to Windows API. Because of that, we need to choose our code carefully.</p>
</li>
<li>
<p>After that we have identified a candidate algorithm, we still need to set up the emulation environment variables (e.g., stack memory, registers, sections, start and end code, algorithm parameters, etc‚Ä¶).</p>
</li>
</ul>
<p>Speaking about ‚Äúgood candidate function‚Äù, we could look for a custom and self-contained algorithm. Even if those requirements seem to be strict constraints, an experienced reverser knows that most of the malware out there have these components as a part of their decryption routine. However, let‚Äôs take a step back. Someone may wonder why we don&rsquo;t use Dumpulator instead of Unicorn, considering all these limitations. The answer is straightforward:</p>
<p><strong>Dumpulator may not be usable if we are unable to run the code</strong> and set up the user mode space. Nevertheless, I strongly believe that it is more <strong>important to understand where and when a technique should be applied</strong>, even if it adds a few layers of complexity, rather than rushing for the easiest or the first solution that comes to our mind.</p>
<h3 id="ursnif-decryption-routine">Ursnif decryption routine</h3>
<p>Decryption routine is pretty straightforward to locate, it just follows the campaignDate variable that is going to be used as a decryption key for the .bss segment. Key generation algorithm has been already described <a href="https://www.0ffset.net/reverse-engineering/challenge-1-gozi-string-crypto/">here</a>, however, I would like to focus on the decryption routine itself, in order to understand all requirements to emulate this code.</p>
<p><img src="/img/emulation_ursnif/decryption_routine_explained.png" alt="Figure 1: Decryption routine explained">
Figure 1: Decryption routine explained</p>
<p>At the first glance we could see that the function is self-contained and most of the operations are simple math (sub, add) that involves the key and the encrypted data. However, before proceeding it&rsquo;s important to have a look at the following instruction:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> [ecx], eax
</span></span></code></pre></div><p><strong>[ecx] is going to be the place to save the output of each decrypted byte</strong>. Nevertheless, ecx is also used as a counter to get the next byte from the <strong>.bss segment</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> eax, [edx<span style="color:#f92672">+</span>ecx]
</span></span></code></pre></div><p>Because of that we need to handle that situation very carefully. In fact, <strong>if we do not consider those instructions, we are going to have an access memory violation</strong> with ecx pointing to an unallocated memory region. In order to solve this issue, there are two ways:</p>
<ul>
<li>Allocating memory at <strong>0x000000</strong>. In this case, ecx will be used as a counter and as a pointer without any issue;</li>
<li>Otherwise, we could use a <strong>hook</strong> on our emulator that is going to analyze each instruction and when we are dealing with <strong>[ecx]</strong>, we could skip that instruction, redirecting the decrypted output towards another variable.</li>
</ul>
<p>For this blogpost we are going to use the first solution. Considering this post as an introduction of Unicorn, I don‚Äôt want to overwhelm readers with a lot of content (setting up the environment will be quite challenging to follow). It‚Äôs always good to master some basic concept before proceeding towards more advanced techniques</p>
<h3 id="setting-up-emulation-environment">Setting up emulation environment</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> unicorn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> unicorn.x86_const <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> pefile
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> struct
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>file_data <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#39;unpacked_ursnif.bin&#39;</span>,<span style="color:#e6db74">&#39;rb&#39;</span>)<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>pe <span style="color:#f92672">=</span> pefile<span style="color:#f92672">.</span>PE(data<span style="color:#f92672">=</span>file_data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> pe<span style="color:#f92672">.</span>sections:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;.bss&#39;</span> <span style="color:#f92672">in</span> s<span style="color:#f92672">.</span>Name[:<span style="color:#ae81ff">6</span>]: 
</span></span><span style="display:flex;"><span>        bss_virtual_address <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span>VirtualAddress
</span></span><span style="display:flex;"><span>        bss_section_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1000</span>
</span></span><span style="display:flex;"><span>        bss_section_data <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span>get_data()
</span></span></code></pre></div><p>First of all we need to import the Unicorn module and also unicorn constants that we are going to use to interact with registers. Then we could use the pefile module to load our bin file and take notes of <strong>.bss segment data.</strong>.</p>
<p>Then, we need to take the whole code that needs to be emulated. Before proceeding, it&rsquo;s important to keep in mind that emulation is quite slow and we need to use only the code needed for our purpose. For instance, prolog and epilogue instructions are not very useful for us, since we are emulating a single function without knowing any information about previous ESP and EBP values. Because of that we could skip them.</p>
<p>To get the proper bytes, with IDA, we could highlight the code that is going to be emulated and, using <strong>shift+e</strong>, spawn a popup with all selected bytes, ready to be pasted in our code.</p>
<p><img src="/img/emulation_ursnif/select_code_to_emulate.png" alt="Figure 2: Select code to emulate">
Figure 2: Select code to emulate</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>code <span style="color:#f92672">=</span> bytes<span style="color:#f92672">.</span>fromhex(<span style="color:#e6db74">&#39;8B040A8BF885C0750AC744241001000000EB0D2B74240C03C689018BF783C104FF4C241075DA&#39;</span>)
</span></span></code></pre></div><p>Now things are starting to heat up, trying to settle our emulation. First of all, we need to instantiate Unicorn, then we need to set up stack memory, ESP, data memory (using .bss content) and then fill the code section with our bytes. To make it easier to read, I have split the whole script in multiple parts, as follow:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Unicorn emulator setup.</span>
</span></span><span style="display:flex;"><span>uc <span style="color:#f92672">=</span> Uc(UC_ARCH_X86, UC_MODE_32)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stack_base <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00100000</span>
</span></span><span style="display:flex;"><span>stack_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00100000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ESP is moved in the middle of the stack in order to handle.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># instruction that uses ESP as base address (e.g., [esp + 0xc]).</span>
</span></span><span style="display:flex;"><span>ESP <span style="color:#f92672">=</span> stack_base <span style="color:#f92672">+</span> (stack_size <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Map the stack memory into the emulator and feed it with null byte.</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_map(stack_base, stack_size)
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_write(stack_base, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> stack_size)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Write python variable ESP in emulator ESP register.</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_ESP, ESP) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>data_base <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00200000</span>
</span></span><span style="display:flex;"><span>data_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00100000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Map the data memory with r/w/x permissions avoiding access violation.</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_map(data_base, data_size, UC_PROT_ALL)
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_write(data_base, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> data_size)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Data section needs to be filled with .bss data.</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_write(data_base, bss_section_data)
</span></span></code></pre></div><p>Through this snippet of code, we have prepared everything related to the stack and data section. More precisely, with <strong>uc.mem_map</strong> we have mapped a memory address with its size and protections ( rwx permissions have been chosen to avoid exceptions).</p>
<p>It‚Äôs worth mentioning that, what really makes those memories different is the ESP register that represents a pointer onto the stack. However, under the hood, there are no differences between the allocated memories.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># ----- Arguments Setup --------- #</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Setting up key parameter.</span>
</span></span><span style="display:flex;"><span>key <span style="color:#f92672">=</span> gen_key(bss_virtual_address)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Generate key bytes.</span>
</span></span><span style="display:flex;"><span>key_bytes <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#39;&lt;I&#39;</span>, key)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Write key byte on the stack.</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_write(ESP, key_bytes)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># key bytes are located at ESP+0xC.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># To handle that istrution properly, we need to shift ESP of 0xC bytes.</span>
</span></span><span style="display:flex;"><span>ESP <span style="color:#f92672">-=</span> <span style="color:#ae81ff">0xC</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># EDX is going to be used as a pointer to the encrypted data.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># It will be used as a base address: [edx + ecx].</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># It needs to be initialized at base address of our data.</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_EDX, data_base)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ECX is a counter starting from 0.</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_ECX, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Write new stack position.</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_ESP, ESP)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ----- Arguments Setup End ----- #</span>
</span></span></code></pre></div><p>In order to get the key, we have called a gen_key routine (omitted here, to focus on emulation setup) that is going to return a string containing the decryption key. Then, once we get the key, we have to store it on the stack, respecting the <a href="https://docs.python.org/3/library/struct.html">little endian format</a>. Along with key parameters we have also settled all other arguments needed for the function, such as: encrypted data (edx), counter (ecx) as well as updated the esp according to the instruction [esp+0xC] that is going to take the key bytes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># ---- Handling ECX access violation ---- #</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># mov [ecx], eax.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>decrypted_base <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000000</span>
</span></span><span style="display:flex;"><span>decrypted_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00100000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_map(decrypted_base, decrypted_size, UC_PROT_ALL)
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_write(decrypted_base, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> decrypted_size)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -- Handling ECX access violation end -- #</span>
</span></span></code></pre></div><p>As mentioned above, since that ecx will be either a pointer and a counter, we are going to create a memory space located to <strong>0x00000000</strong>. In this case, when we are going to deal with   <strong>mov [ecx] ,eax</strong> instruction, we will avoid any exception.</p>
<p>To conclude we need to setup memory for our code. This is a pretty straightforward task if have followed the previous steps. Map the code address, fill it with null bytes and then write the bytes stored in the code variable.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>code_base <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00400000</span>
</span></span><span style="display:flex;"><span>code_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00100000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Map target memory with r/w/x permissions</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_map(code_base, code_size, UC_PROT_ALL)
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_write(code_base, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> code_size)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Write our code into the target memory</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_write(code_base, code)
</span></span><span style="display:flex;"><span>code_end <span style="color:#f92672">=</span> code_base <span style="color:#f92672">+</span> len(code)
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>emu_start(code_base, code_end, timeout<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, count<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span></code></pre></div><p>Now we have satisfied all setting requirements for our emulation and its time to test it out.</p>
<h3 id="testing">Testing</h3>
<p>Running our emulator against few Ursnif samples reveal that we have correctly settled all the environment variables. As you can see from the image below, it has been possible to retrieve all encrypted strings. Some of them could be very useful in order to do a step further in our analysis, since that we have references to infrastructure, powershell script as well as network requests template.</p>
<p><img src="/img/emulation_ursnif/decrypted_strings.png" alt="Figure 3: Decrypted strings">
Figure 3: Decrypted strings</p>
<h3 id="conclusion--further-development">Conclusion &amp; Further Development</h3>
<p>Emulation is a powerful tool, like a swiss knife, and it needs to be considered anytime we are dealing with malware automation. I hope that some of you had fun reading this post and learnt something new, to the point that you can&rsquo;t wait to apply this technique to your own sample.</p>
<p>I‚Äôm still planning to write some structured content about this topic. I don‚Äôt have a deadline for that but it is in my new year resolution list! In the meantime, keep reversing!</p>
<h3 id="references">References</h3>
<p>Sample analyzed:</p>
<ul>
<li><a href="https://www.unpac.me/results/3a3eb893-10fe-42c1-a2c4-5d86cc572fa4#/">Unpacme</a></li>
<li><a href="https://bazaar.abuse.ch/sample/413cf6a694eef7a4f1725a11938f1ab2df1957bfb3bf20cf6a47017bebbad2a9/">MalwareBazaar</a></li>
</ul>
<p>Unicorn:</p>
<ul>
<li><a href="https://www.unicorn-engine.org/">Unicorn engine</a></li>
</ul>
<p>Emulator:</p>
<ul>
<li><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/Ursnif/ursnif_emulate_decryption.py">ursnif_string_decryptor.py</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Applied Emulation - Analysis of MarsStealer</title>
            <link>https://Viuleeenz.github.io/posts/2023/11/applied-emulation-analysis-of-marsstealer/</link>
            <pubDate>Wed, 15 Nov 2023 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2023/11/applied-emulation-analysis-of-marsstealer/</guid>
            <description>Introduction Emulation is a technique that could be very handy and effective when we have to deal with malware triage, configuration extractor and deobfuscate part of the code without rewriting complex algorithms. Even if it seems magic (and it&amp;rsquo;s not unfortunately) it&amp;rsquo;s still not possible to apply emulation on random code. However, if applied correctly this method could really speed up our malware analysis and triage. Through this blogpost I would like to give an overview about emulation usage and apply it in a real case scenario.</description>
            <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p><strong>Emulation is a technique that could be very handy and effective</strong> when we have to deal with <strong>malware triage</strong>, <strong>configuration extractor</strong> and <strong>deobfuscate part of the code without rewriting complex algorithms</strong>. Even if it seems magic (and it&rsquo;s not unfortunately) it&rsquo;s still not possible to apply emulation on random code. However, if applied correctly this method could really speed up our malware analysis and triage. Through this blogpost I would like to give an overview about emulation usage and apply it in a real case scenario.</p>
<p>Recently, I followed a twitter warning about Vidar malware in the wild and eager to revalidate an IDA-python script to deobfuscate strings, I immediately jumped into it. However, extracting that sample it was pretty obvious that I was dealing with another stealer, called MarsStealer. Since I did have a lot of information about that sample, I thought that could be a good choice to experiment with emulation. The result was quite promising and because of that <strong>I want to take this occasion to show a few basic emulations that could, hopefully, help someone else to speed up its analysis</strong>.</p>
<h3 id="payload-extraction">Payload extraction</h3>
<p>Opening up in IDA the original sample, it was clear that a lot of strings were actually obfuscated and the code was partially packed, because of the references to jumps or calls towards registries and un-initialized DWORD.</p>
<p><img src="/img/mars_stealer/ms_ida_packed_code.png" alt="Figure 1: MarsStealer packed code"></p>
<p>Figure 1: MarsStealer packed code</p>
<p>In order to extract the actual payload that will contain a deobfuscation string routine and additional code, it&rsquo;s necessary to go for dynamic analysis and speed up our extraction. As always one of the quickest methods to extract unpacked information is to look for <strong>VirtualAlloc</strong> and <strong>VirtualProtect.</strong></p>
<p><img src="/img/mars_stealer/ms_unpacked_payload.png" alt="Figure 2: Unpacked payload retrieved"></p>
<p>Figure 2: Unpacked payload retrieved</p>
<h3 id="deobfuscation-routine-analysis">Deobfuscation routine analysis</h3>
<p>Since that our purpose is to find out code to emulate, we could look for a deobfuscation routine within the payload extracted. Our search won‚Äôt last long because, almost <strong>immediately after the VirtualProtect</strong> call the malware jumps directly to the allocated memory, <strong>starting the name resolving routine.</strong></p>
<p><img src="/img/mars_stealer/ms_deobfuscation_wrapper.png" alt="Figure 3: Deobfuscation wrapper"></p>
<p>Figure 3: Deobfuscation wrapper</p>
<p>The highlighted function is a wrapper that contains the actual routine. The code is quite easy to spot because of the <strong>three push instructions</strong>. Opening the payload in IDA, it&rsquo;s possible to go a little bit deeper and explore the deobfuscation routine, reconstructing its signature and from that point, understanding the function flow.</p>
<p><img src="/img/mars_stealer/ms_deobfuscation_routine.png" alt="Figure 4: Deobfuscation routine"></p>
<p>Figure 4: Deobfuscation routine</p>
<p>Regardless of the red box related memory errors, it&rsquo;s very easy to understand its core functionality and control flow. However, even if it seems quite easy to reconstruct its logic, I‚Äôm going to take this code as a use case to try a completely different approach, using <strong>emulation to resolve all the strings</strong>.</p>
<h3 id="emulation-requirements">Emulation requirements</h3>
<p>Before proceeding with emulation, there are few things to settle. The first one is that for emulating this code, we need to emulate the user mode because we are dealing with instructions that are going to make additional <strong>calls to WindowsAPI</strong>. For that reason, we are going to use <a href="https://github.com/mrexodia/dumpulator">dumpulator</a>, implementing if needed some API calls. The second thing to talk about are <strong>the requirements for dumpulator</strong>. To make it effective, it&rsquo;s necessary to take a <strong>minidump</strong> of the process that we are analyzing and understand the parameters for <strong>starting</strong> and <strong>stopping</strong> <strong>emulation</strong>.</p>
<ul>
<li>In order to <strong>take a minidump</strong>, its possible to use <strong><strong><strong><strong><strong><strong>x32dbg/x64dbg</strong></strong></strong></strong></strong></strong> that include it as a command (e.g., minidump  mstealer.dump);</li>
<li>then to take the <strong>starting point</strong>, it‚Äôs possible to take references to deobfuscation calls and save those addresses for later.</li>
</ul>
<p><img src="/img/mars_stealer/ms_references_to_deobfuscation_function.png" alt="Figure 5: References to deobfuscation function"></p>
<p>Figure 5: References to deobfuscation function</p>
<p>Now that we have two out of three requirements, it&rsquo;s necessary to focus on the <strong>emulation ending point</strong>. Of course, this one is the most important requirement and could impact your result in terms of efficiency (emulation is tremendously slow) and code writing (could be required to write more code that fits your needs).</p>
<p>For the purpose of this analysis/tutorial about emulation I‚Äôm going straight to the point using <strong>hints collected from IDA</strong> and doing some dynamic code analysis.</p>
<h3 id="emulation-ending-point-extraction">Emulation ending point extraction</h3>
<p>Observing carefully the Figure 4, it&rsquo;s easy to spot that the plaintext string is settled <strong>after the for loop</strong> and <strong>before the VirtualProtect call</strong>. Looking at the assembly with the information acquired, it‚Äôs easy to understand that emulation should stop at the instruction <strong>push ecx</strong>. In fact, <strong>ecx register is going to be a pointer for the plaintext string</strong>.</p>
<p><img src="/img/mars_stealer/ms_plaintext_resolution.png" alt="Figure 6: Plaintext resolution"></p>
<p>Figure 6: Focus on plaintext resolution</p>
<p>With all this information, the <strong>emulation end variable</strong> could be easily retrieved within the debugger at the address <strong>0x031f4De5</strong>.</p>
<p><img src="/img/mars_stealer/ms_end_address.png" alt="Figure 7: Emulation stop address"></p>
<p>Figure 7: Emulation stop address</p>
<h3 id="string-resolving-automation">String Resolving Automation</h3>
<p>Since that we have collected all the requirements for the emulation, we are ready to setup our code as follow:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#Dumpulator libraries</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> dumpulator <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> dumpulator.native <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> dumpulator.handles <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> dumpulator.memory <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">deobfuscate</span>(address):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    start:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            [x] push ciphertext
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                push key
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                push key_length
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    end:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            [x] push ecx
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            call VirtualProtect
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    end <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x031F4DE5</span>
</span></span><span style="display:flex;"><span>    dp <span style="color:#f92672">=</span> Dumpulator(<span style="color:#e6db74">&#34;mars_stealer.dump&#34;</span>,quiet<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>    dp<span style="color:#f92672">.</span>start(address,  end<span style="color:#f92672">=</span>end )
</span></span><span style="display:flex;"><span>    out <span style="color:#f92672">=</span> dp<span style="color:#f92672">.</span>read_str(dp<span style="color:#f92672">.</span>regs<span style="color:#f92672">.</span>ecx)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> out
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>starting_points <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0x031F2E46</span>,<span style="color:#ae81ff">0x031F2E5F</span>,<span style="color:#ae81ff">0x031F2E78</span>,<span style="color:#ae81ff">0x031F2E91</span>,<span style="color:#ae81ff">0x031F2EAA</span>,<span style="color:#ae81ff">0x031F2EC3</span>,<span style="color:#ae81ff">0x031F2EDC</span>,<span style="color:#ae81ff">0x031F2EF5</span>,<span style="color:#ae81ff">0x031F2F0E</span>,<span style="color:#ae81ff">0x031F2F27</span>,<span style="color:#ae81ff">0x031F2F40</span>,<span style="color:#ae81ff">0x031F2F59</span>,<span style="color:#ae81ff">0x031F2F72</span>,<span style="color:#ae81ff">0x031F2F8B</span>,<span style="color:#ae81ff">0x031F2FA4</span>,<span style="color:#ae81ff">0x031F2FBD</span>,<span style="color:#ae81ff">0x031F2FD6</span>,<span style="color:#ae81ff">0x031F2FEF</span>,<span style="color:#ae81ff">0x031F3008</span>,<span style="color:#ae81ff">0x031F3021</span>,<span style="color:#ae81ff">0x031F303A</span>,<span style="color:#ae81ff">0x031F3053</span>,<span style="color:#ae81ff">0x031F306C</span>,<span style="color:#ae81ff">0x031F3085</span>,<span style="color:#ae81ff">0x031F309E</span>,<span style="color:#ae81ff">0x031F30B7</span>,<span style="color:#ae81ff">0x031F30D0</span>,<span style="color:#ae81ff">0x031F30E9</span>,<span style="color:#ae81ff">0x031F3102</span>,<span style="color:#ae81ff">0x031F311B</span>,<span style="color:#ae81ff">0x031F3134</span>,<span style="color:#ae81ff">0x031F314D</span>,<span style="color:#ae81ff">0x031F3166</span>,<span style="color:#ae81ff">0x031F317F</span>,<span style="color:#ae81ff">0x031F3198</span>,<span style="color:#ae81ff">0x031F31B1</span>,<span style="color:#ae81ff">0x031F31CA</span>,<span style="color:#ae81ff">0x031F31E3</span>,<span style="color:#ae81ff">0x031F3206</span>,<span style="color:#ae81ff">0x031F321F</span>,<span style="color:#ae81ff">0x031F3238</span>,<span style="color:#ae81ff">0x031F3251</span>,<span style="color:#ae81ff">0x031F326A</span>,<span style="color:#ae81ff">0x031F3283</span>,<span style="color:#ae81ff">0x031F329C</span>,<span style="color:#ae81ff">0x031F32B5</span>,<span style="color:#ae81ff">0x031F32CE</span>,<span style="color:#ae81ff">0x031F32E7</span>,<span style="color:#ae81ff">0x031F3300</span>,<span style="color:#ae81ff">0x031F3319</span>,<span style="color:#ae81ff">0x031F3332</span>,<span style="color:#ae81ff">0x031F334B</span>,<span style="color:#ae81ff">0x031F3364</span>,<span style="color:#ae81ff">0x031F337D</span>,<span style="color:#ae81ff">0x031F3396</span>,<span style="color:#ae81ff">0x031F33AF</span>,<span style="color:#ae81ff">0x031F33C8</span>,<span style="color:#ae81ff">0x031F33E1</span>,<span style="color:#ae81ff">0x031F33FA</span>,<span style="color:#ae81ff">0x031F3413</span>,<span style="color:#ae81ff">0x031F342C</span>,<span style="color:#ae81ff">0x031F3445</span>,<span style="color:#ae81ff">0x031F345E</span>,<span style="color:#ae81ff">0x031F3477</span>,<span style="color:#ae81ff">0x031F3490</span>,<span style="color:#ae81ff">0x031F34A9</span>,<span style="color:#ae81ff">0x031F34C2</span>,<span style="color:#ae81ff">0x031F34DB</span>,<span style="color:#ae81ff">0x031F34F4</span>,<span style="color:#ae81ff">0x031F350D</span>,<span style="color:#ae81ff">0x031F3526</span>,<span style="color:#ae81ff">0x031F353F</span>,<span style="color:#ae81ff">0x031F3558</span>,<span style="color:#ae81ff">0x031F3571</span>,<span style="color:#ae81ff">0x031F358A</span>,<span style="color:#ae81ff">0x031F35A3</span>,<span style="color:#ae81ff">0x031F35BC</span>,<span style="color:#ae81ff">0x031F35D5</span>,<span style="color:#ae81ff">0x031F35EE</span>,<span style="color:#ae81ff">0x031F3607</span>,<span style="color:#ae81ff">0x031F3620</span>,<span style="color:#ae81ff">0x031F3639</span>,<span style="color:#ae81ff">0x031F3652</span>,<span style="color:#ae81ff">0x031F366B</span>,<span style="color:#ae81ff">0x031F3684</span>,<span style="color:#ae81ff">0x031F369D</span>,<span style="color:#ae81ff">0x031F36B6</span>,<span style="color:#ae81ff">0x031F36CF</span>,<span style="color:#ae81ff">0x031F36E8</span>,<span style="color:#ae81ff">0x031F3701</span>,<span style="color:#ae81ff">0x031F371A</span>,<span style="color:#ae81ff">0x031F3733</span>,<span style="color:#ae81ff">0x031F374C</span>,<span style="color:#ae81ff">0x031F3765</span>,<span style="color:#ae81ff">0x031F377E</span>,<span style="color:#ae81ff">0x031F3797</span>,<span style="color:#ae81ff">0x031F37B0</span>,<span style="color:#ae81ff">0x031F37C9</span>,<span style="color:#ae81ff">0x031F37E2</span>,<span style="color:#ae81ff">0x031F37FB</span>,<span style="color:#ae81ff">0x031F3814</span>,<span style="color:#ae81ff">0x031F382D</span>,<span style="color:#ae81ff">0x031F3846</span>,<span style="color:#ae81ff">0x031F385F</span>,<span style="color:#ae81ff">0x031F3878</span>,<span style="color:#ae81ff">0x031F3891</span>,<span style="color:#ae81ff">0x031F38AA</span>,<span style="color:#ae81ff">0x031F38C3</span>,<span style="color:#ae81ff">0x031F38DC</span>,<span style="color:#ae81ff">0x031F38F5</span>,<span style="color:#ae81ff">0x031F390E</span>,<span style="color:#ae81ff">0x031F3927</span>,<span style="color:#ae81ff">0x031F3940</span>,<span style="color:#ae81ff">0x031F3959</span>,<span style="color:#ae81ff">0x031F3972</span>,<span style="color:#ae81ff">0x031F398B</span>,<span style="color:#ae81ff">0x031F39A4</span>,<span style="color:#ae81ff">0x031F39BD</span>,<span style="color:#ae81ff">0x031F39D6</span>,<span style="color:#ae81ff">0x031F39EF</span>,<span style="color:#ae81ff">0x031F3A08</span>,<span style="color:#ae81ff">0x031F3A21</span>,<span style="color:#ae81ff">0x031F3A3A</span>,<span style="color:#ae81ff">0x031F3A53</span>,<span style="color:#ae81ff">0x031F3A6C</span>,<span style="color:#ae81ff">0x031F3A85</span>,<span style="color:#ae81ff">0x031F3A9E</span>,<span style="color:#ae81ff">0x031F3AB7</span>,<span style="color:#ae81ff">0x031F3AD0</span>,<span style="color:#ae81ff">0x031F3AE9</span>,<span style="color:#ae81ff">0x031F3B02</span>,<span style="color:#ae81ff">0x031F3B1B</span>,<span style="color:#ae81ff">0x031F3B34</span>,<span style="color:#ae81ff">0x031F3B4D</span>,<span style="color:#ae81ff">0x031F3B66</span>,<span style="color:#ae81ff">0x031F3B7F</span>,<span style="color:#ae81ff">0x031F3B98</span>,<span style="color:#ae81ff">0x031F3BB1</span>,<span style="color:#ae81ff">0x031F3BCA</span>,<span style="color:#ae81ff">0x031F3BE3</span>,<span style="color:#ae81ff">0x031F3BFC</span>,<span style="color:#ae81ff">0x031F3C15</span>,<span style="color:#ae81ff">0x031F3C2E</span>,<span style="color:#ae81ff">0x031F3C47</span>,<span style="color:#ae81ff">0x031F3C60</span>,<span style="color:#ae81ff">0x031F3C79</span>,<span style="color:#ae81ff">0x031F3C92</span>,<span style="color:#ae81ff">0x031F3CAB</span>,<span style="color:#ae81ff">0x031F3CC4</span>,<span style="color:#ae81ff">0x031F3CDD</span>,<span style="color:#ae81ff">0x031F3CF6</span>,<span style="color:#ae81ff">0x031F3D0F</span>,<span style="color:#ae81ff">0x031F3D28</span>,<span style="color:#ae81ff">0x031F3D41</span>,<span style="color:#ae81ff">0x031F3D5A</span>,<span style="color:#ae81ff">0x031F3D73</span>,<span style="color:#ae81ff">0x031F3D8C</span>,<span style="color:#ae81ff">0x031F3DA5</span>,<span style="color:#ae81ff">0x031F3DBE</span>,<span style="color:#ae81ff">0x031F3DD7</span>,<span style="color:#ae81ff">0x031F3DF0</span>,<span style="color:#ae81ff">0x031F3E09</span>,<span style="color:#ae81ff">0x031F3E22</span>,<span style="color:#ae81ff">0x031F3E3B</span>,<span style="color:#ae81ff">0x031F3E54</span>,<span style="color:#ae81ff">0x031F3E6D</span>,<span style="color:#ae81ff">0x031F3E86</span>,<span style="color:#ae81ff">0x031F3E9F</span>,<span style="color:#ae81ff">0x031F3EB8</span>,<span style="color:#ae81ff">0x031F3ED1</span>,<span style="color:#ae81ff">0x031F3EEA</span>,<span style="color:#ae81ff">0x031F3F03</span>,<span style="color:#ae81ff">0x031F3F1C</span>,<span style="color:#ae81ff">0x031F3F35</span>,<span style="color:#ae81ff">0x031F3F4E</span>,<span style="color:#ae81ff">0x031F3F67</span>,<span style="color:#ae81ff">0x031F3F80</span>,<span style="color:#ae81ff">0x031F3F99</span>,<span style="color:#ae81ff">0x031F3FB2</span>,<span style="color:#ae81ff">0x031F3FCB</span>,<span style="color:#ae81ff">0x031F3FE4</span>,<span style="color:#ae81ff">0x031F3FFD</span>,<span style="color:#ae81ff">0x031F4016</span>,<span style="color:#ae81ff">0x031F402F</span>,<span style="color:#ae81ff">0x031F4048</span>,<span style="color:#ae81ff">0x031F4061</span>,<span style="color:#ae81ff">0x031F407A</span>,<span style="color:#ae81ff">0x031F4093</span>,<span style="color:#ae81ff">0x031F40AC</span>,<span style="color:#ae81ff">0x031F40C5</span>,<span style="color:#ae81ff">0x031F40DE</span>,<span style="color:#ae81ff">0x031F40F7</span>,<span style="color:#ae81ff">0x031F4110</span>,<span style="color:#ae81ff">0x031F4129</span>,<span style="color:#ae81ff">0x031F4142</span>,<span style="color:#ae81ff">0x031F415B</span>,<span style="color:#ae81ff">0x031F4174</span>,<span style="color:#ae81ff">0x031F418D</span>,<span style="color:#ae81ff">0x031F41A6</span>,<span style="color:#ae81ff">0x031F41BF</span>,<span style="color:#ae81ff">0x031F41D8</span>,<span style="color:#ae81ff">0x031F41F1</span>,<span style="color:#ae81ff">0x031F420A</span>,<span style="color:#ae81ff">0x031F4223</span>,<span style="color:#ae81ff">0x031F423C</span>,<span style="color:#ae81ff">0x031F4255</span>,<span style="color:#ae81ff">0x031F426E</span>,<span style="color:#ae81ff">0x031F4287</span>,<span style="color:#ae81ff">0x031F42A0</span>,<span style="color:#ae81ff">0x031F42B9</span>,<span style="color:#ae81ff">0x031F42D2</span>,<span style="color:#ae81ff">0x031F42EB</span>,<span style="color:#ae81ff">0x031F4304</span>,<span style="color:#ae81ff">0x031F431D</span>,<span style="color:#ae81ff">0x031F4336</span>,<span style="color:#ae81ff">0x031F434F</span>,<span style="color:#ae81ff">0x031F4368</span>,<span style="color:#ae81ff">0x031F4381</span>,<span style="color:#ae81ff">0x031F439A</span>,<span style="color:#ae81ff">0x031F43B3</span>,<span style="color:#ae81ff">0x031F43CC</span>,<span style="color:#ae81ff">0x031F43E5</span>,<span style="color:#ae81ff">0x031F43FE</span>,<span style="color:#ae81ff">0x031F4417</span>,<span style="color:#ae81ff">0x031F4430</span>,<span style="color:#ae81ff">0x031F4449</span>,<span style="color:#ae81ff">0x031F4462</span>,<span style="color:#ae81ff">0x031F447B</span>,<span style="color:#ae81ff">0x031F4494</span>,<span style="color:#ae81ff">0x031F44AD</span>,<span style="color:#ae81ff">0x031F44C6</span>,<span style="color:#ae81ff">0x031F44DF</span>,<span style="color:#ae81ff">0x031F44F8</span>,<span style="color:#ae81ff">0x031F4511</span>,<span style="color:#ae81ff">0x031F452A</span>,<span style="color:#ae81ff">0x031F4543</span>,<span style="color:#ae81ff">0x031F455C</span>,<span style="color:#ae81ff">0x031F4575</span>,<span style="color:#ae81ff">0x031F458E</span>,<span style="color:#ae81ff">0x031F45A7</span>,<span style="color:#ae81ff">0x031F45C0</span>,<span style="color:#ae81ff">0x031F45D9</span>,<span style="color:#ae81ff">0x031F45F2</span>,<span style="color:#ae81ff">0x031F460B</span>,<span style="color:#ae81ff">0x031F4624</span>,<span style="color:#ae81ff">0x031F463D</span>,<span style="color:#ae81ff">0x031F4656</span>,<span style="color:#ae81ff">0x031F466F</span>,<span style="color:#ae81ff">0x031F4688</span>,<span style="color:#ae81ff">0x031F46A1</span>,<span style="color:#ae81ff">0x031F46BA</span>,<span style="color:#ae81ff">0x031F46D3</span>,<span style="color:#ae81ff">0x031F46EC</span>,<span style="color:#ae81ff">0x031F4705</span>,<span style="color:#ae81ff">0x031F471E</span>,<span style="color:#ae81ff">0x031F4737</span>,<span style="color:#ae81ff">0x031F4750</span>,<span style="color:#ae81ff">0x031F4769</span>,<span style="color:#ae81ff">0x031F4782</span>,<span style="color:#ae81ff">0x031F479B</span>,<span style="color:#ae81ff">0x031F47B4</span>,<span style="color:#ae81ff">0x031F47CD</span>,<span style="color:#ae81ff">0x031F47E6</span>,<span style="color:#ae81ff">0x031F47FF</span>,<span style="color:#ae81ff">0x031F4818</span>,<span style="color:#ae81ff">0x031F4831</span>,<span style="color:#ae81ff">0x031F484A</span>,<span style="color:#ae81ff">0x031F4863</span>,<span style="color:#ae81ff">0x031F487C</span>,<span style="color:#ae81ff">0x031F4895</span>,<span style="color:#ae81ff">0x031F48AE</span>,<span style="color:#ae81ff">0x031F48C7</span>,<span style="color:#ae81ff">0x031F48E0</span>,<span style="color:#ae81ff">0x031F48F9</span>,<span style="color:#ae81ff">0x031F4912</span>,<span style="color:#ae81ff">0x031F492B</span>,<span style="color:#ae81ff">0x031F4944</span>,<span style="color:#ae81ff">0x031F495D</span>,<span style="color:#ae81ff">0x031F4976</span>,<span style="color:#ae81ff">0x031F498F</span>,<span style="color:#ae81ff">0x031F49A8</span>,<span style="color:#ae81ff">0x031F49C1</span>,<span style="color:#ae81ff">0x031F49DA</span>,<span style="color:#ae81ff">0x031F49F3</span>,<span style="color:#ae81ff">0x031F4A0C</span>,<span style="color:#ae81ff">0x031F4A25</span>,<span style="color:#ae81ff">0x031F4A3E</span>,<span style="color:#ae81ff">0x031F4A57</span>,<span style="color:#ae81ff">0x031F4A70</span>,<span style="color:#ae81ff">0x031F4A89</span>,<span style="color:#ae81ff">0x031F4AA2</span>,<span style="color:#ae81ff">0x031F4ABB</span>,<span style="color:#ae81ff">0x031F4AD4</span>,<span style="color:#ae81ff">0x031F4AED</span>,<span style="color:#ae81ff">0x031F4B06</span>,<span style="color:#ae81ff">0x031F4B1F</span>,<span style="color:#ae81ff">0x031F4B38</span>,<span style="color:#ae81ff">0x031F4B51</span>,<span style="color:#ae81ff">0x031F4B6A</span>,<span style="color:#ae81ff">0x031F4B83</span>,<span style="color:#ae81ff">0x031F4B9C</span>,<span style="color:#ae81ff">0x031F4BB5</span>,<span style="color:#ae81ff">0x031F4BCE</span>,<span style="color:#ae81ff">0x031F4BE7</span>,<span style="color:#ae81ff">0x031F4C00</span>,<span style="color:#ae81ff">0x031F4C19</span>,<span style="color:#ae81ff">0x031F4C32</span>,<span style="color:#ae81ff">0x031F4C4B</span>,<span style="color:#ae81ff">0x031F4C64</span>,<span style="color:#ae81ff">0x031F4C7D</span>,<span style="color:#ae81ff">0x031F4C96</span>,<span style="color:#ae81ff">0x031F4CAF</span>,<span style="color:#ae81ff">0x031F4CC8</span>,<span style="color:#ae81ff">0x031F4CE1</span>,<span style="color:#ae81ff">0x031F4CFA</span>]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> starting_points:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># push offset is 4byte. </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 3 push instuction before call</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 0xC bytes backward to take all function parameters</span>
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">=</span> s <span style="color:#f92672">-</span> <span style="color:#ae81ff">0xC</span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Address </span><span style="color:#e6db74">{</span>hex(s)<span style="color:#e6db74">}</span><span style="color:#e6db74"> : </span><span style="color:#e6db74">{</span>deobfuscate(s)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span></code></pre></div><p>Launching this script we are able to extract a lot of information on Mars Stealer, starting our triage without even reversing the whole malware. In fact, from the resolved string we have something related to common stealer targets such as: credit cards, browser, crypto wallet, etc..</p>
<p><img src="/img/mars_stealer/ms_deobfuscated_strings.png" alt="Figure 8: Retrieved strings"></p>
<p>Figure 8: Retrieved strings</p>
<p>Additionally we also have a chance to get a few insights about anti-analysis or reversing-aware functions such as: <strong>IsDebuggerPresent</strong> or <strong>CreateToolhelp32Snapshot</strong>. Additionally we have also some indications about anti-sandbox techniques with <strong>HAL9TH</strong>, that should be the Microsoft sandbox computer name. All deobfuscated strings could be found within the <strong>Reference section</strong>.</p>
<h3 id="conclusion-and-next-chapter">Conclusion and next chapter</h3>
<p>Emulation represents the state of the art for analyzing malware functions or triaging sample without losing yourself in complex and heavily obfuscated routine. It was pretty fun to analyze Mars Stealer through this technique. I‚Äôm thinking of creating additional and probably more structured content (maybe a Whitepaper) about malware emulation.</p>
<p>The script above could be used as a reference for further analysis, it&rsquo;s quite simple (and not perfect) but very effective and I used that as a ‚Äú<em>soft</em>‚Äù introduction to this topic and also to give an idea of emulation capabilities.</p>
<p>Hope you enjoyed reading this post as much as I had reversing this malware and writing this article!</p>
<h3 id="references">References</h3>
<p>Sample analyzed:</p>
<ul>
<li><a href="https://bazaar.abuse.ch/sample/81dbad520f8f4d8163e02d7b01866918e8392bb549df2cb73f1b8148f6fd5b51/">MalwareBazaar Sample</a></li>
</ul>
<p>Minidump:</p>
<ul>
<li><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/MarsStealer/mars_stealer_minidump.7z">mars_stealer_minidump.7z</a></li>
</ul>
<p>String resolver:</p>
<ul>
<li><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/MarsStealer/MarsStealer_stringResolver.py">MarsStealer_stringResolver.py</a></li>
</ul>
<p>Extracted strings:</p>
<ul>
<li><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/MarsStealer/strings.txt">strings.txt</a></li>
</ul>
<p>Dumpulator:</p>
<ul>
<li><a href="https://github.com/mrexodia/dumpulator">Reference</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Vidar - payload inspection with static analysis</title>
            <link>https://Viuleeenz.github.io/posts/2023/10/vidar-payload-inspection-with-static-analysis/</link>
            <pubDate>Wed, 25 Oct 2023 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2023/10/vidar-payload-inspection-with-static-analysis/</guid>
            <description>Behind this post Through this blogpost I‚Äôm going to talk about one of the latest Vidar samples that I had a chance to analyze. The payload is actually part of a campaign delivered in July 2023 using PEC mails and this analysis comes from a post related to Cert-Agid in the same period. Even if the payload seems to be out of time, it&amp;rsquo;s still a valid example for further analysis of more recents ones.</description>
            <content type="html"><![CDATA[<h2 id="behind-this-post">Behind this post</h2>
<p>Through this blogpost I‚Äôm going to talk about one of the latest Vidar samples that I had a chance to analyze. The payload is actually part of a campaign delivered in July 2023 using PEC mails and this analysis comes from a post related to <a href="https://cert-agid.gov.it/tag/vidar/">Cert-Agid</a> in the same period. Even if the payload seems to be out of time, it&rsquo;s still a valid example for further analysis of more recents ones.</p>
<p>The purpose of this article is to give an overview of Vidar, helping people that are tracking this threat to properly deal with it. Moreover, it is also an excuse <strong>to tweak a little bit with IDA to show a possible solution related to common issues when we are dealing with highly obfuscated malware</strong>.</p>
<h2 id="static-analysis">Static Analysis</h2>
<p>Opening up the Vidar sample with IDA, it‚Äôs immediately clear that it contains few obfuscated strings and garbage code that prevents analysts from directly examining the sample. More precisely, it has been possible to discover three functions, analyzed in this blogpost, that are in charge of:</p>
<ul>
<li><strong>Detecting VMs execution</strong>;</li>
<li><strong>Detecting ‚Äúdefault settings</strong>‚Äù;</li>
<li><strong>Decrypting Strings</strong>.</li>
</ul>
<p><img src="https://lh7-us.googleusercontent.com/RUhAbxUgIAJQKmsvcjyWa6zNEr4ryy9wKguHx0GUVynFje3aEE0pyIF0zkVwVvYnbFOtAeDSuSFFsEImJEkC3leG8DbpwX-QXK5liy-uZfsg1OLFLs2yU8WIOmOSCihExjDcObga9dfCaiJb5sMJ2t0" alt="Figure 1 - Vidar main function with garbage code"></p>
<p>Figure 1 - Vidar main function with garbage code</p>
<h3 id="anti-analysis-implementation">Anti-Analysis implementation</h3>
<p>In this sample, there are three main functions that are in charge of performing anti-analysis checks.</p>
<p>The first one is implemented through the function <strong>VirtualAllocExNuma</strong> that checks if the sample is running on a system with one or more physical CPU:</p>
<p><img src="https://lh7-us.googleusercontent.com/-HDWHV34_5kdT04VICJmciGOaRD7ZDMrmP-DmNfc_oftxhumwvommeGnMfWFupVgEo7osoENveFybbs9YHKkQVzyHtXJtkxrnK2jjfceQ6hNTzdi6Bf2peaSK1YlGUFcr2Ma5_fn2KXXGwuAmVSEvCI" alt="Figure 2 - Call to VirtualAllocExNuma for physical CPU controls."></p>
<p>Figure 2 - Call to VirtualAllocExNuma for physical CPU controls.</p>
<p>Another techniques that prevent payload execution is related to <strong>the number of processors available on the machine</strong> that are required to be at least 2:</p>
<p><img src="https://lh7-us.googleusercontent.com/o9yejv6GNkWp4yTsJWF_PSOyxKHco5lfkCMLLGbIkkyVhKHHkWiJtv4JCppNsQZs0BBSBvuvFsInQg-4nrqrBH6_dzl65lzyV1cSeSWGzy2I0nRmkr6EK9CYRq3L_-g2V9RQQaOztA8bXIBfJN-WMZk" alt="Figure 3 - Call to GetSystemInfo for Processors‚Äôs checks"></p>
<p>Figure 3 - Call to GetSystemInfo for Processors‚Äôs checks</p>
<p>The last checks that have been identified are related to the Username and Computer Name that is currently used. In particular there are two matches that verify if the username corresponds to <strong>John Doe</strong> and then the <strong>ComputerName</strong> is equal to <strong>HAL9TH</strong>.</p>
<blockquote>
<p>It turns out that Microsoft Defender&rsquo;s Sandbox computername is HAL9TH, so, you can check for the computer name in your malware before detonation, if the name matches HAL9TH, it means you&rsquo;re inside defender&rsquo;s sandbox, so you can make your program exit.</p>
</blockquote>
<p><img src="https://lh7-us.googleusercontent.com/Jlr2e4g6gpjrrFi1uxvrWJZ2usZnGZR_smo3v1PEviMjw8kspy4PL0pm0kMozeRVi3I988gpt0tEvGmHN58pfFXHaw0m_i22FgHhcMnNixAfh-onZBxHmES16D6ZltkhiyEaWdLd7WFuFmLVQwRDZqQ" alt="Figure 4 - Checking for ‚Äúspecific settings‚Äù"></p>
<p>Figure 4 - Checking for ‚Äúspecific settings‚Äù</p>
<p>If one of those checks fails, the payload will call the function <strong>ExitProcess(0)</strong> terminating its execution.</p>
<h3 id="decryption-routine">Decryption routine</h3>
<p>As already mentioned, Vidar payload contains few encrypted strings to slow down the analysis and probably to evade few monitoring solutions. Because of that, there is a function that is in charge to retrieve the plaintext associated with each encrypted string.</p>
<p><img src="https://lh7-us.googleusercontent.com/O34JU_qxsazBuGRm4zbwGM8YimF1fGb1ppOvjoy_Freuwe95fHNFwWn-iaF28q__xg92YpjDPylvOZIeP0CvICtdoG7iYI5hyd5786JE4PXDgc8AwYOzLCpZq7lcY5w2MgXeMfuPSzdDTjrBLACNM00" alt="Figure 5 - Encrypted Strings"></p>
<p>Figure 5 - Encrypted Strings</p>
<p>The function it&rsquo;s fairly easy to spot especially observing the number of times it will be called and its signature (that recall a quite simple decryption procedure):</p>
<ul>
<li><strong>decryption_routine</strong>(encrypted_string , key , length)</li>
</ul>
<p>As expected the decryption routine it&rsquo;s not so hard to understand, in fact it iterates over the key length and performs an <strong>XOR</strong> operation between the <strong>encrypted_string</strong> and <strong>key</strong> parameters.</p>
<p><img src="https://lh7-us.googleusercontent.com/nEm9g0DmlIQNnO4HVGmAokxfV_MiWn1pgAX-XD3ut6Gy2nSIGY_IdTWmAVwb7iZVIMonhgdwGwqb1pxank2vEqReC50L5LnYPOfwlW7UrOzM5LiQ-3b67KZfgGEWcKuGNUYFgjErruihN5D0S0p6-VY" alt="Figure 6 - Decryption routine"></p>
<p>Figure 6 - Decryption routine</p>
<p><img src="https://lh7-us.googleusercontent.com/ztZ7Z6oxeCfGDB_ki1WvSAF-jChkBAyv00n-W0W3cfdjUzbuIeNMA4Y3TfatAuXwrZa07em1ps2j_47P3n5cdfaMiTGvG5hOSMx2sVe-R_IrkXl62zeTxT7FL4NLtAT7mlWq37cxgKKadxjxow1_nRE" alt="Figure 7 - String decrypted"></p>
<p>Figure 7 - String decrypted</p>
<p>It‚Äôs worth noting that IDA has few limitations, in fact sometimes it does not perform the proper variable renaming and due to the obfuscation implemented few instructions could be misinterpreted. Because of that an effective method to <strong>keep track of decrypted variables is to locate their offset and append a comment</strong>.</p>
<p>In that case, we should have a nice reference that could be used later on, to rename the variable accordingly. Keeping that in mind, it&rsquo;s possible to speed up our analysis by writing an <a href="https://viuleeenz.github.io/posts/2023/06/ida-python-locate-a-function-independently-from-its-offset/">IDA-python</a> script that takes care of those strings.</p>
<h3 id="fixing-functions">Fixing Functions</h3>
<p>As mentioned above, IDA sometimes could be confused by obfuscation that could lead to mis-interpret instructions or inhibit its ability to recognize a function. In fact, <strong>at the end of main</strong> there is a jump to a location that is not currently interpreted as a function. However, looking at strings and references to that text section there is clearly an error from the IDA interpreter.</p>
<p><img src="https://lh7-us.googleusercontent.com/_i129YO91RRHlKrIIzaqJSO77K63-3EjGKLWqMSwkXw96T_mWeO5lvgEC8RkFi8mpGQvtgaVhwgNbr3z__vbm3cZws9y4jgwq-qXoHt72h5gvEyxMRlszrabva2jI8e4nYMCn-n8vFvvrMfdRLXrqNw" alt="Figure 8 - Mis-intepreted function"></p>
<p>Figure 8 - Mis-intepreted function</p>
<p>To fix that, it‚Äôs possible to select the block of code and force IDA to treat that as a function. However, this practice it‚Äôs not always painless. In fact, it&rsquo;s still possible that we could get some issues from IDA that are not capable of interpreting all code correctly. An example is given from the figure below, where we have strings related to <strong>JUMPOUT</strong> and <strong>MEMORY</strong>.</p>
<p><img src="https://lh7-us.googleusercontent.com/9E5IDw_OiMauChtO3a8kmYcvag0cD-w8srPJduXSg_8niBztLjuwgX10a7wKUUCOgAmBSCaDdO4l8xqxGVsmjrifWZL-CeeHJiGoHb7zlZo8rREHqIihxtikMgHtUAV3VTz77mQ7VixYwiO5xJ-_UI0" alt="Figure 9 - Function interpreted as data"></p>
<p>Figure 9 - Function interpreted as data</p>
<p>This issue could be solved easily by fixing the byte related to the <strong>JUMPOUT</strong> instruction, however, in order to avoid losing focus on our main tasks, this issue will probably be discussed in a dedicated thread.</p>
<p>Nevertheless, we have now all pieces to complete our static analysis and go deep in all malicious activities related to this malware.</p>
<h2 id="additional-analysis">Additional Analysis</h2>
<p>String decryption was an effective method to extract IOCs from this Vidar sample. Examinig those strings we could see that, as expected, it works as an InfoStealer querying browser information (credentials on local storage) and multiple installed programs. At the time of writing, it supports most of the main used browsers, such as: Chrome, Firefox, Opera, Tor, etc.</p>
<p>Another interesting feature is related to the <strong>chrome extension</strong> checks feature, that aims to verify if specific extensions are actually installed. Mainly monitored extensions are related to <strong>crypto wallets</strong> and <strong>password managers</strong>.</p>
<p><img src="https://lh7-us.googleusercontent.com/aV7S2p8iQiUzjzkHNTFC0HLUbA1mJ7_gLJNYHEh_pmrpA39UtlOQEHpxUzdPLeMqPz6KX-tWZSGb7csNwhzTsXXiInuIO_cC29ZtN-Q3cmhRQ2qqKVwGUXJUHI6LUxc8eFGAdrBxl0lBTbfO8Yummd8" alt="Figure 10 - Monitored chrome extensions"></p>
<p>Figure 10 - Monitored chrome extensions</p>
<h2 id="network-communication">Network Communication</h2>
<p>According to the examined functions related to the network communication, it is possible to recreate the POST request structure that could be monitored and used as an indicator of compromise of this actor:</p>
<ul>
<li><strong>Content Disposition: form-data; name=&lt;Vidar_parameter&gt;</strong></li>
</ul>
<p>It‚Äôs worth mentioning that parameters observed are:</p>
<ul>
<li><strong>ID</strong> for BOT identification;</li>
<li><strong>HWID</strong> that uniquely identifies a machine (used for monitoring multiple infection from the same machine, indicating an analyzing attempts from researcher);</li>
<li><strong>Token:</strong> Exfiltrated token available on the victim‚Äô machine;</li>
<li><strong>File:</strong> An archive of all information gathered from the victim‚Äôs machine.</li>
</ul>
<p><img src="https://lh7-us.googleusercontent.com/yIAa0snonhSg0z1Th0EeZMkPMap6PnuZ3tueBAOL5KLjHWFMLc3150BY7KGaaCftMjiSg1IgEMYQmdCO8RwbTCV6d7gcNsMvph6KaWLLP54RtLpvsCTeORzZeY6QwCfpnrthNtTEkfiYf6gOGt_qBso" alt="Figure 11 - POST request structure"></p>
<p>Figure 11 - POST request structure</p>
<h2 id="references">References</h2>
<p>Sample:</p>
<ul>
<li>556f8b06b92ddbc4008dea5298eab3934c61647a1cd7333a9087c37cc5a75456 (SHA256)<a href="https://bazaar.abuse.ch/sample/556f8b06b92ddbc4008dea5298eab3934c61647a1cd7333a9087c37cc5a75456/">MalwareBazaar</a></li>
</ul>
<p>Ida-python scrypt:</p>
<ul>
<li><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/Vidar/ida_vidar_string_decrypt.py">ida_vidar_string_decrypt.py</a>
Microsoft Defender&rsquo;s Sandbox:</li>
<li>BlackHat 2018 <a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Bulazel-Windows-Offender-Reverse-Engineering-Windows-Defenders-Antivirus-Emulator.pdf">detailed analysis </a></li>
</ul>
<h2 id="iocs">IOCs</h2>
<ul>
<li>
<p>Network indicators</p>
<ul>
<li>https://t.]me/game4serv</li>
<li>https://steamcommunity.]com/profiles/76561199523054520</li>
<li>http://bigsnowstone.]com/</li>
</ul>
</li>
<li>
<p>Targets</p>
<table>
<thead>
<tr>
<th>Browsers</th>
<th>Browser Extensions - Wallets</th>
<th>Authenticator/Password Manager</th>
<th>Desktop Programs</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mozilla Firefox</td>
<td>TronLink</td>
<td>Authenticator</td>
<td>LevelDB</td>
</tr>
<tr>
<td>Pale Moon</td>
<td>Meta</td>
<td>Authy</td>
<td>Thunderbird</td>
</tr>
<tr>
<td>Google Chrome</td>
<td>BinanceChainWallet</td>
<td>EOS Authenticator</td>
<td>Telegram</td>
</tr>
<tr>
<td>Chromium</td>
<td>Yoroi</td>
<td>GAuth Authenticator</td>
<td>WinSCP</td>
</tr>
<tr>
<td>Amigo</td>
<td>NiftyWallet</td>
<td></td>
<td>IndexedDB</td>
</tr>
<tr>
<td>Torch</td>
<td>MathWallet</td>
<td></td>
<td>Steam</td>
</tr>
<tr>
<td>Comodo Dragon</td>
<td>Coinbase</td>
<td></td>
<td>Jaxx_Desktop</td>
</tr>
<tr>
<td>Epic Privacy Browser</td>
<td>Guarda</td>
<td></td>
<td>Binance Desktop</td>
</tr>
<tr>
<td>Vivaldi</td>
<td>EQUALWallet</td>
<td></td>
<td>Bitcoin Core</td>
</tr>
<tr>
<td>CocCoc</td>
<td>JaxxLiberty</td>
<td></td>
<td>Bitcoin Core Old</td>
</tr>
<tr>
<td>Cent Browser</td>
<td>BitAppWallet</td>
<td></td>
<td>Raven Core</td>
</tr>
<tr>
<td>TorBro Browser</td>
<td>iWallet</td>
<td></td>
<td>Ledger Live</td>
</tr>
<tr>
<td>Chedot Browser</td>
<td>Wombat</td>
<td></td>
<td>Blockstream</td>
</tr>
<tr>
<td>Brave_Old</td>
<td>MewCx</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7Star</td>
<td>GuildWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Microsoft Edge</td>
<td>RoninWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td>360 Browser</td>
<td>NeoLine</td>
<td></td>
<td></td>
</tr>
<tr>
<td>QQBrowser</td>
<td>CloverWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Opera</td>
<td>LiqualityWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td>OperaGX</td>
<td>Terra_Station</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CryptoTab Browser</td>
<td>Keplr</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Brave</td>
<td>Sollet</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>AuroWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>PolymeshWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>ICONex</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Harmony</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>EVER Wallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>KardiaChain</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Trezor Password Manager</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Rabby</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Phantom</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>BraveWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>PaliWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>BoltX</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Xdefi</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Nami</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>MaiarDeFiWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>WavesKeeper</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Solflare</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>CyanoWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>KHC</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>TezBox</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Temple</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Goby</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>RoninWalletEdge</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Wasabi Wallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Daedalus Mainnet</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Agent Tesla - Building an effective decryptor</title>
            <link>https://Viuleeenz.github.io/posts/2023/08/agent-tesla-building-an-effective-decryptor/</link>
            <pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2023/08/agent-tesla-building-an-effective-decryptor/</guid>
            <description>General Information and preface Agent Tesla, according to the data provided by CERT-EU, is one the most prominent threats that are hitting European cyberspace. Because of that, I found that it could be quite interesting understanding its behavior. However, as I usually prefer, instead of focusing on the infection chain or information about TA methodologies, sharing knowledge that were already provided by more authoritative sources, I preferred to focus mostly on malware analysis and in this specific case to the latest encryption algorithm adopted.</description>
            <content type="html"><![CDATA[<h3 id="general-information-and-preface">General Information and preface</h3>
<p>Agent Tesla, according to the <a href="https://cert.europa.eu/static/threat-intelligence/TLP-CLEAR-CB-23-08.pdf">data</a> provided by CERT-EU, is one the most prominent threats that are hitting European cyberspace. Because of that, I found that it could be quite interesting understanding its behavior. However, as I usually prefer, instead of focusing on the infection chain or information about TA methodologies, sharing knowledge that were already provided by more authoritative sources, I preferred to focus mostly on malware analysis and in this specific case to the latest encryption algorithm adopted. Then, upon the knowledge acquired, I would like to write a decryptor script that extracts payload configuration.</p>
<h3 id="encryption-variants">Encryption variants</h3>
<p>Agent Tesla first appeared in 2014, however, its evolution over time could be tracked by multiple TTPs. For the purpose of this article, I‚Äôm versioning it through the encryption algorithm adopted. At the time of writing there have been 4 different versions with unique characteristics:</p>
<p><strong>Encryption v1</strong>: Through this encryption implementation, strings are stored (encrypted) in base64. The decryption function uses a password and a salt ( both hardcoded) as input for the SHA1 algorithm, in order to generate the decryption key. Then, ciphertext and key are eventually used with AES in CBC mode.</p>
<p><strong>Encryption v2</strong>: The main difference from the previous method, is that each encrypted string is paired with a dedicated key and an IV. The algorithm used is still AES in CBC mode.</p>
<p><strong>Encryption v3</strong>: In this version, TA completely changed their approach, shifting to a pure <em>xor decryption</em>. The decryption function is defined within the <em>.cctor()</em> constructor. The structure of encrypted strings is quite simple. Each string is contained in a byte array paired with a key. The size of the ciphertext allows the decryption routine to iterate over the byte array distinguishing all parameters.</p>
<p><strong>Encryption v4</strong>: The latest version of Agent Tesla is based on a <em>xor string</em> algorithm that stores information within a macro-structure that contains raw data organized as follow:</p>
<p><img src="https://lh4.googleusercontent.com/rgMJHsQLR6JB0OjAGzCeIZGYJAEiuThnX5uPyZPB9ukmC7vPMclavaVnoQgB9G3tRnv8IOZ2Lvjbcav4pjEUS1uxqeF8fktYlITE4YsNZ9yLtgZJsmsQjCzjKvLfKA0oKT6hzNNZNWE3COKWp0Smm9k" alt="Figure 1: Encrypted data structure"></p>
<p>Figure 1 - Encrypted data structure</p>
<p>In this version we have a macro-struct that contains the encrypted data. It‚Äôs actually possible to visualize it as an array where each element follows a specific structure where the first 4 bytes are dedicated to define the encryption data length, then other 4 bytes are used to describe the encryption key and the remaining bytes are reserved for the actual data.</p>
<p>As always, the decryption routine iterates over the encrypted data, using key bytes.</p>
<h3 id="analysis-of-encryption-v4-and-obfuscation-routine">Analysis of encryption v4 and obfuscation routine</h3>
<p>As I wrote in the first paragraph Agent Tesla analysis will be carried out on the latest encryption mechanism. Because of that, let‚Äôs start analyzing the main components of this algorithm:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">byte</span>[] RXOR(<span style="color:#66d9ef">byte</span>[] data, <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">int</span> key)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>key = RandomNumberGenerator.GetInt32(<span style="color:#66d9ef">int</span>.MaxValue);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// RXOR Cipher: reverse array order and decrypt byte by byte using single XOR</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n = data.Length - <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; n; i++, n--)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>data[i] ^= data[n];
</span></span><span style="display:flex;"><span>data[n] ^= (<span style="color:#66d9ef">byte</span>) (data[i] ^ key);
</span></span><span style="display:flex;"><span>data[i] ^= data[n];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (data.Length % <span style="color:#ae81ff">2</span> != <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>data[data.Length &gt;&gt; <span style="color:#ae81ff">1</span>] ^= (<span style="color:#66d9ef">byte</span>) key; <span style="color:#75715e">// x &gt;&gt; 1 == x / 2</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> data;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The key is generated randomly through <strong>RandomNumberGenerator.GetInt32(int.MaxValue)</strong> function. The <em>int.MaxValue</em> constraint is related to the key size limitation of 4 bytes within the encrypted data structure. The algorithm it&rsquo;s pretty straightforward, performing <em>xor</em> between plaintext and key bytes. However, what really matters here is the <strong>obfuscator</strong> that happens at runtime.</p>
<p>The <strong>obfuscation routine</strong> is part of an open source <a href="https://github.com/dr4k0nia/XorStringsNET">project</a>. Basically, this obfuscation works creating multiple placeholders that are going to be replaced at runtime. Analyzing the sample statically, this technique messes up with code decompilers such as DnSpy. However, the author wrote a detailed <a href="https://dr4k0nia.github.io/posts/Encrypting-Strings-In-NET/">blogpost</a> explaining obfuscator features and its modus operandi:</p>
<blockquote>
<p>&ldquo;After processing all methods we need to do some patches in the injected runtime. First, we need to set up the placeholder struct with the correct attribute values. The struct needs a <strong>ClassLayout</strong> with <strong>packing size 1</strong> and the <strong>length of the encrypted data as its size</strong>.&rdquo;</p>
</blockquote>
<blockquote>
<p>&ldquo;We also need to create a new <strong>field which will be an initialized version of our struct</strong>. By adding a DataSegment in its <strong>FieldRva</strong>, we can use the field to store any raw data we want, in this case, our encrypted string data.&rdquo;</p>
</blockquote>
<p>Following the indication provided by the author, we should have a more clear idea of what these components are and how to hunt for them in the code. Now it‚Äôs possible to start looking at the code gathering as much information as possible (e.g., locating these placeholders) and finding out a pattern to write an effective configuration decryptor.</p>
<h3 id="binary-inspection">Binary inspection</h3>
<p>If we open up DnSpy, we could be overwhelmed by the mess that is going to be presented in front of us. However, trying to follow the code flow, we could start exploring.</p>
<p><img src="https://lh5.googleusercontent.com/zuONKbBX5bsAJ-9VLBUlNoqYkhrk3PdCdn3WHkNawFSZG6MvRT636ILfvDcipjFTT0GlhrCzBdbnxiDNMWsQpDpViMBIgFZFJZ1fhqZZJZdi_bi3lRoGkMNJ2pv16lful5B_TWsxw7m6nMatFOupgRw" alt="Figure 2: Entry point"></p>
<p>Figure 2 - Entry point</p>
<p>Starting from the Entry Point, it‚Äôs possible to locate something promising. Exploring variable and function calls and following references to the object <strong>GWZl2RFJ6nA</strong>, it&rsquo;s possible to bump into quite interesting piece of code.</p>
<p><img src="https://lh4.googleusercontent.com/U3w0tnCvmRyhyBt97-Pk36cwOrTPTGa6KoRQIWPwArHkdyJ8nwQZWrchT7r4dQiU7BbazIGGDoDYDl1wPIknrnyjdzR1ZZo4jC-mLGlcbqllKjfDRnBR8UdJOAU7UlPiHWo4Uzd48Hj-AY0tSpXuG48" alt="Figure 3: Obfuscated decryption routine"></p>
<p>Figure 3 - Obfuscated decryption routine</p>
<p>First of all, we see the function <strong>cpblk</strong> that it‚Äôs necessary to perform the injection at runtime, moreover, scrolling the code it&rsquo;s possible to get insight about pointer operations paired with xor. In fact, observing the line 104 in Figure 3, it is very similar to the encryption routine that we saw in the previous paragraph.¬† Nevertheless, on the top of that, as a final proof that we are looking in the right place, scrolling at the end of the code we see a class that fulfills all requirements requested by the obfuscator.</p>
<ul>
<li><strong>ClassLayout</strong></li>
<li><strong>Pack size = 1</strong></li>
<li><strong>Size = encrypted data length</strong></li>
</ul>
<p><img src="https://lh4.googleusercontent.com/SscVl6FW0XbBVt3px_oGIjxBChRw68fi7Zrez6Mumu_WF7sdJBsNRMVqrIqaXeIo-mPaMQf0V8VnILZKPbprhbATjKxIjhWxLwULyM9FngDrwEdjA2C09QVdog2oUeMjqfngeFViG5m6TJrDQqb37wA" alt="Figure 4 - Class placeholder for runtime decryption"></p>
<p>Figure 4 - Class placeholder for runtime decryption</p>
<p>Moreover, following the instruction provided by the author, we should be able to locate the encrypted string in raw bytes within the binary. If we have a closer look to struct <strong>zqRrwrwgu</strong> examining the raw value, we are redirected to a very suspicious sequence of bytes.</p>
<p><img src="https://lh3.googleusercontent.com/SGwLKd7RiZ-or8mXHPy7frC_MDAQgyn3RcHZ9sK_vs3jU_yReO3wmC_4le_AFu-l8jxsvGEF2Li5sgbNIa5ObmTDEjkJysNMQUrbwfhkGkESbwRg_gApWFALZmnSVnIyFpe412KCqGRwGy2ryp3H63o" alt="figure 5 - Encrypted String"></p>
<p>Figure 5 - Encrypted string</p>
<p>Analyzing those bytes, it&rsquo;s immediate to find out that we are dealing with an encrypted payload that is ready to be decrypted.</p>
<h3 id="decrypting-strings">Decrypting Strings</h3>
<p><strong>The idea behind this script is simple</strong>:</p>
<ul>
<li>Find out a class that is big enough to contain the encrypted data ( usually the biggest class in the code). Then we could retrieve raw bytes related to its size from the binary file and forward them towards our decryption routine</li>
</ul>
<p>Before proceeding, it&rsquo;s worth mentioning that I‚Äôm quite a newbie in .NET interaction with python and generally, I‚Äôm still learning .NET layout. Because of that, if someone else is going to produce more efficient code. Please do it! But for now, let‚Äôs do a quick look to this this script:</p>
<p><img src="https://lh6.googleusercontent.com/YgvfXQ1w_ggTUJ8u7Gd0oP5hPymmMYsmLFFVX0FmNoNx9oYpJ6ALMGdINsjWlQ3b25nzLXobQmcMt0-TmyWwVClZ28nHmJbO4Jmw92ck25uN-2A5XwGmtwx1EoTFYSugv8RD9JN9hn8liM6dALueaTY" alt="Figure 6 - Agent Tesla decryptor"></p>
<p>Figure 6 - Agent Tesla decryptor</p>
<ul>
<li><strong>Line 40 - 44:</strong> Gathered references to ClassLayout and FieldRVA Tables.</li>
<li><strong>Line 46 - 47:</strong> Following the initial idea that encrypted data should be stored in a quite large class, I started to enumerate class, selecting the biggest (likely the one that contains the encrypted strings)</li>
<li><strong>Line 51:</strong> retrieve the last element of the FieldRVA table that contains our data (I don‚Äôt know if it is an unexpected behavior caused by the obfuscation process applied, but the raw data containing the encryption string resulted to be always the last element of the FieldRVA table).</li>
</ul>
<p>Running our script on one of the latest Agent Tesla sample, we got the following result:</p>
<p><img src="https://lh3.googleusercontent.com/MtQZbbAOaz2HR4EEGvuVnAH2VoTzbz3P31VeZe0WPg_qMGpPuDOOQH7vn5jxriHiljyrfpK_3T_lejGWJ3Scwq1vNJDICyjvmkhZzI8g423d7e20_R8XSulLtXB9Db_-Si7wu5H6dPT95HPotd-BY7o" alt="Figure 7 - Decryptor result"></p>
<p>Figure 7 - Decryptor result</p>
<h3 id="references">References</h3>
<p>Agent Tesla Decryptor:</p>
<ul>
<li><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/AgentTesla/agent_tesla_decryptor_v4.py">agent_tesla_decryptor_v4.py</a></li>
</ul>
<p>DotNet references:</p>
<ul>
<li>General .NET implementation <a href="https://www.ntcore.com/files/dotnetformat.htm">info</a></li>
<li>Python <a href="https://github.com/pan-unit42/dotnetfile">parser</a> for .NET</li>
</ul>
<p>Samples:</p>
<ul>
<li>ae26382f191225447550e9a691453fc3ea2e02127222787c662efc8db63c59e3 (SHA256) <a href="https://bazaar.abuse.ch/sample/ae26382f191225447550e9a691453fc3ea2e02127222787c662efc8db63c59e3/">MalwareBazaar</a></li>
<li>acedd97c8350bacc485e87ae56c851d08b497c202deb46df28c3e7218cb4469a (SHA256) <a href="https://bazaar.abuse.ch/sample/acedd97c8350bacc485e87ae56c851d08b497c202deb46df28c3e7218cb4469a/">MalwareBazaar</a></li>
<li>f5751d89bc6f15c3ade6513d3cf44f92a25e8cd25d2f5ad239b8c44f8f732cb8 (SHA256)<a href="https://bazaar.abuse.ch/sample/f5751d89bc6f15c3ade6513d3cf44f92a25e8cd25d2f5ad239b8c44f8f732cb8">MalwareBazaar</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>IDA-Python - Locate a function independently from its offset</title>
            <link>https://Viuleeenz.github.io/posts/2023/06/ida-python-locate-a-function-independently-from-its-offset/</link>
            <pubDate>Tue, 27 Jun 2023 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2023/06/ida-python-locate-a-function-independently-from-its-offset/</guid>
            <description>Introduction Analyzing samples statically could be not an easy going taks, especially when you deal with heavily obfuscated or encrypted data. Because of that, it‚Äôs useful to find out the decryption/deobfuscation routine and write a little script that makes sense of strings or function names before starting to analyze the whole sample.
The idea behind this technique was inspired by the infinite amount of tweaking I have made to run multiple Ida-python scripts that were heavily machine-setting dependents.</description>
            <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Analyzing samples statically could be not an easy going taks, especially when you deal with heavily obfuscated or encrypted data. Because of that, it‚Äôs useful to find out the decryption/deobfuscation routine and write a little script that makes sense of strings or function names before starting to analyze the whole sample.</p>
<p>The idea behind this technique was inspired by the infinite amount of tweaking I have made to run multiple Ida-python scripts that were heavily machine-setting dependents. The idea is very simple and it‚Äôs based on pattern matching as for YARA rules. The scope here is to create a kind of signature for a function that we would like to locate (e.g., deobfuscation routine) and apply its execution to its parameters in order to simplify our analysis <strong>without tweaking specific parameters</strong> making it <strong>independent from the function offset</strong>. I have already got good results experimenting with malware samples (e.g, Qbot) and custom binaries from CTFs as well as other samples that used some sort of obfuscation. Because of that, I decided to create this post to share this approach that could be useful for writing better scripts.</p>
<p>Generally speaking, approaching to these sample could be done through multiple perspective (e.g., starting with dynamic analysis and proceeding backwards), however, for the purpose of this blogpost I‚Äôm going to take a custom sample written by me, where strings are partially obfuscated with custom algorithm and I‚Äôm going to show an easy but effective method to write an ida-python script to <strong>locate and deobfuscate variables</strong>.</p>
<h2 id="practical-example">Practical example</h2>
<p>First go first. In order to deobfuscate a piece of code, it&rsquo;s still required to analyze the function that is going to perform this task and replicate its behavior implementing it within our script. For the purpose of this post, this step is out of scope, however, I‚Äôm going to directly analyze the assembly code in order to find out how to write the IDA-python script to collect all obfuscated variables to apply the proper routine.</p>
<p>The steps that we are going are pretty much the following:</p>
<ul>
<li>Find out the deobfuscation function;</li>
<li>Create a ‚Äúsignature‚Äù to retrieve all its references;</li>
<li>Collect the obfuscated parameters;</li>
<li>Apply the deobfuscation routine;</li>
</ul>
<h2 id="creating-function-signature">Creating function signature</h2>
<p>Since that sample it&rsquo;s actually very easy, finding the proper function it‚Äôs not so tricky. In fact, we could see that there is a DWORD that is going to be passed to a function called ‚Äú<strong>DeobfuscateString</strong>‚Äù. However, what really matters here, is to create a signature of this function in order to locate it in multiple samples, independently from the offset that is going to be loaded.</p>
<p><img src="/img/ida_python/function_overview.png" alt="Figure 1 - Main function overview">
Figure 1 - Main function overview</p>
<p>To do so, it&rsquo;s possible to open the <strong>text</strong> view and explore the function to collect a few bytes that could be useful for this signature-like phase. I have chosen to get something related to the <strong>strcspn</strong> function that is part of the deobfuscation routine. More precisely, I have chosen to gather 16 bytes (<strong>8D 55 E0 52 8D 45 E4 50 FF 15 CC 20 40 00</strong>).</p>
<p><img src="/img/ida_python/deob_function.png" alt="Figure 2 - Deobfuscation routine">
Figure 2 - Deobfuscation routine</p>
<p>Now we could try to find out if our collected bytes are enough to identify this function. Let‚Äôs write a little script that checks this out.</p>
<h2 id="searching-for-the-function-characteristics">Searching for the function characteristics</h2>
<p>The first thing to do is to gather the <strong>.text</strong> segment and then, start to look for our signature. One of the easiest ways to get the segment requested is to iterate over all segments until the <strong>idc.get_segm_name</strong> contains the ‚Äú<strong>.text‚Äù</strong> name:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_text_segment</span>(seg_name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;.text&#34;</span>):
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> idautils<span style="color:#f92672">.</span>Segments():
</span></span><span style="display:flex;"><span>  start <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>get_segm_start(s)
</span></span><span style="display:flex;"><span>  end <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>get_segm_end(s)
</span></span><span style="display:flex;"><span>  name <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>get_segm_name(s)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> name <span style="color:#f92672">==</span> seg_name:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> start, end
</span></span></code></pre></div><p>Then, we should write a function that is capable to locate our signature:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">patternSearch</span>(address_start, address_end):
</span></span><span style="display:flex;"><span>    pattern <span style="color:#f92672">=</span> idaapi<span style="color:#f92672">.</span>compiled_binpat_vec_t()
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> idaapi<span style="color:#f92672">.</span>parse_binpat_str(
</span></span><span style="display:flex;"><span>        pattern,
</span></span><span style="display:flex;"><span>        address_start,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;8D 55 E0 52 8D 45 E4 50 FF 15 CC 20 40 00&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">16</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> res <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;[!] Pattern not Found&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        ea <span style="color:#f92672">=</span> idaapi<span style="color:#f92672">.</span>bin_search(address_start, address_end, pattern, idaapi<span style="color:#f92672">.</span>BIN_SEARCH_CASE)
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;[+] Pattern found at: </span><span style="color:#e6db74">{0}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(hex(ea)))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ea
</span></span></code></pre></div><p>At first glance this code could seem a mess, but it‚Äôs easier than expected. Let‚Äôs do a deep dive. The parameters <strong>address_start</strong> | <strong>address_end</strong> are related to the text segment, since we are looking for the signature within the whole segment space. To understand the parameters passed to <strong>idaapi.parse_binpat_str</strong>, we could refer to its <a href="https://www.hex-rays.com/products/ida/support/idapython_docs/ida_bytes.html">documentation</a>. However, for interruption its signature is given here:</p>
<blockquote>
<p><strong>parse_binpat_str(out, ea, _in, radix, strlits_encoding=0) -&gt; str</strong> (the odd variable could be represented by the out parameter. However it represents a vector of compiled binary patterns, that will be later used with bin_search()). Running those functions together it‚Äôs possible to observe few references related to the deobfuscation string used within the <strong>.text</strong> segment, then if we look for those references in IDA we could see that with those few bytes we were able to get all we needed to move forward to collect all the obfuscated parameters.</p>
</blockquote>
<p><img src="https://lh5.googleusercontent.com/4gWjUL1uVbmX1aIjD6h6emg_1IjrTWq7m9I8iUt5oaI7sOwSddMLk9LJj9usj0Zo4OeMkQfAIf8sqBzkwRJwXB_-7_adbxB0V3YZCtk_QS7Ar4ykqA1ovZYgEgDhEAniCKz569KUV5jBsiQw8VoQPSQ" alt="Figure 3 - Code reference of deobfuscation routine">
Figure 3 - Code reference of deobfuscation routine</p>
<h2 id="collecting-parameters">Collecting parameters</h2>
<p>Now we have tested that our script successfully identifies the function within the <strong>.text</strong> segment, however, before proceeding collecting its parameters, it is important to also get information related to its usage. To do so, we could use the returning value from the <strong>bin_search</strong> function and use them as a parameter for <strong>idaapi.get_func()</strong> that will return the addresses where our deobfuscation routine is actually used. As a final step to locate all its references it‚Äôs possible to use the function <strong>idautils.XrefsTo</strong> as follow:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">locate_decrypt_function</span>(function_address):
</span></span><span style="display:flex;"><span>    xref_list <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> xref <span style="color:#f92672">in</span> idautils<span style="color:#f92672">.</span>XrefsTo(function_address):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> xref<span style="color:#f92672">.</span>frm <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> xref_list:
</span></span><span style="display:flex;"><span>            xref_list<span style="color:#f92672">.</span>append(xref<span style="color:#f92672">.</span>frm)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> list(xref_list)
</span></span></code></pre></div><p>Through this method I‚Äôve just created a list that is going to contain all function references. From that list, it is possible to iterate all over the function call and retrieve the obfuscated string.</p>
<p><img src="https://lh6.googleusercontent.com/oeQLy6NE6GfIe-DTLErQgVmQwSBzaCf-EM5DB666-y--7RES2yKOYnQXaTQ8evd24clMhEvmhiKXYQvMUSohzaTWMmgqigSMNu74lr-6czaTyxRp8VL7mR82Ge9JKdXQq6FWMYOMb7dcSmGR91OdN_0" alt="Figure 4 - finding function code and its usage">
Figure 4 - finding function code and its usage</p>
<p>Now, in order to find out the parameters, it‚Äôs necessary to observe the pattern used by this sample to understand how to collect the obfuscated string. Observing all the occurrences retrieved, it‚Äôs possible to create a function that retrieves all parameters named ‚Äúoffset‚Äù with mnemonic push (opcode <strong>68</strong>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">gather_string_offset</span>(xref_address):
</span></span><span style="display:flex;"><span>    function_start <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>get_func_attr(xref_address, FUNCATTR_START)
</span></span><span style="display:flex;"><span>    new_address <span style="color:#f92672">=</span> xref_address
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>        prev_address <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>prev_head(new_address)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> prev_address <span style="color:#f92672">&lt;=</span> function_start:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> idc<span style="color:#f92672">.</span>print_insn_mnem(prev_address) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;push&#34;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> idc<span style="color:#f92672">.</span>print_operand(prev_address,<span style="color:#ae81ff">0</span>)<span style="color:#f92672">.</span>split()[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;offset&#34;</span>: 
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> idc<span style="color:#f92672">.</span>get_operand_value(prev_address, <span style="color:#ae81ff">0</span>) 
</span></span><span style="display:flex;"><span>        new_address <span style="color:#f92672">=</span> prev_address
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;[!] Offset not found.&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span></code></pre></div><p>The function presented here, it‚Äôs pretty straightforward. It takes the <strong>fucntion_start</strong> parameters that represents the function block that contains the instruction <strong>call DeobfuscateString</strong> (since the code it‚Äôs all written within the main function, <strong>fucntion_start</strong> will be the first instruction in the main. However, in other example our DeobfuscateString function could be part of another subroutine and in that case, the function_start will point to the first instruction of that routine ) Then, from the function the instruction call DeobfuscateString, we start to move backward in order to find out the <strong>offset</strong> parameter that will point to our obfuscated string. It‚Äôs worth mentioning that the code <strong>prev_address &lt;= function_start it‚Äôs used to avoid going over the main function boundaries</strong> (it doest make any sense to go backward over that line, since our code should be located there).</p>
<p>Now that we have collected all string references related to each call, we are still required to get the whole obfuscated string. In fact, through our code we were able to get the first byte of each string but it‚Äôs required to get the whole reference to forward the string to the deobfuscation routine:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">retrive_string</span>(offset):
</span></span><span style="display:flex;"><span>    obfuscated_string <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> chr(idaapi<span style="color:#f92672">.</span>get_byte(offset <span style="color:#f92672">+</span> counter)) <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span>:
</span></span><span style="display:flex;"><span>        obfuscated_string <span style="color:#f92672">+=</span> chr(idaapi<span style="color:#f92672">.</span>get_byte(offset <span style="color:#f92672">+</span> counter))
</span></span><span style="display:flex;"><span>        counter <span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> obfuscated_string
</span></span></code></pre></div><p>The script here, takes the first string byte and it starts to move forward until a NULL byte it‚Äôs located (In this case, the null byte represents the end of our string).</p>
<h2 id="deobfuscation-function">Deobfuscation function</h2>
<p>After retrieving the string, it‚Äôs a matter of implementing the deobfuscation routine and applying it to the collected strings. Implementation details are left as an exercise for curious reversers that would like to make it on their own. Since implementation of this specific case it‚Äôs actually pointless for a real case scenario, it will be skipped from this article and will be directly implemented within the final IDA-python script.</p>
<h2 id="script-testing">Script Testing</h2>
<p>To run our script it‚Äôs possible to go in <em>File &gt; Script</em> <em>file</em>, selecting the proper <em>ida_python</em> script. Testing the script in IDA, it&rsquo;s possible to observe that all obfuscated strings have been correctly deobfuscated and a little comment has been added to the end of each string reference.</p>
<p><img src="https://lh6.googleusercontent.com/CZC2L6z-Ie0G8mb6v0Nutciep3hXx7AerWk-c6vr52u1QyEIicO-E76156SnByknVj8_JtB-m2lZCxuSB_NBst6miGqVh8vcz3zNg81m4raC4QCVV1can-KqGLdLRNp5YH1IzPm9MzhEANTWX-J4XFY" alt="Figure 5 - Variable deobfuscated successfully">
Figure 5 - Variable deobfuscated successfully</p>
<h2 id="conclusion">Conclusion</h2>
<p>This post has been written to illustrate an effective and quite useful technique to locate interesting functions within a binary and to write a custom IDA-python script that is capable of finding all function occurrences. This approach it‚Äôs actually very helpful also to avoid configuration dependencies, giving to our script the ability to be shared <strong>without tweaking specific parameters</strong> that could rely on IDA instances.</p>
<h3 id="references">References</h3>
<ul>
<li>Ida-python script: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/IDA-python/function_search/fSearch.py">fSearch.py</a></li>
<li>source code: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/IDA-python/function_search/test/obfuscation.c">obfuscation.c</a></li>
<li>compiled sample: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/IDA-python/function_search/test/obfuscation.exe">obfuscation.exe</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Extracting DDosia targets from process memory</title>
            <link>https://Viuleeenz.github.io/posts/2023/05/extracting-ddosia-targets-from-process-memory/</link>
            <pubDate>Mon, 08 May 2023 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2023/05/extracting-ddosia-targets-from-process-memory/</guid>
            <description>Introduction This post is part of an analysis that I have carried out during my spare time, motivated by a friend that asked me to have a look at the DDosia project related to the NoName057(16) group. The reason behind this request was caused by DDosia client changes for performing the DDos attacks. Because of that, all procedures used so far for monitoring NoName057(16) activities did not work anymore.
Before starting to reverse DDosia Windows sample, I preferred to gather as much information as possible about NoName057(16) TTPs and a few references to their samples.</description>
            <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>This post is part of an analysis that I have carried out during my spare time, motivated by a friend that asked me to have a look at the DDosia project related to the NoName057(16) group. The reason behind this request was caused by DDosia client changes for performing the DDos attacks. Because of that, all procedures used so far for monitoring NoName057(16) activities did not work anymore.</p>
<p>Before starting to reverse DDosia Windows sample, I preferred to gather as much information as possible about NoName057(16) TTPs and a few references to their samples.</p>
<p><a href="https://decoded.avast.io/martinchlumecky/ddosia-project-how-noname05716-is-trying-to-improve-the-efficiency-of-ddos-attacks/">Avast</a> wrote a very detailed article about that project and described thoroughly all changes observed in the last few months. Because of that, before proceeding with this post, If you feel you are missing something, I strongly¬† recommend that you read their article.</p>
<h2 id="client-setup">Client Setup</h2>
<p>According to the information retrieved from the Telegram channel of DDosia Project, there are a couple of requirements before executing the client. The very first action is to create your id through a dedicated bot that will be used later on for authentication purposes. After that, it&rsquo;s necessary to put the client_id.txt file (generated from DDosia bot) and the executable file in the same folder. If everything has been done properly, it should be possible to observe that authentication process will be done correctly and the client is going to download targets from its server:</p>
<p><img src="/img/ddosia/c_a.png" alt="Figure 1: Client authenticated correctly"></p>
<p>Figure 1: Client authenticated correctly</p>
<h2 id="dynamic-analysis-and-process-memory-inspection">Dynamic analysis and process memory inspection</h2>
<p>Here we are with the fun part. Because of the issues of analyzing GO binaries statically, I preferred to use a dynamic approach supported by Cape sandbox. In fact, executing the client with Cape it was possible to gather behavioral information to speed up our analysis (<a href="https://capesandbox.com/analysis/385183/">ref</a>). Since the executable is going to be used for DDoS attacks, it&rsquo;s easy to expect that most of the functions are related to network routines. One of the most interesting WindowsAPI refers to <a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsastartup">WSAStartup</a>. This is interesting for us, because according to Microsoft documentation, it must be the first function to be used in order to retrieve socket implementation for further network operations:</p>
<blockquote>
<p>The WSAStartup function must be the first Windows Sockets function called by an application or DLL. It allows an application or DLL to specify the version of Windows Sockets required and retrieve details of the specific Windows Sockets implementation. The application or DLL can only issue further Windows Sockets functions after successfully calling WSAStartup.</p>
</blockquote>
<p>Moreover, starting to monitor network requests with Wireshark, give us additional information about client-server interactions and targets retrieving procedure:</p>
<p><img src="/img/ddosia/network_communication.png" alt="Figure 2 - Request for target list"></p>
<p>Figure 2 - Request for target list</p>
<p>As already mentioned on Avast blogspot, the target list is encrypted and retrieved after the authentication process. However, performing DDoS attacks requires a decryption routine to make targets in cleartext and forward them to a proper procedure. With this insight, it‚Äôs possible to open up a debugger and set a breakpoint of WSAStartup and start exploring the process flow from that point.</p>
<p><img src="/img/ddosia/control_flow.png" alt="Figure 3 - Exploring DDosia executable control flow"></p>
<p>Figure 3 - Exploring DDosia executable control flow</p>
<p>Exploring the process execution, it‚Äôs possible to observe that <strong>WSAStartup API is called two times before starting the attack.</strong> The first one has been used from the main thread to perform the authentication process on the server side, instead the second call will be done right after retrieving the target file and it will be used from another thread to start the attack phase. Since that information we are looking for has been already downloaded and hopefully decrypted (at the time of the second call) we could explore the process memory trying to identify our target list.</p>
<p><img src="/img/ddosia/cleartext_targets.png" alt="Figure 4 - Target stored in cleartext within process memory">
Figure 4 - Target stored in cleartext within process memory</p>
<p>As we expected, information is actually decrypted right before being used from threads that are in charge to flood the targets. From the cleartext sample, it‚Äôs also possible to reconstruct the original json file structure that follow this format:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{<span style="color:#f92672">&#34;target_id&#34;</span>:<span style="color:#e6db74">&#34;435te3af574b95e395847362&#34;</span>,<span style="color:#f92672">&#34;request_id&#34;</span>:<span style="color:#e6db74">&#34;23cer8c5mmp4434dlad53f2s&#34;</span>,<span style="color:#f92672">&#34;host&#34;</span>:<span style="color:#e6db74">&#34;www.tartuhly.ee&#34;</span>,<span style="color:#f92672">&#34;ip&#34;</span>:<span style="color:#e6db74">&#34;90.190.99.85&#34;</span>,<span style="color:#f92672">&#34;type&#34;</span>:<span style="color:#e6db74">&#34;http&#34;</span>,<span style="color:#f92672">&#34;method&#34;</span>:<span style="color:#e6db74">&#34;GET&#34;</span>,<span style="color:#f92672">&#34;port&#34;</span>:<span style="color:#ae81ff">443</span>,<span style="color:#f92672">&#34;use_ssl&#34;</span>:<span style="color:#66d9ef">true</span>,<span style="color:#f92672">&#34;path&#34;</span>:<span style="color:#e6db74">&#34;/otsi/$_1&#34;</span>,<span style="color:#f92672">&#34;body&#34;</span>:{<span style="color:#f92672">&#34;type&#34;</span>:<span style="color:#e6db74">&#34;&#34;</span>,<span style="color:#f92672">&#34;value&#34;</span>:<span style="color:#e6db74">&#34;&#34;</span>},<span style="color:#f92672">&#34;headers&#34;</span>:<span style="color:#66d9ef">null</span>}
</span></span></code></pre></div><p>At this point I have shown all procedures to quickly follow the execution flow until the decryption routine is called. From now on, it&rsquo;s just a matter of looking for those data within process memory and extracting them for your own purpose. It‚Äôs worth noting that information won‚Äôt be stored decrypted forever, in fact, as the executable keeps running, the json file is actually mangled in a way that is not easy to resemble it properly.</p>
<h2 id="a-little-bit-of-automation">A little bit of automation</h2>
<p>Even if the analysis has been completed and targets are correctly retrieved, I thought that giving a little tool to extract that information would be useful. Instead of doing complex stuff, I wrote two simple scripts called targets.js and recover.py. The purpose of these two files is to allow analysts from different backgrounds to extract those targets, even performing a simple memory dump. Probably there are easier and smarter techniques out there, but it was also a good chance to put in practice DBI, which I have already covered in a previous <a href="https://viuleeenz.github.io/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/">post</a>.</p>
<ul>
<li>
<p><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/DDosia_Targets/targets.js">target.js</a>: Frida script that aims to get a memory dump after the WSAStartup has been called for the second time (when payloads are in cleartext in memory).</p>
</li>
<li>
<p><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/DDosia_Targets/recover.py">recover.py</a>: it‚Äôs a simple python script that retrieves structured information from the files dumped. It‚Äôs worth noting that I limited my script to look for structured information, retrieving IP and Hostname (additional improvements are left to user‚Äôs needs).</p>
</li>
</ul>
<h2 id="script-testing">Script Testing</h2>
<p>In order to run the mentioned scripts there are two requirements to fulfill:</p>
<ul>
<li>Installing frida-tool (pip install frida-tools).</li>
<li>Create a folder named ‚Äúdumps‚Äù in the same place where you run the target.js file.</li>
</ul>
<p>If all requirements are satisfied it‚Äôs just a matter of running those scripts and getting the results. The first step is to run frida.exe, using the targets.js file that contains all the information to dump the process memory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>frida.exe &lt;ddosia_client.exe&gt;  -l targets.js
</span></span></code></pre></div><p>If everything has been done correctly (please keep in mind the requirements), you should be able to see a message ‚Äú[END] Memory dumped correctly‚Äù in your console.</p>
<p><img src="/img/ddosia/frida_dump.png" alt="Figure 5 - Dumping process Memory with Frida"></p>
<p>Figure 5 - Dumping process Memory with Frida</p>
<p>Now you can navigate in dumps folder and run the python script using the following command line that is going to forward all dumped file from the current directory to the script that is going to print the result in your console:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>python.exe recover.py (Get-Item .\*dump)
</span></span></code></pre></div><p><img src="/img/ddosia/target_extraction.png" alt="Figure 6 - Extracting DDosia targets from dumped files"></p>
<p>Figure 6 - Extracting DDosia targets from dump files</p>
<h2 id="final-notes">Final Notes</h2>
<p>Before concluding, It‚Äôs worth mentioning that updates on these scripts and new techniques to dealing with further improvements of DDosia project are not going to be shown, because it represents a topic that I‚Äôm not following personally and I‚Äôm sure that more authoritative voices will keep track of this threat and its evolution.</p>
<hr>
<h3 id="2023-11---update-">[2023-11 - UPDATE ]</h3>
<p>As mentioned in the section above I‚Äôm not able to provide updates on real-time DDosia Project changes, but since it represents a quite good challenge to sharpen my reversing skills on GO binaries (and I received unexpected feedback about this work), I decided to look in their new Windows client version.</p>
<p>Since I would like to keep this update note as brief as possible, I‚Äôll go straight to the point. What really changes and makes the previous frida script ineffective are slightly binary improvements (mostly related to the syscalls used). Because of that I tried to switch monitored syscall to <a href="https://learn.microsoft.com/en-us/windows/console/writeconsole"><strong>WriteConsoleW</strong></a>, hooking on the message that confirmed the numbers of targets retrieved. I found out that I really needed to change 1 line of the previous script to keep it updated. (Great example of code reuse xD).</p>
<h3 id="note"><strong>Note:</strong></h3>
<p>The modification required was pretty easy, however, this change could be also more consistent for further updates (limiting to tweak a little bit with counter variable) since it exploits the feedback messages (e.g., target acquired, requests completed, rewards, etc..) that won‚Äôt be removed any time soon.</p>
<p>Moreover, most of this blogpost it&rsquo;s still a valid reference for setting up the environment and understanding the control flow to retrieve the actual targets, additionally, as far as I know, there were no great changes on the authentication layer. Previous configured environments needs to replace the old binary to the newer provided on DDosia channel.</p>
<ul>
<li>New frida script: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/DDosia_Targets/console.js">console.js</a></li>
</ul>
<hr>
<h3 id="references">References:</h3>
<table>
<thead>
<tr>
<th>FileName</th>
<th>Sha256</th>
<th>Date</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="(https://www.virustotal.com/gui/file/726c2c2b35cb1adbe59039193030f23e552a28226ecf0b175ec5eba9dbcd336e)">d_windows_amd64.exe</a></td>
<td>726c2c2b35cb1adbe59039193030f23e552a28226ecf0b175ec5eba9dbcd336e</td>
<td>2023/04/19</td>
</tr>
<tr>
<td>(new sample) <a href="https://www.virustotal.com/gui/file/1b53443ebaabafd6f511d4cf7cb85ddf9fa32540c5dd5621f04a3c5eefa663a9">d_win_x64.exe</a></td>
<td>1b53443ebaabafd6f511d4cf7cb85ddf9fa32540c5dd5621f04a3c5eefa663a9</td>
<td>2023/11/09</td>
</tr>
</tbody>
</table>
]]></content>
        </item>
        
        <item>
            <title>Dynamic Binary Instrumentation for Malware Analysis</title>
            <link>https://Viuleeenz.github.io/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/</link>
            <pubDate>Tue, 14 Mar 2023 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/</guid>
            <description>Introduction Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary.</description>
            <content type="html"><![CDATA[<h2 id="introduction"><strong>Introduction</strong></h2>
<p>Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary.</p>
<p>Since I would like to skip redundant topics that are already written all over the internet by people that are Jedi in this field, I‚Äôm going to limit this post linking references that would be nice to have to understand everything easily.</p>
<ul>
<li><a href="https://frida.re/docs/javascript-api/">Frida</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">Windows API</a></li>
<li><a href="https://research.checkpoint.com/2020/gozi-the-malware-with-a-thousand-faces/">Ursnif/Gozi</a></li>
</ul>
<h2 id="intercepting-function-calls"><strong>Intercepting function calls</strong></h2>
<p>Most of the time, malware, in order to write memory and run code from the newly allocated space, make use of two functions, such as: <strong>VirtualAlloc</strong> (<a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">ref.</a>) and <strong>VirtualProtect</strong> (<a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">ref</a>.). For the purpose of our task, I have chosen the VirtualProtect function, because at the time of its calling, the data (payload) should be already there and it would be easier to analyze.</p>
<p>So let‚Äôs start to write out the code that retrieves the <strong>reference</strong> of this function and the interceptor that is going to be used to monitor function calls entry and return. Thanks to Frida, it is possible to directly retrieve function arguments through the variable <strong>args</strong> and check their values. The most important parameter and the one that will be used for our purpose is the <strong>lpAddress</strong> that represents the address space that is involved in this function call.</p>
<p><img src="https://lh3.googleusercontent.com/mra9ne7fbva4FUzxVzhFwTz2QWCiv3W5nM6SvVJT-fMqx2VoyXA-SMrFV_5yx6mVkbWUiLNg9Xxx-c_uEuMRGFrVCGRDp5Cg7cPOOQ9V6lBUu592qFLb4ebOsaVA8ra1ykjAxnhz6F4nbZDjU-RwZqc" alt="Figure 1 - References to VirtualProtect and call Interceptor"></p>
<p>Figure 1 - References to VirtualProtect and call Interceptor</p>
<p>Because of the purpose of the article we are not interested in all <strong>VirtualProtect</strong> calls but we would like to limit our scope to ones that contain a PE header.¬† To do this, it&rsquo;s possible to verify if <strong>lpAddress</strong> starts with ‚Äú<strong>MZ</strong>‚Äù or ‚Äú<strong>5d4a</strong>‚Äù. If so, we could print out some values in order to check them against the running executable using tools such as <strong>ProcessMonitor</strong> or <strong>ProcessHacker</strong>.</p>
<p><img src="https://lh6.googleusercontent.com/YwJkMozUWoo0bIKWP2QTX_Fr18F3LdGhRu4P2AznmONaPx305jNoDDQRHaAeHQExP96jrpxPjM6QDjxJ2IlFQfaN5oIbAYPImYP-Wq7JalzBHtuPWvcDBptVWvbiInjyAtFl5NUEE9XXvjsV8gE6Vkk" alt="Figure 2 - Printing VirtualProtect arguments"></p>
<p>Figure 2 - Printing VirtualProtect arguments</p>
<h2 id="retrieving-the-payload"><strong>Retrieving the payload</strong></h2>
<p>Now comes the tricky part. If we simply apply this technique to dump the memory that contains the <strong>MZ</strong>, it would be possible for us to also dump the binary that we originally started the infection with. However, analyzing Ursnif code, it&rsquo;s possible to see that it creates a dedicated memory space to write its final stage that is commonly referenced as a DLL. In order to avoid that, it&rsquo;s possible to use a function <em>findModuleByAddress</em> that belongs to the <em>Process</em> object.</p>
<p>As reported by Frida documentation:</p>
<blockquote>
<p>Process.findModuleByAddress(address) returns a <strong><a href="https://frida.re/docs/javascript-api/#module"><code>Module</code></a></strong> whose <em>address</em> or <em>name</em> matches the one specified. In the event that no such module could be found, the <em>find</em>-prefixed functions return <em>null</em> whilst the <em>get</em>-prefixed functions throw an exception.</p>
</blockquote>
<p>In order to avoid exception handling stuff I have preferred to go with find prefix function and then checking if the Module returned is equal to null. Otherwise, we would have an existing module object and¬† module.base = image base.</p>
<p>Now, as a final step before moving on and dumping the actual payload, it&rsquo;s necessary to retrieve the page size to which¬† <strong>lpAddress</strong> belongs. That information could be retrieved using the findRangeByAddress that¬† return an object with details about the range (memory page) containing address.</p>
<p><img src="https://lh4.googleusercontent.com/disgHE5VRs6Ob1F0hCt2bKCsfuc3AsxUFViJkqkf_EfYYCmpsiUOILazwCz6asBUsj3paJZ5Libw9N0dYYGSzY60PQRmukGzwFTDfkONM_V2McgqX69kVVlUzrRksfiuM48oDS_GzsPzMQA9gz_GN5E" alt=" Figure 3 - Checking for payload address"></p>
<p>Figure 3 - Checking for payload address</p>
<h2 id="dumping-config-file"><strong>Dumping config file</strong></h2>
<p>Now that we have all the information required, it‚Äôs time to dump the actual Ursnif payload. In order to do this, it&rsquo;s possible to read the page related to <strong>lpAddress</strong> using the <em>readByteArray</em> using the <strong>module.size</strong>. Once the information has been stored, it‚Äôs possible to write it in a file that could be used later on for further manipulation and analysis.</p>
<p><img src="https://lh3.googleusercontent.com/ju4MZv16hQgyeT6Si6wn_Y6-ble6sl4Oq8L2Jx93vCt3OpxmJBjDvdRCDD9yDVsUIRueQSPksuWVEMsxNUppGE1DsNM5F_PGdanWV4_wqOSuNpUnst2UdLT7emcpaaJMYuLigwBKRvHzuTyY86E3q2U" alt=" Figure 4 - Dumping Ursnif payload"></p>
<p>Figure 4 - Dumping Ursnif payload</p>
<p>It‚Äôs worth noting that before proceeding with the configuration extraction phase, it‚Äôs necessary to modify <code>Raw addresses</code> and <code>Virtual Addresses</code> of each section¬† header accordingly. This step is necessary because the payload was extracted directly from memory.</p>
<h2 id="script-testing"><strong>Script Testing</strong></h2>
<p>Now that we have completed our script it&rsquo;s time for testing with a real case! Let‚Äôs take one of the recent samples delivered by the TA and see if it works. For this example I have chosen a publicly available sample on <a href="https://bazaar.abuse.ch/sample/83ece9c5d6ffe0e99276becec96bc1c181a731ebd2fb95eaef329d2fbbec7271/">MalwareBazar</a>.</p>
<p>Running the script against this sample with Frida as follow:</p>
<p><code>frida.exe &lt;mal_executable&gt; -l &lt;your_script.js&gt;</code></p>
<p>It will produce a file called <strong>0x2cf0000_mz.bin</strong> (it may vary from the memory address allocation on your machine).</p>
<p><img src="/img/dbi/extractionWithFrida.png" alt="Figure 5 - Ursnif payload extraction with Frida"></p>
<p>Figure 5 - Ursnif payload extraction with Frida</p>
<p>If we open this file with PE-Bear, what should alert us, is the import table that contains unresolved information. This happens, because our code has been extracted directly from memory and before proceeding with our analysis it is necessary to map the raw sections addresses with their virtual counterparts (for brevity I have prepared a script that is going to perform these steps automatically). After having settled the addresses properly, it‚Äôs possible to proceed with configuration extraction through a custom script (that is out of the scope for this post).</p>
<h2 id="reference">Reference</h2>
<ul>
<li>DBI script: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/DynamicBinaryInstrumentation/mon.js">mon.py</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Manually unpacking of packed executable</title>
            <link>https://Viuleeenz.github.io/posts/2021/09/manually-unpacking-of-packed-executable/</link>
            <pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2021/09/manually-unpacking-of-packed-executable/</guid>
            <description>Introduction In this post, I will show how to manually unpack a simple executable that has been packed with WinUPack. However, the goal of this post is to provide a general approach to start reversing code and, in general, packers. Because of that it will be hard to cover all the techniques and strategies that could be applied, but I will try to give the rights hints and the mindset to approach these challenges.</description>
            <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>In this post, I will show how to manually unpack a simple executable that has been packed with WinUPack.
However, the goal of this post is to provide a general approach to start reversing code and, in general, packers.
Because of that it will be hard to cover all the techniques and strategies that could be applied,
but I will try to give the rights hints and the mindset to approach these challenges.</p>
<p>I will also try to highlight references to concepts that are almost mandatory to understand when you start doing this activity.</p>
<p>Before to proceed, all files and tools used in this tutorial are available at the following links:</p>
<ul>
<li><a href="https://storage.ey.md/Technology%20Related/Programming%20%26%20Reversing/Tuts4You%20Collection/UnPackMe%20Collection/PE32/WinUpack%200.38.rar">Packed executable</a></li>
<li><a href="http://www.openrce.org/downloads/details/108/OllyDump">OllyDump</a></li>
<li><a href="https://webscene.ir/tools/show/Import-REConstructor-1.6-FINAL">Import Rec</a></li>
</ul>
<p>I expect that most of the people that are approaching this post are already aware of packing techniques and how these are generally implemented.
However, since I strongly dislike to take for granted even this little details, a good reference to dig deeper about this topic is:</p>
<ul>
<li><a href="https://techtalk.pcmatic.com/2017/10/04/debugging-unpacking-malicious-software/">Debugging and Unpacking malicious software</a></li>
</ul>
<p>Let&rsquo;s start to make our hands a little bit dirty :)</p>
<h2 id="loading-exe-file-in-ollydbg">Loading .exe file in OllyDbg</h2>
<p>As soon as you load this file in OllyDbg you&rsquo;ll see an error message related to a corrupted <a href="https://tech-zealots.com/malware-analysis/pe-portable-executable-structure-malware-analysis-part-2/">PE Header</a>.</p>
<p>However, this error won‚Äôt prevent us to debug the application, if we try to run it (F9) the application stopped at 770A01C8 (in my case) and if you follow the execution step-by-step (F8), it will terminate almost immediately with a message box.</p>
<p>So let&rsquo;s step back where the application stopped. On the stack tab, we&rsquo;ll see something like this:</p>
<pre tabindex="0"><code>0018FFF4      | 00401018   | UnPackMe.00401018 |
</code></pre><p>Since it is the only function that is still in the stack, we could be confident that it represents the address of entry point of our PE. This insight is confirmed exploring the PE Header, in fact we saw the ImageBase = 400000 and the AddressOfEntryPoint = 1018 (since it is a <a href="https://tech-zealots.com/malware-analysis/understanding-concepts-of-va-rva-and-offset/">relative address</a>, we need to sum it with the ImageBase).</p>
<p>According to the information acquired, we could start placing a breakpoint at 00401018 and try to follow the execution step-by-step. After few instructions the stack tab should be similar to this one:</p>
<pre tabindex="0"><code>......
0018FF80   75581222  kernel32.GetProcAddress
0018FF84   755849D7  kernel32.LoadLibraryA
0018FF88   004271B0  UnPackMe.004271B0
0018FF8C   755833CA  RETURN to kernel32.755833CA
0018FF90   7EFDE000
0018FF94  /0018FFD4
0018FF98  |770C9ED2  RETURN to ntdll.770C9ED2
0018FF9C  |7EFDE000
0018FFA0  |7540DB7C
0018FFA4  |00000000
0018FFA8  |00000000
0018FFAC  |7EFDE000
0018FFB0  |00000000
0018FFB4  |00000000
0018FFB8  |00000000
0018FFBC  |0018FFA0
0018FFC0  |00000000
0018FFC4  |FFFFFFFF  End of SEH chain
0018FFC8  |77101ECD  SE handler
0018FFCC  |0253E188
0018FFD0  |00000000
0018FFD4  \0018FFEC
0018FFD8   770C9EA5  RETURN to ntdll.770C9EA5 from ntdll.770C9EAB
0018FFDC   00401018  UnPackMe.00401018
0018FFE0   7EFDE000
0018FFE4   00000000
0018FFE8   00000000
0018FFEC   00000000
0018FFF0   00000000
0018FFF4   00401018  UnPackMe.00401018
0018FFF8   7EFDE000
0018FFFC   00000000
</code></pre><p>As you can see from the stack, we have the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/structured-exception-handling">SEH</a> (structured exception handling) and on the top of it, there are two interesting functions (<a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> and <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibraryA</a>).</p>
<p><strong>GetProcAddress</strong> retrieves the address of an exported function or variable from the specified dynamic-link library (DLL), instead the function <strong>LoadLibraryA</strong> loads the specified module into the address space of the calling process (note that this module may cause other modules to be loaded).</p>
<p>Since we are trying to follow a repeatable approach, according to the information retrieved so far we could start guessing
(and then proving or refusing) something about the application. As far as we know, the application starts to load some dll (e.g., kernel32.dll) and then from each of them retrieve all functions that are needed for the executable. Then when everything is correctly settled, the application should go back to the OEP (Original Entry Point).</p>
<p><strong>In order to follow this insight its important to understand where these function are called and place a breakpoint there.</strong></p>
<h2 id="examining-a-function-call">Examining a function call</h2>
<p>From here, there are uncountable ways to move forward in order to find the OEP. We could look through the code to understand where GetProcAddress or LoadLibraryA are called for the last time, or we could also find the last function and the last library loaded and from that point move forward to reach the OEP, otherwise we could also look for specific blocks that are commonly used to save the OEP.</p>
<p>However, showing a specific technique is out of scope (as I said, <strong>I would like to give some hints and a mindset to approach to these challenges</strong>),
I&rsquo;m going to explore a little bit more the binary in order to be able to retrieve the OEP, dump the binary and restoring also the IAT (Import Address Table).</p>
<p>After these clarifications we are now ready to proceed with our analysis.</p>
<p>Since we were able to identify GetProcAddress and LoadLibraryA functions on the stack, we could easily move forward until we don&rsquo;t see
that these function are actually called within the UnPackMe address space. In my case, these functions are called from the UnPackMe address space at the following addresses:</p>
<ul>
<li>LoadLibraryA   0049A053</li>
<li>GetProcAddress 0049A06A</li>
</ul>
<p>Now let&rsquo;s go deep a little bit in detail, examining the LoadLibraryA function call and its returning value (the approach is the same for GetProcAddress ).</p>
<p>If you followed the <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">link</a> related to this function you are now aware that LoadLibrabryA take a single parameter that represents the module name. According to the <a href="https://en.wikibooks.org/wiki/X86_Disassembly/Calling_Conventions">calling convention</a> in x86 this parameters are commonly pushed on the stack, instead the return value is stored in the EAX registry.</p>
<p><img src="/img/winupack/loadLibrary.png" alt="LoadLibraryA details"></p>
<p>From the figure above It is easy to spot that:</p>
<ul>
<li>ESI contains the module name &ldquo;USER32.DLL&rdquo;,</li>
<li>ECX contains the function address of LoadLibraryA.</li>
</ul>
<p>In order to check if EAX contains the module&rsquo;s handler, we do a single step forward after the call ECX instruction. After that instruction we are able to see that EAX contains the handler for the module USER32.</p>
<pre tabindex="0"><code>EAX 74EA0000 OFFSET USER32.#2338
</code></pre><p>Eventually, when the last call to the LoadLibraryA and GetProcAddress are performed the EIP will reach the address <code>0049A06F</code> that contains the <code>RETN</code> instruction that will lead us the actual OEP.</p>
<p><img src="/img/winupack/OEP.png#center" alt="OEP"></p>
<p>Since we were able to go back to the OEP, <strong>we are also confirming that our initial hypothesis was correct</strong>! (Yes I cheated a little bit, since I already knew that it was the right path :) .</p>
<p>From now on, its just a matter of:</p>
<ol>
<li>Dump the executable with Ollydump</li>
<li>Attach to the debugging process with ImportREC</li>
<li>Set the new OEP and search for the IAT.</li>
<li>Fix dump</li>
</ol>
<p>These steps are left as homework for the few people that reached this point :)</p>
<h2 id="conclusion">Conclusion</h2>
<p>To conclude, in this brief post we saw how to manually examine a binary that has been packed, looking for clues, formulate hypothesis and then working to confirm or reject them.</p>
<p>In my experience, reversing isn&rsquo;t going in the middle of the code without an idea, it‚Äôs important to follow a method that should be as general as possible. In order to get better, I strongly recommend to practice with other sample trying to apply the same approach we saw here.</p>
<p>In case of doubts, unclear part, or just feedback about this post, feel free to reach me on my mail account.</p>
]]></content>
        </item>
        
    </channel>
</rss>
