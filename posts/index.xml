<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Security Undisguised</title><link>https://Viuleeenz.github.io/posts/</link><description>Recent content in Posts on Security Undisguised</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Thu, 28 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://Viuleeenz.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>From one to many - one IOC to hunt them ALL</title><link>https://Viuleeenz.github.io/posts/2025/08/from-one-to-many-one-ioc-to-hunt-them-all/</link><pubDate>Thu, 28 Aug 2025 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2025/08/from-one-to-many-one-ioc-to-hunt-them-all/</guid><description>&lt;p>&lt;em>If you are a threat researcher reading a blog post about a novel threat that could potentially impact your organization, or if you need to investigate this threat to enrich your internal telemetry for better tracking and detection, how would you proceed?&lt;/em>&lt;/p>
&lt;p>This was the question that come up in my mind, out of the blue, reading an article from Unit42 where they start to talk about a novel malware sold in the underground named &lt;a href="https://unit42.paloaltonetworks.com/new-malware-gremlin-stealer-for-sale-on-telegram/">Gremlin stealer&lt;/a>. As always the article is very well detailed, carefully explaining the malware‚Äôs characteristics and objectives while also providing the SHA-256 hash of the analyzed sample.&lt;/p></description><content type="html"><![CDATA[<p><em>If you are a threat researcher reading a blog post about a novel threat that could potentially impact your organization, or if you need to investigate this threat to enrich your internal telemetry for better tracking and detection, how would you proceed?</em></p>
<p>This was the question that come up in my mind, out of the blue, reading an article from Unit42 where they start to talk about a novel malware sold in the underground named <a href="https://unit42.paloaltonetworks.com/new-malware-gremlin-stealer-for-sale-on-telegram/">Gremlin stealer</a>. As always the article is very well detailed, carefully explaining the malware‚Äôs characteristics and objectives while also providing the SHA-256 hash of the analyzed sample.</p>
<p>Generally speaking, shared IOCs are invaluable resources for the security community, as detection capabilities often depend on the breadth of threat intelligence available in your platform. However, IOC collections can vary dramatically in quality and scope. Sometimes you&rsquo;ll find comprehensive lists containing everything from phishing email hashes and malware stages to domains and JavaScript files. Other times, you&rsquo;re left with minimal intelligence‚Äîperhaps just a single hash and a brief description‚Äîmaking threat hunting significantly more challenging.</p>
<blockquote>
<p>üí°<em>When you encounter a new threat and there aren‚Äôt many resources to rely on, you must leverage your own internal data to collect additional intelligence. This allows you to extract valuable IOCs, pivot across related malware infrastructures, and discover additional hidden samples.</em></p>
</blockquote>
<p>In this blog post, we‚Äôll walk through a <strong>threat-hunting methodology</strong> using <strong>Gremlin Stealer</strong> as our primary case study. We‚Äôll explore how to extract <strong>meaningful intelligence</strong> from a single malware sample ‚Äî <strong>without heavily relying on reversing activities</strong> ‚Äî and transform that knowledge into <strong>actionable hunting strategies</strong> capable of detecting broader threat actor operations.</p>
<h2 id="understanding-sample-relationships">Understanding Sample Relationships</h2>
<p>Effective threat hunting begins with understanding how malware samples relate to each other. <strong>Static characteristics</strong> form the foundation of this analysis. File hash relationships are particularly valuable‚Äîsearching for samples with the same <strong>imphash</strong> (import hash) can reveal binaries that use similar API patterns, while <strong>ssdeep</strong> and other fuzzy hashing techniques help identify files with comparable byte-level structures, even when their exact hashes differ due to minor modifications or repacking.</p>
<p>In addition to hashes, <strong>file metadata</strong> can provide another valuable layer of similarity indicators, helping connect samples that may belong to the same malware family or campaign. However, similarity analysis shouldn‚Äôt stop at static attributes. From a <strong>behavioral standpoint</strong>, distinctive indicators often emerge, such as: <strong>File creation paths, Command-line arguments, Registry modifications, Network communication patterns,</strong> etc..</p>
<p>When multiple samples shows overlapping behavioral traits ‚Äî for instance, reaching out to the same C2 infrastructure or using identical file paths ‚Äî it becomes much easier to <strong>cluster them under the same threat actor‚Äôs activity</strong>. In fact, for hunting purposes, <strong>behavioral indicators are often more reliable than static characteristics</strong>, since they reflect what the malware <strong>must</strong> do to achieve its objectives.</p>
<blockquote>
<p>üí° <em>Static characteristics are <strong>easily modified</strong> by threat actors, but behavioral requirements are <strong>functionally constrained</strong>. A threat actor can change how malware looks, but it‚Äôs much harder to change what it needs to do to succeed.</em></p>
</blockquote>
<h3 id="static-indicators">Static Indicators</h3>
<p>When examining our Gremlin Stealer sample in VirusTotal, several metadata characteristics immediately caught the attention. Each of these anomalies not only serves as a detection opportunity but also provides clues about the malware author&rsquo;s techniques and intentions:</p>
<ul>
<li>
<p><strong>Anomalous Timestamp</strong></p>
<p>The file‚Äôs reported creation date ‚Äî <strong>2041-06-29 19:48:00 UTC</strong> ‚Äî is set in the future. This is a <strong>common anti-analysis technique</strong> used by malware authors to bypass certain detection mechanisms or confuse automated analysis pipelines.</p>
</li>
<li>
<p><strong>Misleading Copyright Information</strong></p>
<ul>
<li>‚ÄúLLC &lsquo;Windows&rsquo; &amp; Copyright ¬© 2024‚Äù ( Attempts to mimic legitimate Microsoft software )</li>
</ul>
</li>
<li>
<p><strong>.NET Assembly Metadata</strong></p>
<p>Since <strong>Gremlin Stealer</strong> is a <strong>.NET binary</strong>, it exposes rich metadata that can be extremely useful for clustering related samples. Notably:</p>
<ul>
<li><strong>Module Version ID (MVID):</strong> <code>8f855bb2-4718-4fa4-be9c-87ed0b588b5c</code></li>
<li><strong>TypeLib ID:</strong> <code>7c11697d-caad-4bae-8b2a-0e331680a53b</code></li>
</ul>
<p>These identifiers are <strong>generated during compilation</strong> and often remain <strong>consistent across samples built from the same source code or development environment</strong>. As such, they can be powerful static indicators for <strong>connecting related binaries</strong> within the same malware family</p>
</li>
</ul>
<p><img src="/img/threat_hunt/gremlin_info.png" alt="Figure 1: Gremlin Stealer Information"></p>
<p>Figure 1: Gremlin Stealer Information</p>
<h3 id="behavioral-indicators">Behavioral indicators</h3>
<p>While static analysis provides valuable initial insights, behavioral analysis through sandbox execution reveals how the malware actually operates in a live environment. VirusTotal&rsquo;s sandbox capabilities allow us to observe Gremlin Stealer&rsquo;s runtime behavior, uncovering network communications, file system interactions, and process execution patterns that static analysis alone cannot reveal.</p>
<p><img src="/img/threat_hunt/gremlin_urls.png" alt="Figure 2: Gremlin Stealer URLs"></p>
<p>Figure 2: Gremlin Stealer URLs</p>
<p>Gremlin Stealer‚Äôs <strong>behavior tab</strong> reveals distinct networking fingerprints:</p>
<ul>
<li>
<p><strong>IP Discovery Services</strong>: The malware reaches out to:</p>
<ul>
<li><code>api.ipify.org</code></li>
<li><code>ip-api.com</code></li>
</ul>
<p>These requests are used to <strong>determine the victim‚Äôs external IP address</strong>, a common tactic among info-stealers for <strong>geolocation</strong> and <strong>target profiling</strong>.</p>
</li>
<li>
<p><strong>Telegram API Endpoints</strong>: Connections to <code>api.telegram.org/bot</code> could suggest that <strong>Telegram is used for data exfiltration</strong>.</p>
<ul>
<li>It&rsquo;s worth mentioning that this technique has become increasingly <strong>popular among cybercriminals</strong> due to <strong>encryption</strong>, <strong>ease of automation</strong>, and <strong>resilience against takedowns</strong>.</li>
</ul>
</li>
<li>
<p><strong>Hardcoded C2 Server</strong>: <code>207.244.199[.]46</code> is embedded as a <strong>command-and-control endpoint</strong>.</p>
<ul>
<li>This serves as both an <strong>immediate IOC</strong> and a <strong>pivot point</strong> for uncovering related infrastructure used by the same threat actor.</li>
</ul>
</li>
</ul>
<p>Moreover, digging deeper into the <strong>behavior tab</strong> reveals how Gremlin Stealer systematically <strong>harvests sensitive data</strong> from multiple browsers, including <strong>Chrome</strong>, <strong>Brave</strong>, <strong>Edge</strong>, and other Chromium-based derivatives. One particularly interesting technique involves launching browser instances with <strong>remote debugging enabled.</strong></p>
<p><img src="/img/threat_hunt/behvaioral_info.png" alt="Figure 3: VirusTotal behvaior tab for Gremlin Stealer sample"></p>
<p>Figure 3: VirusTotal behvaior tab for Gremlin Stealer sample</p>
<blockquote>
<p>üí° <em>There is <strong>no single indicator</strong> you can always rely on. Threat hunting success depends on <strong>how much information you can extract</strong> from a sample and how effectively you <strong>correlate it with other intelligence</strong>. This process requires <strong>iterative analysis</strong> and cannot be treated as a one-time or ‚Äúspot‚Äù activity.</em></p>
</blockquote>
<h3 id="exploring-vt-queries-to-collect-more-samples">Exploring VT Queries to collect more samples</h3>
<p>Crafting effective VirusTotal hunting queries is both an art and a science. The challenge lies in balancing precision with coverage‚Äîqueries that are too narrow will miss related variants, while overly broad searches generate overwhelming false positives. The sweet spot lies in identifying characteristics that are:</p>
<ul>
<li><strong>Likely to remain consistent</strong> across the threat actor‚Äôs campaigns</li>
<li><strong>Unique enough</strong> to minimize noise during collection</li>
</ul>
<p>Using the intelligence we‚Äôve gathered so far from our Gremlin Stealer sample, we can start sketching out a <strong>VirusTotal hunting query</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">generated:</span><span style="color:#e6db74">&#34;2041-06-29T19:48:00&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">signature:</span><span style="color:#e6db74">&#34;LLC &#39;Windows&#39; &amp; Copyright ¬©  2024&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">netguid:</span><span style="color:#ae81ff">8</span><span style="color:#960050;background-color:#1e0010">f</span><span style="color:#ae81ff">855</span><span style="color:#960050;background-color:#1e0010">bb</span><span style="color:#ae81ff">2-4718-4</span><span style="color:#960050;background-color:#1e0010">fa</span><span style="color:#ae81ff">4</span><span style="color:#960050;background-color:#1e0010">-be</span><span style="color:#ae81ff">9</span><span style="color:#960050;background-color:#1e0010">c</span><span style="color:#ae81ff">-87</span><span style="color:#960050;background-color:#1e0010">ed</span><span style="color:#ae81ff">0</span><span style="color:#960050;background-color:#1e0010">b</span><span style="color:#ae81ff">588</span><span style="color:#960050;background-color:#1e0010">b</span><span style="color:#ae81ff">5</span><span style="color:#960050;background-color:#1e0010">c</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">behavior:</span><span style="color:#e6db74">&#34;\&#34;%ProgramFiles(x86)%\\Google\\Chrome\\Application\\chrome.exe\&#34; --restore-last-session --remote-debugging-port=9222 --user-data-dir=\&#34;%LOCALAPPDATA%\\Google\\Chrome\\User Data\&#34;&#34;</span>
</span></span></code></pre></div><p>Starting with the first one (<em>generated:&ldquo;2041-06-29T19:48:00&rdquo;</em>) we are able to collect a couple of samples.</p>
<p><img src="/img/threat_hunt/vt_simple.png" alt="Figure 4: Potentially correlated sample with original Gremlin Stealer"></p>
<p>Figure 4: Potentially correlated sample with original Gremlin Stealer</p>
<p>As expected, the first match is <strong>our original sample</strong>. However, the second one appears to be <strong>a new potential candidate</strong> worth investigating based on its <strong>filename</strong> and metadata, which suggest it may be linked to the same campaign.</p>
<p>To validate this assumption, we need to <strong>cross-check indicators</strong> between our original sample and the new binary. Diving into the <strong>details</strong> and <strong>behavior tabs</strong> reveals strong overlaps:</p>
<ul>
<li>Matching <strong>signature strings</strong></li>
<li>Identical <strong>LegalTradeMark</strong> values</li>
<li>Same <strong>.NET Module Version ID (MVID)</strong></li>
<li>Same <strong>TypeVersion</strong> metadata</li>
</ul>
<p>Additionally, inspecting the <strong>functions list</strong> and <strong>external modules</strong> shows <strong>identical APIs and libraries</strong> in both binaries, suggesting a <strong>shared codebase</strong>.</p>
<blockquote>
<p>üí°¬†<em>At this stage, you might feel like a single new sample isn‚Äôt enough ‚Äî but resist the temptation to cast a wider net too early. Every hash you collect must be <strong>validated</strong> to ensure it‚Äôs truly related. Once you confirm multiple samples with strong correlations, you can safely expand your query and begin crafting <strong>high-confidence detection rules</strong>.</em></p>
</blockquote>
<h3 id="comparing-disassembled-code">Comparing Disassembled Code</h3>
<p>Sometimes, <strong>metadata alone isn‚Äôt enough</strong> to confidently determine whether two samples are related. In these cases, a deeper dive into the <strong>disassembled code</strong> can provide stronger evidence. By analyzing the code structure, <strong>function names</strong>, and <strong>implementation patterns</strong>, we can often spot significant overlaps that confirm a shared origin. In our case, we can clearly see that the two samples:</p>
<ul>
<li>Share a <strong>large number of identical functions</strong></li>
<li>Use the <strong>same function names</strong></li>
<li>Contain <strong>matching code blocks</strong> within those functions</li>
</ul>
<p>This level of similarity strongly suggests that both binaries were compiled from the <strong>same source code</strong> or at least from <strong>closely related codebases</strong>.</p>
<p><img src="/img/threat_hunt/disass_code.png" alt="Figure 5: Gremlin Stealer code"></p>
<p>Figure 5: Gremlin Stealer code</p>
<blockquote>
<p>üí°¬†<em>For C/C++-like binaries, a highly effective workflow is to combine <strong>IDA Pro</strong> for performing an <strong>in-depth analysis</strong> of one binary, and then leverage <strong>BinDiff</strong> to compare it against another. This highlights <strong>code-level similarities and discrepancies</strong>, making it easier to identify relationships and validate correlations between samples.</em></p>
</blockquote>
<h3 id="analyzing-additional-result-information">Analyzing additional result information</h3>
<p>After completing the investigation on the previously identified sample, we can continue our research using the same <strong>hunting methodology</strong>, but this time pivoting on other <strong>high-confidence indicators</strong> such as the <strong>signature</strong> and the <strong>netguid</strong> we collected earlier. When we pivot on the <strong>signature</strong>, VirusTotal returns <strong>15 matches</strong>. On the other hand, pivoting on the <strong>netguid</strong> produces <strong>13 matches</strong>. This discrepancy raises important questions that can fuel further investigation. Some of these questions directly influence <strong>tactical hunting</strong>, while others provide paths toward <strong>strategic intelligence</strong>.</p>
<p><img src="/img/threat_hunt/signature_and_netguid.png" alt="Figure 6: VT Queries results for signature and netguid tags."></p>
<p>Figure 6: VT Queries results for signature and netguid tags.</p>
<p>Differences in the returned results could indicate the presence of <strong>.NET build outliers</strong> that deviate slightly from the main family. To better understand them, we can:</p>
<ul>
<li>Investigate whether these <strong>outlier samples</strong> show <strong>different behavioral patterns</strong></li>
<li>Determine why these specific builds were created ‚Äî e.g., testing variants, specialized targets, or toolchain updates</li>
<li>Analyze whether these binaries communicate with <strong>different infrastructures</strong> or reuse existing ones</li>
</ul>
<p>These insights can directly enhance detection engineering and improve coverage for <strong>variant-level hunting</strong>. Beyond tactical detection, the results open the door to deeper <strong>strategic intelligence</strong> questions:</p>
<ul>
<li>How <strong>large</strong> is the organization behind Gremlin Stealer?</li>
<li>Do the different build lines suggest the involvement of <strong>multiple threat actors</strong> or a <strong>single actor with multiple operational capabilities</strong>?</li>
<li>Could these variations indicate <strong>distinct campaigns</strong> tailored for specific geographies, targets, or objectives?</li>
</ul>
<p>Answering these questions requires a broader analysis of development patterns, campaign overlaps, and infrastructure reuse ‚Äî insights that are valuable for <strong>long-term threat actor profiling</strong>.</p>
<blockquote>
<p>üí°¬†<em>Attribution remains one of the most challenging aspects of threat intelligence. Unlike traditional forensics, where physical evidence provides concrete links, <strong>cyber attribution</strong> often relies on connecting <strong>digital breadcrumbs</strong> across fragmented datasets. Accurate attribution typically involves multiple steps, including <strong>code similarity analysis</strong>, <strong>infrastructure tracking</strong>, <strong>campaign clustering</strong>, and even <strong>business model assessments</strong> ‚Äî all of which contribute to building a robust <strong>threat actor profile</strong>.</em></p>
</blockquote>
<h3 id="writing-yara-rules">Writing Yara Rules</h3>
<p>With our comprehensive intelligence gathering complete, we can now translate our findings into actionable detection logic. Creating a YARA rule allows us to codify the patterns we&rsquo;ve discovered, enabling automated detection across security platforms. Our rule needs to balance several competing priorities: broad enough to catch variants, specific enough to minimize false positives, and resilient enough to survive minor modifications by threat actors.</p>
<p>When analyzing the <strong>15 matching samples</strong>, it‚Äôs clear that some binaries contain <strong>obfuscated code</strong>, which makes relying solely on <strong>assembly instructions</strong> less effective. Instead, we‚Äôll focus on <strong>unique strings</strong> and <strong>metadata-based attributes</strong> extracted during our VirusTotal analysis.</p>
<p>Here‚Äôs an <strong>initial draft</strong> of the rule:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">rule</span> <span style="color:#960050;background-color:#1e0010">GermlinStealer</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">meta:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">description</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#f92672">&#34;Detects Gremlin Stealer&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">author</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#e6db74">&#34;Viuleeenz&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">date</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#e6db74">&#34;2025-08-25&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">hash</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#e6db74">&#34;d1ea7576611623c6a4ad1990ffed562e8981a3aa209717065eddc5be37a76132&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">reference</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#e6db74">&#34;https://unit42.paloaltonetworks.com/new-malware-gremlin-stealer-for-sale-on-telegram/&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">strings</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Fraudulent copyright and version information
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#960050;background-color:#1e0010">$metadata</span><span style="color:#ae81ff">1</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#e6db74">&#34;LLC &#39;Windows&#39; &amp; Copyright&#34;</span> <span style="color:#960050;background-color:#1e0010">ascii</span> <span style="color:#960050;background-color:#1e0010">wide</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">$metadata</span><span style="color:#ae81ff">2</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#e6db74">&#34;CefSharp.BrowsersSubprocess&#34;</span> <span style="color:#960050;background-color:#1e0010">ascii</span> <span style="color:#960050;background-color:#1e0010">wide</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">$metadata</span><span style="color:#ae81ff">3</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#e6db74">&#34;CefSharp&#34;</span> <span style="color:#960050;background-color:#1e0010">ascii</span> <span style="color:#960050;background-color:#1e0010">wide</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// .NET details
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#960050;background-color:#1e0010">$typelib_id</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#e6db74">&#34;7c11697d-caad-4bae-8b2a-0e331680a53b&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">$module_version_id</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#e6db74">&#34;8f855bb2-4718-4fa4-be9c-87ed0b588b5c&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Cryptocurrency wallet targeting
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//$crypto1 = &#34;bitcoincore&#34; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//$crypto2 = &#34;litecoincore&#34; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//$crypto3 = &#34;electrum&#34; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//$crypto4 = &#34;exodus&#34; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//$crypto5 = &#34;atomicwallet&#34; 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//$crypto6 = &#34;monero&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">$library</span><span style="color:#ae81ff">1</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#e6db74">&#34;bcrypt.dll&#34;</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">$library</span><span style="color:#ae81ff">2</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#e6db74">&#34;dllFilePath&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">$library</span><span style="color:#ae81ff">3</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#e6db74">&#34;iphlpapi.dll&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">$library</span><span style="color:#ae81ff">4</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#e6db74">&#34;kernel32.dll&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">$library</span><span style="color:#ae81ff">5</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#e6db74">&#34;user32.dll&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">condition</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">uint</span><span style="color:#ae81ff">16</span><span style="color:#960050;background-color:#1e0010">(</span><span style="color:#ae81ff">0</span><span style="color:#960050;background-color:#1e0010">)</span> <span style="color:#960050;background-color:#1e0010">==</span> <span style="color:#ae81ff">0</span><span style="color:#960050;background-color:#1e0010">x</span><span style="color:#ae81ff">5</span><span style="color:#960050;background-color:#1e0010">a</span><span style="color:#ae81ff">4</span><span style="color:#960050;background-color:#1e0010">d</span> <span style="color:#960050;background-color:#1e0010">and</span>
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">filesize</span> <span style="color:#960050;background-color:#1e0010">&lt;</span> <span style="color:#ae81ff">500</span><span style="color:#960050;background-color:#1e0010">KB</span> <span style="color:#960050;background-color:#1e0010">and</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">(any</span> <span style="color:#960050;background-color:#1e0010">of</span> <span style="color:#960050;background-color:#1e0010">($metadata*))</span> <span style="color:#960050;background-color:#1e0010">and</span>
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">(($typelib_id)</span> <span style="color:#960050;background-color:#1e0010">or</span> <span style="color:#960050;background-color:#1e0010">($module_version_id))</span> <span style="color:#960050;background-color:#1e0010">and</span>
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">(</span><span style="color:#ae81ff">3</span> <span style="color:#960050;background-color:#1e0010">of</span> <span style="color:#960050;background-color:#1e0010">($library*))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This rule focuses on <strong>three key detection pillars</strong>:</p>
<ol>
<li><strong>Metadata &amp; Branding Strings</strong>
<ul>
<li>Fake copyright claims and Chromium subprocess references</li>
<li>Helps detect samples attempting to <strong>masquerade as legitimate Microsoft software</strong></li>
</ul>
</li>
<li><strong>.NET Compilation Identifiers</strong>
<ul>
<li>Uses <code>TypeLib ID</code> and <code>Module Version ID</code> for clustering ( It&rsquo;s important to keep in mind that this is a very restrictive condition and could lead to miss some samples if the malware author make some changes in the compilation environment - e.g., modify compiler settings, use different Visual Studio or .NET framework as well as alter compilation metadata to evade detection )</li>
</ul>
</li>
<li><strong>Functional Capabilities</strong>
<ul>
<li>Includes critical <strong>Windows DLLs</strong> commonly referenced by Gremlin Stealer</li>
</ul>
</li>
</ol>
<p><img src="/img/threat_hunt/yara.png" alt="Figure 7: Yara results"></p>
<p>Figure 7: Yara results</p>
<blockquote>
<p>üí° <em>There isn‚Äôt a <strong>single YARA rule</strong> that works for every scenario. Even this rule isn‚Äôt perfect. It relies on <strong>crypto-related strings</strong>, which could affect detection efficiency in certain environments. However, this rule was designed as an <strong>experimental approach</strong> to validate its effectiveness, so testing it made sense. Similarly, the use of <strong>.NET-specific identifiers</strong> might be a bit <strong>restrictive</strong>, potentially missing variants compiled with different settings. Ultimately, the <strong>best rule design</strong> depends on your goals and the <strong>system ingesting the files</strong>. In some cases, you may want a <strong>highly tailored, precise rule</strong> that minimizes false positives; in others, a <strong>broader rule</strong> with a higher tolerance for noise might be more appropriate. The key is balancing <strong>coverage and accuracy</strong> based on your operational needs.</em></p>
</blockquote>
<h3 id="collecting-infrastructural-information">Collecting Infrastructural Information</h3>
<p>Our malware analysis has yielded valuable insights, but the investigation remains incomplete without understanding the infrastructure supporting Gremlin Stealer&rsquo;s operations. Threat actors don&rsquo;t operate in isolation‚Äîthey require command and control servers, data exfiltration channels, and often administrative panels to manage their campaigns. By mapping this infrastructure, we can uncover additional IOCs and gain deeper insight into the scope of their operations.</p>
<p>Starting from the previously identified IP address <strong>207.244.199[.]46</strong>, we can leverage tools like <a href="https://urlscan.io/">Urlscan</a> and <a href="https://app.validin.com/login">Validin</a> to expand our research. By querying this IP, we immediately uncover <strong>interesting insights</strong>, including a glimpse of what appears to be the <strong>Gremlin control panel</strong>.</p>
<p><img src="/img/threat_hunt/gremlin_infra.png" alt="Figure 8: Gremlin Stealer Control Panel"></p>
<p>Figure 8: Gremlin Stealer Control Panel</p>
<p>Digging deeper, we can extract the <strong>HTML source code</strong>, <strong>DOM structure</strong>, and <strong>associated assets,</strong> including images and icons, from the landing page. By <strong>computing hashes</strong> of these elements, we create new <strong>pivot points</strong> that can be used to identify <strong>related infrastructure</strong> and potential additional panels.</p>
<p>At this stage, we‚Äôve already collected:</p>
<ul>
<li>The <strong>landing page content</strong> and <strong>visual assets</strong></li>
<li>The <strong>DOM hash</strong> and other unique fingerprints</li>
<li>Metadata such as <strong>page title</strong> and associated <strong>icon hashes</strong></li>
</ul>
<p>Using these artifacts, we can pivot further using <strong>Validin</strong>. Starting with the same IP, we uncover additional details such as the <strong>host title</strong> used by the panel. This information becomes valuable because we can search for the same title across other servers, potentially revealing <strong>related panels</strong> deployed on <strong>different IPs</strong>.</p>
<p><img src="/img/threat_hunt/correlated_ips.png" alt="Figure 9: Additionally Control Panel IPs"></p>
<p>Figure 9: Additionally Control Panel IPs</p>
<p>Interestingly, the same <strong>host title</strong> is seen on <strong>multiple IP addresses</strong>. This is an important discovery:</p>
<ul>
<li>It <strong>suggests a broader infrastructure</strong> behind Gremlin Stealer.</li>
<li>It gives us <strong>new candidate servers</strong> to investigate.</li>
<li>Some of these IPs might still <strong>host active panels</strong>, providing opportunities for <strong>deeper intelligence gathering</strong> üëÄ.</li>
</ul>
<h3 id="sketching-a-threat-actor-profile">Sketching a Threat Actor Profile</h3>
<p>With the intelligence collected so far (e.g., <strong>malware samples, behavioral patterns, and infrastructure insights</strong>), it is possible to begin sketching a preliminary <strong>threat actor profile</strong>. By correlating static indicators like <strong>.NET identifiers and metadata</strong>, behavioral traits such as <strong>browser targeting and command-line arguments</strong>, and infrastructural data including <strong>C2 IPs and panel hostnames</strong>, we can start to infer the operational capabilities and methods of the actor behind Gremlin Stealer.</p>
<p>This profile helps answer key questions:</p>
<ul>
<li><strong>Scope and scale:</strong> How many campaigns or variants are likely active?</li>
<li><strong>Technical sophistication:</strong> Which coding practices, obfuscation techniques, and exfiltration methods are employed?</li>
<li><strong>Operational patterns:</strong> Do multiple IPs, host titles, or panel infrastructures suggest a centralized organization or distributed teams?</li>
<li><strong>Targeting focus:</strong> Are specific industries or regions being prioritized?</li>
</ul>
<p>While attribution remains challenging, building a structured profile allows analysts to <strong>prioritize investigations, anticipate next moves, and design more effective detection rules</strong>. Over time, as new samples and infrastructure emerge, this profile can be refined into a <strong>comprehensive understanding of the threat actor‚Äôs TTPs, infrastructure, and strategic objectives</strong>.</p>
<p><img src="/img/threat_hunt/ta_sketch.png" alt="Figure 10: Attempt of Gremlin Stealer sketching profile"></p>
<p>Figure 10: Attempt of Gremlin Stealer sketching profile</p>
<h3 id="conclusion">Conclusion</h3>
<p>Remember the question we started with: <em>&ldquo;If you are a threat researcher reading a blog post about a novel threat that could potentially impact your organization, or if you need to investigate this threat to enrich your internal telemetry for better tracking and detection, how would you proceed?&rdquo;</em></p>
<p>Through our Gremlin Stealer investigation, we&rsquo;ve demonstrated that the answer isn&rsquo;t as daunting as it might initially seem. <strong>You don&rsquo;t need to be a reverse engineering expert to extract meaningful intelligence from a single malware sample.</strong></p>
<p>Starting with just one hash from Unit42&rsquo;s report, we systematically built a comprehensive threat profile. The key insight? <strong>Effective threat hunting is more about methodology than advanced technical skills.</strong> It&rsquo;s about asking the right questions, knowing where to look for answers, and systematically connecting the dots between seemingly unrelated pieces of information.</p>
<p>Every indicator we discovered became a stepping stone to the next discovery. This iterative approach transformed a single IoC into a robust detection strategy capable of identifying an entire malware family and its supporting infrastructure.</p>
<p>So the next time you encounter a novel threat with limited public intelligence, don&rsquo;t be intimidated. <strong>Start with what you have, apply systematic thinking, and let curiosity guide your investigation.</strong> After all, threat hunting isn&rsquo;t just about finding malware, it&rsquo;s about understanding the adversary. And that understanding begins with a single question and the determination to find the answer.</p>
<p>Happy hunting! üîç</p>
<h3 id="hunting-insight">Hunting Insight</h3>
<p><em>This strategy can be particularly valuable when you encounter interesting malware that&rsquo;s difficult to analyze due to heavy protection and obfuscation mechanisms. Through this clustering technique, it&rsquo;s not uncommon to discover similar samples that lack such hardening‚Äîoften representing earlier development versions or variants from the same author. These less protected samples frequently show similarities to your target (detectable through YARA matches) and can provide valuable insights into the underlying functionality and TTPs, even when the primary sample is heavily obfuscated.</em></p>
<h3 id="iocs">IOCs</h3>
<ul>
<li>
<p>Potential Control Panel IPs:</p>
<ul>
<li>138.124.60[.]33</li>
<li>217.119.129[.]92</li>
<li>207.244.199[.]46</li>
<li>159.65.7[.]52</li>
</ul>
</li>
<li>
<p>Additonal Gremlin Stealer</p>
<table>
  <thead>
      <tr>
          <th>Gremlin Stealer - Sha256</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>d1ea7576611623c6a4ad1990ffed562e8981a3aa209717065eddc5be37a76132</td>
      </tr>
      <tr>
          <td>32d081039285eed1fb97dc814da1a97dac9d6efcf5827326067ca0ba2130de05</td>
      </tr>
      <tr>
          <td>971198ff86aeb42739ba9381923d0bc6f847a91553ec57ea6bae5becf80f8759</td>
      </tr>
      <tr>
          <td>598ba6b9bdb9dcc819e92c10d072ce93c464deaa0a136c4a097eb706ef60d527</td>
      </tr>
      <tr>
          <td>01dc8667fd315640abf59efaabb174ac48554163aa1a21778f85b31d4b65c849</td>
      </tr>
      <tr>
          <td>7458cb50adfcce50931665eae6bd9ce81324bc0b70693e550e861574cb0eb365</td>
      </tr>
      <tr>
          <td>208ecca5991d25cc80e4349ce16c9d5a467b10dedcb81c819b6bc28901833ea9</td>
      </tr>
      <tr>
          <td>7ed4eea56c2c96679447cc7dfc8c4918f4f7be2b7ba631bc468e8a180414825a</td>
      </tr>
      <tr>
          <td>8202ba2d361e6507335a65ccc250e01c2769ed22429e25d08d096cd46a6619ff</td>
      </tr>
      <tr>
          <td>281b970f281dbea3c0e8cfc68b2e9939b253e5d3de52265b454d8f0f578768a2</td>
      </tr>
      <tr>
          <td>a9f529a5cbc1f3ee80f785b22e0c472953e6cb226952218aecc7ab07ca328abd</td>
      </tr>
      <tr>
          <td>9aab30a3190301016c79f8a7f8edf45ec088ceecad39926cfcf3418145f3d614</td>
      </tr>
      <tr>
          <td>ab0fa760bd037a95c4dee431e649e0db860f7cdad6428895b9a399b6991bf3cd</td>
      </tr>
      <tr>
          <td>d11938f14499de03d6a02b5e158782afd903460576e9227e0a15d960a2e9c02c</td>
      </tr>
      <tr>
          <td>691896c7be87e47f3e9ae914d76caaf026aaad0a1034e9f396c2354245215dc3</td>
      </tr>
  </tbody>
</table>
</li>
</ul>
]]></content></item><item><title>Symbolic Execution for fun and Flare-On</title><link>https://Viuleeenz.github.io/posts/2024/12/symbolic-execution-for-fun-and-flare-on/</link><pubDate>Fri, 27 Dec 2024 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2024/12/symbolic-execution-for-fun-and-flare-on/</guid><description>&lt;p>Emulation is my passion. I apply it as much as I can in countless scenarios‚Äîsometimes for practical purposes, and sometimes just for fun. Recently, I‚Äôve been diving into &lt;strong>angr&lt;/strong>, and after weeks of banging my head against it, a few questions crossed my mind:&lt;/p>
&lt;p>Has anyone ever tried using angr for something meaningful, only to end up frustrated because nothing seemed to work? Or followed an angr tutorial based on CTF code, thinking, &lt;em>‚ÄúWow, this looks easy‚ÄîI‚Äôve got this!‚Äù&lt;/em>‚Äîonly to realize you‚Äôre in way over your head?&lt;/p></description><content type="html"><![CDATA[<p>Emulation is my passion. I apply it as much as I can in countless scenarios‚Äîsometimes for practical purposes, and sometimes just for fun. Recently, I‚Äôve been diving into <strong>angr</strong>, and after weeks of banging my head against it, a few questions crossed my mind:</p>
<p>Has anyone ever tried using angr for something meaningful, only to end up frustrated because nothing seemed to work? Or followed an angr tutorial based on CTF code, thinking, <em>‚ÄúWow, this looks easy‚ÄîI‚Äôve got this!‚Äù</em>‚Äîonly to realize you‚Äôre in way over your head?</p>
<p>Well, that‚Äôs exactly where I found myself. üòë</p>
<p>Nevertheless, I found quite interesting tutorial about symbolic execution and I really recommend the course on <a href="https://p.ost2.fyi/courses/course-v1:OpenSecurityTraining2&#43;RE3201_symexec&#43;2021_V1/about">OpenSecurityTraining2</a>. It‚Äôs a generic course but it also gives some really good basic of angr usage. Unfortunately, what is really missing on the web (or at least I didn‚Äôt find it) is something that goes over the basic.</p>
<p>Unfortunately, most of the tutorial covers the following scenario: ‚Äú<em>Take a binary, run it from the beginning, set few values for addresses to reach and avoid, get the result‚Äù.</em> Through this post I would like to go a little bit further from the basic and setup angr properly in order to handle a function within the binary, setting the requirements and evaluate the actual result. In my opinion this simulates a more real case scenario where you don‚Äôt really need or can‚Äôt execute the whole binary from scratch. For this post I am going to use the <strong>challenge #10</strong> of <strong>Flare-on 2024.</strong> However, instead of starting the challenge from scratch, it would be more beneficial for this tutorial to focus directly to the angr-related concepts and general requirements needed for it.</p>
<blockquote>
<p>üí° <em>I‚Äôd like to point out that I always strive to create content with immediate, real-world applicability. While this post might initially seem CTF-oriented, it‚Äôs not‚Äîthe challenge I‚Äôm discussing is particularly interesting because it closely resembles a ‚Äúransomware-like‚Äù binary. It involves file decryption and even a virtual machine interpreter, making it highly relevant beyond CTFs. Given the binary&rsquo;s complexity, it‚Äôs an excellent candidate for a test case. It‚Äôs also easy to obtain and far safer to experiment with than actual ransomware‚Äîperfect if you‚Äôd like to try it yourself.</em></p>
</blockquote>
<p><em><strong>Note</strong></em>: If you feel uncomfortable with this topic, please refer to the OpenSecurityTraining2 mentioned course.</p>
<h3 id="delights-and-pains-of-using-angr">Delights and Pains of using Angr.</h3>
<p>Angr is an entirely different beast compared to the emulators I‚Äôve covered on this blog. To be honest, <strong>angr</strong> is more like a full-featured framework for analyzing binaries through symbolic execution. The <a href="https://docs.angr.io/en/latest/">angr documentation</a> is well-structured and covers a wide range of topics in detail. However, fully grasping the documentation is no small feat‚Äîit‚Äôs far from easy.</p>
<p>I‚Äôve spoken with several people who stay away from using <strong>angr</strong> because of its steep learning curve, and I have to agree‚Äîit can be challenging to get started.</p>
<p>To use <strong>angr</strong> effectively, there are a few key concepts you absolutely need to understand. These requirements are not so different from the prerequisites discussed earlier on this blog for working with emulators. However, with <strong>angr</strong>, you also need to thoroughly understand <strong>what symbolic execution is and how it works.</strong></p>
<p>The most critical step, though, is setting up <strong>angr</strong> correctly‚Äîespecially when you need to focus on a specific piece of code rather than running the entire binary from the beginning.</p>
<p>Having an idea of angr components and capabilities we could simplify its usage in two main cases:</p>
<ol>
<li>You need to symbolically execute the <strong>binary from scratch</strong> in order to understand <em><strong>which input could lead to a specific output</strong></em>. (Basic usage)</li>
<li>You need to symbolically execute a <strong>function within the binary</strong> in order to understand the result of this function, <strong>setting up all the requirements</strong> (parameters) <strong>that are going to be used during the execution</strong>.</li>
</ol>
<p>When you run a binary with <strong>angr</strong>, you‚Äôll rely on these components to find a ‚Äúsolution‚Äù that meets your specific needs. This solution could take many forms‚Äîit might be identifying a bug in a program to report an error, or it could be something entirely different, such as uncovering a passphrase or a product key</p>
<blockquote>
<p>üí°¬†<em>Before diving into our example, you might wonder: ‚ÄúHow can I determine if this function, or my goal, is a good fit for angr?‚Äù This is a great question, but unfortunately, it doesn‚Äôt have a straightforward answer. Generally speaking, you can use <strong>angr</strong> whenever you‚Äôre faced with a question like: ‚ÄúWhat input would produce this specific output?‚Äù While this isn‚Äôt a complete guideline, I‚Äôve found that this question often arises when I encounter problems well-suited for an <strong>angr-like</strong> solution. That said, you also need to carefully consider the function or binary you plan to analyze. Since emulation is inherently slow, working with <strong>angr</strong> can lead to exponentially increasing complexity and execution time, depending on the task.</em></p>
<p><em>My recommendation is to use <strong>angr</strong> for well-defined, specific tasks that align with the question above, rather than attempting to run it against the entire binary.</em></p>
</blockquote>
<h3 id="c4tbert--vs-angr">C4tbert  Vs. Angr</h3>
<p>C4tbert is one of the most enjoyable challenges I‚Äôve had the chance to tackle recently. It covers a variety of fascinating topics, including UEFI, cryptography, and virtual machines. In short, the goal is to find the correct passwords that will eventually decrypt files containing parts of the flag.</p>
<p><img src="/img/symbolic_exe/decrypt_file.png" alt="Figure 1: Catbert Ransomware - attempt to decrypt file with random password"></p>
<p>Figure 1: Catbert Ransomware - attempt to decrypt file with random password</p>
<p>Does this sound familiar? It aligns perfectly with the question we discussed earlier: <em>‚ÄúWhat input would produce this output?‚Äù</em> To answer this question using <strong>angr</strong>, we first need to explore the code, develop a high-level understanding of the input and output parameters, and define all the necessary requirements.</p>
<p>Let‚Äôs start reversing a bit the interesting part of the binary avoiding to look closer on the challenge itself, but let‚Äôs try to focus on angr requirements.</p>
<p><img src="/img/symbolic_exe/code_overview.png" alt="Figure 2: Decryption overview for angr requitements "></p>
<p>Figure 2: Decryption overview for angr requitements</p>
<blockquote>
<p>üí°¬†<em>To make it easier to follow, I have renamed most of the code. So it will be also possible to use line number as a reference.</em></p>
</blockquote>
<p>Looking at <strong>Figure 2</strong>, we can see that at <strong>line 170</strong>, the <strong>password</strong> is checked to ensure it is <strong>16 characters long</strong>. Before this, a <strong>bytecode</strong> is retrieved from a file (<strong>line 163</strong>) and later manipulated slightly (<strong>lines 180‚Äì194</strong>) by substituting some of its characters with values derived from our input key. Finally, the bytecode is passed to a <strong>virtual_machine_interpreter</strong> for processing. Based on these observations, we can start taking notes of the requirements we‚Äôve uncovered so far and translate them into practical actions we need to perform with <strong>angr</strong>:</p>
<ul>
<li><strong>Bytecode</strong>: We need to allocate memory to hold the bytecode, which can be easily retrieved from the <code>.c4tb</code> file.</li>
<li><strong>Password</strong>: This is the answer to our problem. We need to find a 16-character input that can successfully decrypt the file.</li>
</ul>
<p>Additionally, we must keep in mind that the <strong>password is mixed into the bytecode</strong> during its processing by the <strong>bytecode interpreter</strong> function. With a more clear understanding of those points, we can now move on to exploring the virtual machine code, which represents the part of the program we will execute</p>
<p><img src="/img/symbolic_exe/vm_code.png" alt="Figure 3: Requirements for virtual_machine_interpreter function."></p>
<p>Figure 3: Requirements for virtual_machine_interpreter function.</p>
<p>To determine the function&rsquo;s requirements, we need to start our exploration from the very beginning. As we can see, the function involves a <strong>bytecode</strong> (which we‚Äôve already noted), a <strong>status</strong> (representing the exit condition, as referenced in Figure 3), and a <strong>stack</strong>.</p>
<blockquote>
<p>üí°<em>To keep things simple, I‚Äôve referred to the additional memory needed in the function as a <strong>stack</strong>. You might ask, ‚ÄúHow am I supposed to know that a stack is needed without analyzing the function?‚Äù Well, a stack is essentially just a block of memory. It‚Äôs called a <strong>stack</strong> because it‚Äôs typically accessed via a register pointing to it, but in general, we could call it anything we like. It‚Äôs important to note that I made this simplification to make the overall structure easier to understand. If you‚Äôre interested in reversing the code in detail, you‚Äôll eventually discover that the virtual machine interpreter performs various operations on the stack, such as <strong>push</strong>, <strong>pop</strong>, <strong>rotate</strong>, and more.</em></p>
</blockquote>
<p>To effectively use <strong>angr</strong>, especially in our case, it‚Äôs crucial to identify the correct address to begin execution. Fortunately, this is straightforward in this scenario, as it corresponds to the very first instruction of the <strong>virtual_machine_interpreter</strong> (<strong>line 16</strong>).</p>
<p>Another important aspect to consider when running an <strong>angr</strong> script are the <strong>find</strong> and <strong>avoid</strong> addresses. These special addresses represent success and failure conditions, respectively. However, instead of just specifying a simple address, you can also define a function to check the <strong>status</strong> variable in order to determine its value and any potential success condition. Looking at the code, we can easily see that if <strong>status</strong> equals 0, the program will follow the invalid key branch.</p>
<p>Now that we have a general understanding of the code, we can begin writing our <strong>angr</strong> script.</p>
<h3 id="writing-angr-script">Writing angr script</h3>
<p>Let‚Äôs start writing down the requirements that we have discovered.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#bytecode</span>
</span></span><span style="display:flex;"><span>data <span style="color:#f92672">=</span> list<span style="color:#f92672">(</span>f.read<span style="color:#f92672">(</span>size<span style="color:#f92672">))</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#key</span>
</span></span><span style="display:flex;"><span>key <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>claripy.BVS<span style="color:#f92672">(</span>f<span style="color:#e6db74">&#39;k{i}&#39;</span>, 8<span style="color:#f92672">)</span> <span style="color:#66d9ef">for</span> i in range<span style="color:#f92672">(</span>16<span style="color:#f92672">)]</span>¬†
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># mixing input key bytes within the bytecode</span>
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">[</span>5<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">[</span>4<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">[</span>12<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">[</span>11<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">[</span>3<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">[</span>19<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">[</span>4<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">[</span>18<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">[</span>5<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">[</span>26<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">[</span>6<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">[</span>25<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">[</span>7<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">[</span>33<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">[</span>8<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">[</span>32<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">[</span>9<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">[</span>40<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">[</span>10<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">[</span>39<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">[</span>11<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">[</span>47<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">[</span>12<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">[</span>46<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">[</span>13<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">[</span>54<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">[</span>14<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>data<span style="color:#f92672">[</span>53<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">[</span>15<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>The code above is fairly easy to understand. The <strong>data</strong> variable represents the bytes read from the <code>.c4tb</code> file, and the <strong>key</strong> is a <strong>bitvector</strong> that will hold our input.</p>
<blockquote>
<p>üí° <em>Angr‚Äôs solver engine, called Claripy, uses the syntax above to create a 16-byte array (or an array named ‚Äòkey‚Äô with each cell being 8 bits). This assignment tells angr that the key array is our symbolic variable, which needs to be &ldquo;concretized&rdquo; to guess the correct decryption key. The subsequent mixing step simply assigns our key to the bytecode, which will then be interpreted.</em></p>
</blockquote>
<p>Next, we need to define the parameters necessary for properly handling the operations related to the bytecode, the <strong>status</strong> variable, and the entry and return addresses of the function we intend to execute. With this information, we‚Äôll be ready to create the <strong>project</strong> and <strong>state</strong> variables for the calling function.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>RET_ADDR <span style="color:#f92672">=</span> <span style="color:#75715e"># Return address of virtual_machine_interpreter function.</span>
</span></span><span style="display:flex;"><span>STATUS_ADDR <span style="color:#f92672">=</span> <span style="color:#75715e"># Address of status variable</span>
</span></span><span style="display:flex;"><span>FUN_ENTRY_ADDR <span style="color:#f92672">=</span> <span style="color:#75715e"># Address of the first instruction of virtual_machine_interpreter</span>
</span></span><span style="display:flex;"><span>DATA_PTR_ADDR <span style="color:#f92672">=</span> <span style="color:#75715e"># Address that is storing the bytecode</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>proj <span style="color:#f92672">=</span> angr.Project<span style="color:#f92672">(</span><span style="color:#e6db74">&#39;0.efi&#39;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>state <span style="color:#f92672">=</span> proj.factory.call_state<span style="color:#f92672">(</span>FUN_ENTRY_ADDR<span style="color:#f92672">)</span>
</span></span></code></pre></div><blockquote>
<p>üí° <em>As you can see, I‚Äôve omitted the exact values for the addresses. This is because they depend on angr and where it loads the binary. Using specific addresses would be pointless for this tutorial, but for now, you can assume them to be correct. I‚Äôll explain how to properly set them at the end of this section.</em></p>
</blockquote>
<p>Now that everything should be clear so far, it‚Äôs time to tighten your seatbelt because we‚Äôre about to dive a bit deeper.</p>
<p>Up to this point, most of the requirements have been correctly defined. However, before moving forward, we need to allocate memory for our <strong>data</strong>. Keep in mind that the <strong>data</strong> variable <strong>contains the data extracted from the <code>.c4tb</code> file</strong>, but we haven‚Äôt assigned it to <strong>angr‚Äôs</strong> memory yet. Additionally, this assignment must be done correctly, matching the appropriate variable type.</p>
<p>Looking more closely at the bytecode and <strong>key</strong> assignment, we can see that we‚Äôre using the lower byte of the <strong>RAX</strong> register (specifically <strong>AL</strong>) each time. This means we need exactly <strong>8 bits</strong> for each key value.</p>
<p><img src="/img/symbolic_exe/bytecode.png" alt="Figure 4: Shuffle bytecode and key chars"></p>
<p>Figure 4: Shuffle bytecode and key chars</p>
<p>Armed with this knowledge, it is possible to allocate and assign angr memory accordingly.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>data_sec <span style="color:#f92672">=</span> state.heap.allocate<span style="color:#f92672">(</span>size<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i in range<span style="color:#f92672">(</span>size<span style="color:#f92672">)</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Each data of the bytecode is 1 byte long. </span>
</span></span><span style="display:flex;"><span>  state.mem<span style="color:#f92672">[</span>data_sec + i<span style="color:#f92672">]</span>.uint8_t <span style="color:#f92672">=</span> data<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># For memory on 64bit architecture we need to use the right address size.</span>
</span></span><span style="display:flex;"><span>state.mem<span style="color:#f92672">[</span>DATA_PTR_ADDR<span style="color:#f92672">]</span>.uint64_t <span style="color:#f92672">=</span> data_sec
</span></span></code></pre></div><p>At this point, there isn‚Äôt much left to do. We can now initialize the simulation manager and define our <strong>find</strong> and <strong>avoid</strong> parameters.</p>
<p>As mentioned earlier, we can use a function for our <strong>find</strong> parameter. In this case, this function will allow us to explore the value of the <strong>status</strong> variable, which will act as a switch to indicate whether we&rsquo;ve provided the correct password.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>simgr <span style="color:#f92672">=</span> proj<span style="color:#f92672">.</span>factory<span style="color:#f92672">.</span>simulation_manager(state)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#if I&#39;m reaching the end of the function I need to check the status variable.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">found</span>(state):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> state<span style="color:#f92672">.</span>addr <span style="color:#f92672">==</span> RET_ADDR:
</span></span><span style="display:flex;"><span>    status <span style="color:#f92672">=</span> state<span style="color:#f92672">.</span>memory<span style="color:#f92672">.</span>load(STATUS_ADDR, <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># add a constraints to force status to be != from 0</span>
</span></span><span style="display:flex;"><span>    state<span style="color:#f92672">.</span>add_constraints(status <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># return a simple true or false, depending on status.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> state<span style="color:#f92672">.</span>solver<span style="color:#f92672">.</span>satisfiable()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># define a found function that is going to check the status variable</span>
</span></span><span style="display:flex;"><span>simgr<span style="color:#f92672">.</span>explore(find<span style="color:#f92672">=</span>found)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># There is only a single solution.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">assert</span> len(simgr<span style="color:#f92672">.</span>found) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>state <span style="color:#f92672">=</span> simgr<span style="color:#f92672">.</span>found[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>print(bytes((state<span style="color:#f92672">.</span>solver<span style="color:#f92672">.</span>eval(k) <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> key)))
</span></span></code></pre></div><h3 id="script-testing">Script Testing</h3>
<p>Now that everything is properly set up, we can run our script and expect to receive the results within a reasonable timeframe. It shouldn‚Äôt take long‚Äîtypically around 3 to 5 minutes, depending on your VM.</p>
<p><img src="/img/symbolic_exe/testing_script.png" alt="Figure 5: Testing angr script for catmeme1.jpg"></p>
<p>Figure 5: Testing angr script for catmeme1.jpg</p>
<blockquote>
<p>üí°<em>I have automatically generated a few comments throughout the code to improve readability. Additionally, it&rsquo;s worth noting that running the script for the third file requires some extra adjustments. However, the technical details of this specific case won&rsquo;t be covered, as it relies on a challenge-specific scenario</em></p>
</blockquote>
<h3 id="setting-up-the-reference-addresses-properly">Setting up the reference addresses properly</h3>
<p>How do we set <strong>RET_ADDR</strong>, <strong>STATUS_ADDR</strong>, <strong>FUN_ENTRY_ADDR</strong>, and <strong>DATA_PTR_ADDR</strong>? When executing code, it&rsquo;s crucial to align the addresses from the program with those in your disassembler or debugger if you want to track the program&rsquo;s flow accurately. In this case, <strong>angr</strong> loads the program into specific memory addresses. To set these variables correctly, you can retrieve the addresses used by <strong>angr</strong> and rebase the binary in <strong>IDA</strong> accordingly. After initializing the project, you can print the base address used by <strong>angr</strong> to get this information.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>base_addr <span style="color:#f92672">=</span> proj<span style="color:#f92672">.</span>loader<span style="color:#f92672">.</span>min_addr 
</span></span><span style="display:flex;"><span>print(hex(base_addr))
</span></span></code></pre></div><p>This is instruction actually prints the base address used by angr to load the binary. Matching this address in IDA will make all operation about addresses way more easier.</p>
<p><img src="/img/symbolic_exe/rebase_program.png" alt="Figure 5: Rebase program with IDA"></p>
<p>Figure 5: Rebase program with IDA</p>
<h3 id="conclusion">Conclusion</h3>
<p>Through this post, I‚Äôve ‚Äúclosed the circle‚Äù (or at least tried) on emulation and symbolic execution, demonstrating how these techniques can be used to analyze real-world malware. While there are still unexplored topic (e.g., Qiling), I haven‚Äôt delved into it deeply. Despite being a potentially powerful tool, Qiling‚Äôs documentation isn‚Äôt well-maintained, and utilizing it might require significant effort. Nevertheless, I hope you‚Äôve enjoyed reading all the posts and had as much fun exploring them as I did while explaining and experimenting with these topics.</p>
<p>Recently, I‚Äôve received a few messages asking why I stopped publishing on the blog. The truth is, most of my recent research has focused on very specific topics that might not appeal to a broad audience. Writing blog posts for such a niche can sometimes feel less beneficial for a general readership. So, what does the future hold?</p>
<p>I don‚Äôt want to stop publishing entirely, even though I‚Äôve been a bit inconsistent lately. However, I‚Äôm still figuring out which topics could be interesting to explore in the coming months. I enjoy exploring new ideas and conducting independent research on malware analysis and classification. I usually try to align this blog with my research, both to clarify my own thoughts and to provide useful content for a wider audience.</p>
<p>At the moment, I have a few large projects under development that are keeping me quite busy. Still, I‚Äôm considering posting research-oriented content related to malware classification, possibly adopting a more formal, paper-oriented format (which I‚Äôd include in the whitepapers section). As for the future, it remains uncertain. As the saying goes, <em>‚ÄúThe best way to predict the future is to create it.‚Äù</em> I‚Äôll continue exploring, experimenting, and sharing whenever inspiration strikes or a project feels worth sharing.</p>
<p>Thank you for reading, and as always, keep reversing and have fun!</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://services.google.com/fh/files/misc/flare-on11-challenge10-catbert-ransomware.pdf">Flare-on Challenge</a></li>
<li><a href="https://p.ost2.fyi/courses/course-v1:OpenSecurityTraining2&#43;RE3201_symexec&#43;2021_V1/about">SymbolicExecution training</a></li>
<li><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/SymbolicExecution/catbert_ransomware.py">Catbert Ransomware solver</a></li>
</ul>
]]></content></item><item><title>Emulating inline decryption for triaging C++ malware</title><link>https://Viuleeenz.github.io/posts/2024/05/emulating-inline-decryption-for-triaging-c-malware/</link><pubDate>Thu, 16 May 2024 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2024/05/emulating-inline-decryption-for-triaging-c-malware/</guid><description>&lt;h2 id="what-we-need-to-know">What we need to know?&lt;/h2>
&lt;p>C and C++ binaries share several commonalities, however, some additional features and complexities introduced by C++ can make reverse engineering C++ binaries more challenging compared to C binaries. Some of the most important features are:&lt;/p>
&lt;p>&lt;strong>Name Mangling&lt;/strong>: C++ compilers often use name mangling to encode additional information about functions and classes into the symbol names in the binary. This can make it more challenging to understand the code&amp;rsquo;s structure and functionality by simply looking at symbol names.&lt;/p></description><content type="html"><![CDATA[<h2 id="what-we-need-to-know">What we need to know?</h2>
<p>C and C++ binaries share several commonalities, however, some additional features and complexities introduced by C++ can make reverse engineering C++ binaries more challenging compared to C binaries. Some of the most important features are:</p>
<p><strong>Name Mangling</strong>: C++ compilers often use name mangling to encode additional information about functions and classes into the symbol names in the binary. This can make it more challenging to understand the code&rsquo;s structure and functionality by simply looking at symbol names.</p>
<p><strong>Object-Oriented Features</strong>: C++ supports object-oriented programming (OOP) features such as classes, inheritance, polymorphism, and virtual functions. Reverse engineering C++ binaries may involve identifying and understanding these constructs, which may not exist in C binaries.</p>
<p><strong>Templates</strong>: C++ templates allow for generic programming, where functions and classes can operate on different data types. Reverse engineering C++ templates can be complex due to the generation of multiple versions of the same function or class template with different types.</p>
<p>Another topic that is <strong>mandatory to understand</strong> when we approach binaries is related to the <strong>calling convention.</strong> Even if it&rsquo;s determined by the operating system and the compiler ABI (Application Binary Interface) rather than the specific programming language being used, its one of the fundamental aspects that too many times is overlooked.</p>
<blockquote>
<p>üí°There are many other differences related to <strong>Runtime Type Information (RTTI)</strong>, <em><em>Constructor and Destructor Calls,</em> Exception Handling and <strong>Compiler-Specific Features</strong>. Those topics aren‚Äôt less important than the others mentioned above, however, explaining a basic triage does not involve those topics and giving an explanation for all of them could just lose the focus. Moreover,</em> If you don‚Äôt feel comfortable with <strong>calling conventions</strong>, refer to exceptional material on <a href="https://www.youtube.com/watch?v=9lzW0I9_cpY">OALabs</a>.</p>
</blockquote>
<h2 id="why-glorysprout">Why GlorySprout?</h2>
<p>I know, probably this name for most of you does not mean anything because it does not represent one the most prominent threats on Cyberspace, however, didactically speaking, it has a lot of characteristics that make it a great fit. First of all it‚Äôs a recent malware and because of this, it shares most of the capabilities employed by more famous ones such as: <strong>obfuscation</strong>, <strong>api hashing</strong>, <strong>inline decryption</strong> etc.. Those characteristics are quite challenging to deal with, especially if we go against them to build an automation script that is going to replicate our work on multiple samples.</p>
<p>Another interesting characteristic of this malware is that it represents a fork of another malware called Taurus Stealer as reported by RussianPanda in her article. So, why is it important? Taurus Stealers have been dissected and a detailed report is available here. From a learning stand point it represents a plus, since if you are stuck somewhere in the code, you have a way out trying to match this GlorySprout capabilities with Taurus.</p>
<p>Let‚Äôs start our triage.</p>
<h2 id="binary-overview">Binary Overview</h2>
<p>Opening up the binary in IDA and scrolling a little bit from the main functions it should be clear that this binary is going to use some api hashing for retrieving DLLs, inline decryption and C++ structures to store some interesting value. To sum up, this binary is going to start resolving structures and APIs, perform inline decryption to start checking Windows information and installed softwares. However, those actions are not intended to be taken without caution. In fact, each time a string is decrypted, its memory region is then immediately zeroed after use. It means that a ‚Äú<em>quick and dirty</em>‚Äù approach using dynamic analysis to inspect memory sections won‚Äôt give you insights about strings and/or targets.</p>
<p><img src="/img/glory_sprout/binary_overview.png" alt="Figure 1: Binary Overview"></p>
<p>Figure 1: Binary Overview</p>
<h3 id="identifying-and-creating-structures">Identifying and Creating Structures</h3>
<p>Identifying and creating structures is one of the most important tasks when we deal with C++ malware. Structures are mostly reused through all code, because of that, having a good understanding of structures is mandatory for an accurate analysis. In fact, applying structures properly will make the whole reversing process way more easier.</p>
<p>Now you may be wondering, how do we recognise a structure? In order to recognise structures it‚Äôs important to observe <strong>how a function is called</strong> and <strong>how input parameters are actually used</strong>.</p>
<p>In order to explain it properly, let‚Äôs take an example from GlorySprout.</p>
<p><img src="/img/glory_sprout/passing_structure.png" alt="Figure 2: Passing structure parameter"></p>
<p>Figure 2: Passing structure parameter</p>
<p>Starting from left to right, we see some functions callings that could help us to understand that we are dealing with a structure. Moreover, its also clear in this case, <strong>how big the structures is</strong>.</p>
<blockquote>
<p>üí°<em>As said before, <strong>calling convention is important</strong> to understand how parameters are passed to a function. In this case, we are dealing with is a clear example of <strong>thiscall</strong>.</em></p>
</blockquote>
<p>Let‚Äôs have a look at the function layout. Even if we are seeing that <strong>ecx</strong> is going to be used as a parameter for three functions, it is actually used each time with a different offset (this is a good indication that we are dealing with a structure). Moreover, if we have a look at the first call (<code>sub_401DEB</code>), this function seems to fill the first <strong>0xF4</strong> (244 in decimal) bytes pointed by <strong>ecx</strong> with some values. Once the function ends, there is the instruction <strong>lea ecx, [esi+0F8h]</strong> and another function call. This pattern is used a couple of times and confirms our hypothesis that each function is in charge to fill some offset of the structure.</p>
<p>From the knowledge we have got so far and looking at the code, we could also infer the structure passed to the third call (<code>sub_406FF1</code>) and the whole size of the structure.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>sub_406FF1_bytes_to_fill = 0xF8 - 0x12C = 0x34 (<span style="color:#ae81ff">52</span> bytes)  
</span></span><span style="display:flex;"><span>structure_size = 0xF8 + 0x34 = 0x12C (<span style="color:#ae81ff">300</span> bytes) + <span style="color:#ae81ff">4</span> bytes realted to the size of the last value.
</span></span></code></pre></div><p>However, even if we resolved the size structures and understood where it is used, there is still a point missing. <strong>Where does this structure come from?</strong> To answer this question, it‚Äôs important to take a step back. Looking at the function<code>sub_40100A</code> we see the instruction [<strong>mov ecx , offset unk_4463F8</strong>]. If you explore that variable you will see that it is stored at <code>0x004463F8</code> and the  next variable is stored at <code>0x0044652F</code>. If we do a subtraction through these two addresses, we have <strong>312</strong> bytes. There are two important things to highlight here. First of all, we are dealing with  a <strong>global structure</strong> that is going to be used multiple times in different code sections (because of that, naming structure fields will be our first task), however, according to the size calculated, it seems that we are missing a few bytes. This could be a good indication that additional bytes will be used later on in the code to store an additional value. In fact, this insight is confirmed if we analyze the last function (<code>sub_40B838</code>). Opening up the function and skipping the prolog instructions, we could immediately see that the structure is moved in <code>esi</code>, and then a <strong>dword</strong> is moved to <strong>esi+4</strong>. It means that <strong>esi</strong> is adding <strong>4 bytes</strong> to the structure that means that now the structure size is <strong>308 bytes</strong>.</p>
<p><img src="/img/glory_sprout/structure_size.png" alt="Figure 3: Understanding structure size"></p>
<p>Figure 3: Understanding structure size</p>
<p>Now that we have a better understanding of the structure&rsquo;s size, it&rsquo;s time to understand its values. In order to figure out what hex values represent, we need to go a little bit deeper exploring the function. Going over a <strong>decryption routine</strong>, there is a call towards <code>sub_404CC1</code>. If we follow this call, we should immediately recognize a familiar structure (if not, have a look at <a href="https://viuleeenz.github.io/posts/2024/02/understanding-peb-and-ldr-structures-using-ida-and-lummastealer/">this article</a>). We are dealing with a routine that is going to resolve some APIs through the hex value passed to the function.</p>
<p><img src="/img/glory_sprout/load_dlls.png" alt="Figure 4: PEB and LDR data to collect loaded DLLs"></p>
<p>Figure 4: PEB and LDR data to collect loaded DLLs</p>
<p>Well, so far we have all the elements required to solve our puzzle! <strong>The structure we are dealing with is 312 bytes long</strong> and <strong>contains hex values related to APIs</strong>. Doing an educated guess, these values will be used and resolved on the fly, when a specific API function is required (structure file will be shared in the Reference section).</p>
<blockquote>
<p>üí°<em>As part of the triage process, structures are usually the very first block of the puzzle to solve. In this case, we have seen a global structure that is stored within the data section. Exploring the data section a little bit deeper, you will find that structures from this sample are stored one after another. This could be a very good starting point to resolve structures values and hashes that could highlight the binary capabilities.</em></p>
</blockquote>
<h3 id="resolving-api-hash">Resolving API Hash</h3>
<p>If we recall Figure 3, we see multiple assignment instructions related to <strong>esi</strong> that contain our structure. Then in Figure 4 we discovered that API hashing routine is applied to some hex to get a reference to the corresponding function. The routine itself is quite easy and standard, at least in terms of retrieving the function name from the DLL (a detailed analysis has been done <a href="https://viuleeenz.github.io/posts/2024/03/understanding-api-hashing-and-build-a-rainbow-table-for-lummastealer/">here</a>).</p>
<p><img src="/img/glory_sprout/api_hashing.png" alt="Figure 5: API hashing routine"></p>
<p>Figure 5: API hashing routine</p>
<p>The Figure above, represents the routine applied to each function name in order to find a match with the hash passed as input. It should be easy to spot that <strong>esi</strong> contains (on each iteration) a string character that will be manipulated to produce the corresponding hash.</p>
<blockquote>
<p>üí°<em>The routine itself does not require a lot of explanation and it&rsquo;s pretty easy to reconstruct. In order to avoid any spoilers, if a reader wants to take this exercise, my code will be shared within the Reference section. It‚Äôs worth mentioning that this function could be implemented also through emulation, even if code preparation is a bit annoying compared to the function complexity, it could be a good exercise too.</em></p>
</blockquote>
<h3 id="inline-decryption">Inline Decryption</h3>
<p>So far we have done good work reconstructing structure layout and resolving API. That information gave us few insights about malware capabilities and in general, what could be the actions taken by this malware to perform its tasks. Unfortunately, we have just scratched the surface. In fact we are still missing information about malware configuration, such as: targets, C2, anti-debug, etc.. In fact, most of the interesting strings are actually decrypted with an inline routine.</p>
<blockquote>
<p>üí°<em>For anyone of you that actually tried to analyze this malware, you should already familiar with inline decryption routine, since that it spread all around the code.</em></p>
</blockquote>
<p><strong>Inline decryption</strong> is a quite interesting technique that really <strong>slows down malware analysis</strong> because it requires decryption of multiple strings, usually with slight differences, on the fly. Those routines are all over the code and most of the malware actions involve their usage. An example has been already observed in Figure 4 and 5. However, in order to understand what we are talking about, The figure below show some routines related to this technique: ¬†</p>
<p><img src="/img/glory_sprout/inline_decryption.png" alt="Figure 6: Inline Decryption"></p>
<p>Figure 6: Inline Decryption</p>
<p>As you can see, all those routines are quite different, involving each time a different operand and sometimes, the whole string is built on multiple parts of the code. According to the information collected so far, about inline decryption, it should be clear that creating a script for each routine will take forever. Does it end our triage? Likely, we still have our secret weapon called <strong>emulation</strong>.</p>
<p>The idea to solve this challenge is quite simple and effective, but it requires a little bit of experience: Collect all strings and their decryption routine in order to properly emulate each snippet of code.</p>
<h3 id="automation">Automation</h3>
<p>Automating all the <strong>inline</strong> <strong>encryption</strong> and the hashing routine it‚Äôs not an easy task. First of all, we need to apply the evergreen approach of ‚Äúdividi et impera‚Äù.In this way, the hashing routine have been partially solved using the template from a previous <a href="https://viuleeenz.github.io/posts/2024/03/understanding-api-hashing-and-build-a-rainbow-table-for-lummastealer/">post</a>. In this way, it‚Äôs just a matter of rewriting the function and we are going to have all the corresponding matches.</p>
<p><img src="/img/glory_sprout/resolved_hashes.png" alt="Figure 7: advapi32.dll resolved hashes"></p>
<p>Figure 7: advapi32.dll resolved hashes</p>
<p>However, what is really interesting in this sample is related to the string decryption. The idea is quite simple but very effective. First of all, in order to emulate this code, we need to identify some structures that we could use as <strong>anchor</strong> that is going to indicate that the decryption routine ended. <strong>Then we need to jump back to the very first instruction that starts creating the stack string</strong>. Well, it is easier said than done, because jumping back in the middle of an instruction and then going forward to the anchor value would lead us to an unpredictable result. However, if we jump back, far enough from the stack string creation, we could traverse the instructions upside down, starting from the anchor value back to the stack string. Doing so won&rsquo;t lead to any issue, since all instructions are actually correct.</p>
<p><img src="/img/glory_sprout/decrypted_strings.png" alt="Figure 8: Resolved strings"></p>
<p>Figure 8: Resolved strings</p>
<h2 id="conclusion">Conclusion</h2>
<p>Through this post we have started to scratch the surface of C++ binaries, understanding calling conventions and highlighting some features of those binaries (e.g, classes and calling conventions). However, going further would have been confusing, providing too much details on information that wouldn‚Äôt have an immediate practical counterpart. Nevertheless, what was quite interesting regardless of the api hashing routine emulation, was the inline decryption routine, introducing the <strong>idea of anchors and solving the issue of jumping back from an instruction</strong>.</p>
<h3 id="references">References</h3>
<p>Glory Sprout string decryptor:</p>
<ul>
<li><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/GlorySprout/gsprout_string_decryption.py">gsprout_string_decryption.py</a></li>
</ul>
<p>Glory Sprout Hash resolver:</p>
<ul>
<li><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/GlorySprout/gsprout_api_resolver.py">gsprout_api_resolver.py</a></li>
</ul>
<p>GlorySprout sample:</p>
<ul>
<li><a href="https://bazaar.abuse.ch/browse.php?search=sha256%3A8996c252fc41b7ec0ec73ce814e84136be6efef898822146c25af2330f4fd04a">Malwarebazaar</a></li>
</ul>
<p>Insight from GlorySprout and Taurus Stelaer:</p>
<ul>
<li><a href="https://russianpanda.com/2024/03/16/The-GlorySprout-Stealer-or-a-Failed-Clone-of-Taurus-Stealer/">RussianPanda Research Blog</a></li>
<li><a href="https://fumik0.com/2019/12/25/lets-play-again-with-predator-the-thief/">Let‚Äôs play (again) with Predator the thief</a></li>
<li><a href="https://outpost24.com/blog/an-in-depth-analysis-of-the-new-taurus-stealer/">An In-Depth analysis of the new Taurus Stealer</a></li>
</ul>
]]></content></item><item><title>Understanding API Hashing and build a rainbow table for LummaStealer</title><link>https://Viuleeenz.github.io/posts/2024/03/understanding-api-hashing-and-build-a-rainbow-table-for-lummastealer/</link><pubDate>Sun, 24 Mar 2024 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2024/03/understanding-api-hashing-and-build-a-rainbow-table-for-lummastealer/</guid><description>&lt;p>Understanding PEB and Ldr structures represents a starting point when we are dealing with API hashing. However, before proceeding to analyze a sample it‚Äôs always necessary to recover obfuscated, encrypted or hashed data. Because of that, through this blogpost I would like to continue what I have started in the &lt;a href="https://viuleeenz.github.io/posts/2024/02/understanding-peb-and-ldr-structures-using-ida-and-lummastealer/">previous post&lt;/a>, using emulation to create a rainbow table for LummaStealer and then write a little resolver script that is going to use the information extracted to resolve all hashes.&lt;/p></description><content type="html"><![CDATA[<p>Understanding PEB and Ldr structures represents a starting point when we are dealing with API hashing. However, before proceeding to analyze a sample it‚Äôs always necessary to recover  obfuscated, encrypted or hashed data. Because of that, through this blogpost I would like to continue what I have started in the <a href="https://viuleeenz.github.io/posts/2024/02/understanding-peb-and-ldr-structures-using-ida-and-lummastealer/">previous post</a>, using emulation to create a rainbow table for LummaStealer and then write a little resolver script that is going to use the information extracted to resolve all hashes.</p>
<blockquote>
<p>üí°<em>It‚Äôs worth mentioning that I‚Äôm trying to create self-contained posts. Of course, previous information will give a more comprehensive understanding of the whole process, however, the goal for this post is to have a guide that could be applied overtime even on different samples not related to LummaStealer.</em></p>
</blockquote>
<h2 id="resolving-hashes">Resolving Hashes</h2>
<p>Starting from where we left in the last post, we could explore the function routine that is in charge of <strong>collecting function names from a DLL and then perform a hashing algorithm</strong> to find a match with the input name.</p>
<p><img src="/img/api_hashing/api_hashing_overview.png" alt="Figure 1: LummaStealer API Hashing overview"></p>
<p>Figure 1: LummaStealer API Hashing overview</p>
<p>At the first glance, this function could be disorienting, however, understanding that <strong>ecx</strong> contains the module <strong>BaseAddress</strong> (explained in the previous article) it is possible to set a comment that is going to make the whole function easier to understand. Moreover, it has been also divided in three main parts( first two are going to be detailed in the next sections):</p>
<ol>
<li>Collecting exported function within a PE file;</li>
<li>Hashing routine;</li>
<li>Compare hashing result until a match is found, otherwise return 0; (<em>skipped because of a simple comparing routine</em>)</li>
</ol>
<h3 id="collecting-exported-function-within-a-pe-file">Collecting exported function within a PE file</h3>
<p>The first box starts with the instruction <strong>mov edi, ecx</strong> where <strong>ecx</strong> is a <em>BaseAddress</em> of a module that is going to be analyzed. This is a fundamental instruction that gives us a chance to infere the subsequent value of <strong>edi</strong> and <strong>ebx</strong>. In fact, if we rename values associated to these registers, it should be clear that this code is going to collect exported functions names through <strong>AddressOfNames</strong> and <strong>AddressOfNameOrdinals</strong> pointers.</p>
<p><img src="/img/api_hashing/resolving_structures_names.png" alt="Figure 2: Resolving structures names"></p>
<p>Figure 2: Resolving structures names</p>
<p>Those structures are very important in order to understand what is happening in the code. For now, you could think about those structures as <em>support structures</em> that could be chained together in order to collect the actual function pointer (after a match is found!)  within the <strong>Address of a Function structure</strong>.</p>
<blockquote>
<p>üí° <em>At the end of this article I created a dedicated sections to explain those structures and their connections.</em></p>
</blockquote>
<p>Another step that could misleading is related  to the following instruction:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> ebx,[eax<span style="color:#f92672">+</span>edi<span style="color:#f92672">+</span>IMAGE_NT_HEADERS.OptionaHeader.DataDirectory.VirtualAddress]
</span></span></code></pre></div><p>where <strong>ebx</strong> becomes a pointer for <strong>IMAGE_EXPORT_DIRECTORY</strong>.</p>
<p>In order to explain this instruction its useful to have a look at <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32">IMAGE_OPTIONAL_HEADERS</a> documentation, where Microsoft states that <strong>DataDirectory</strong> is pointer to a dedicated structure called <a href="https://learn.microsoft.com/en-us/windows/desktop/api/winnt/ns-winnt-image_data_directory">IMAGE_DATA_DIRECTORY</a> that could be addressed through a <strong>number</strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span> <span style="color:#a6e22e">typedef</span> struct _IMAGE_OPTIONAL_HEADER <span style="color:#960050;background-color:#1e0010">{</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">...</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">IMAGE_DATA_DIRECTORY</span> DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]<span style="color:#75715e">;</span>
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">}</span>
</span></span></code></pre></div><p>With that information let‚Äôs do some math unveiling the magic behind this assignment.</p>
<ul>
<li><strong>eax</strong> corresponds to the <strong>IMAGE_NT_HEADERS</strong> (because of its previous assignment)</li>
</ul>
<p>From there we have a <strong>0x78</strong> offset to sum. If we sum the first 18 bytes from <strong>eax</strong>, it‚Äôs possible to jump to the <strong>IMAGE_OPTIONAL_HEADER</strong>. Using the 60 bytes remaining to reach the next field within this structure, we could see that we are directly pointing to DataDirectory.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#a6e22e">typedef</span> struct <span style="color:#f92672">**</span>_IMAGE_NT_HEADERS<span style="color:#f92672">**</span> <span style="color:#960050;background-color:#1e0010">{</span>
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000</span> <span style="color:#66d9ef">DWORD</span>                   Signature<span style="color:#75715e">;</span>
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0004</span> IMAGE_FILE_HEADER       FileHeader<span style="color:#75715e">;</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">...</span>
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0018</span> IMAGE_OPTIONAL_HEADER32 OptionalHeader<span style="color:#75715e">;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">}</span> <span style="color:#a6e22e">IMAGE_NT_HEADERS32</span>, <span style="color:#f92672">*</span>PIMAGE_NT_HEADERS32<span style="color:#75715e">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">typedef</span> struct <span style="color:#f92672">**</span>_IMAGE_OPTIONAL_HEADER<span style="color:#f92672">**</span> <span style="color:#960050;background-color:#1e0010">{</span>
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0000</span> <span style="color:#66d9ef">WORD</span>                 Magic<span style="color:#75715e">;</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">...</span>
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x001C</span> <span style="color:#66d9ef">DWORD</span>                ImageBase<span style="color:#75715e">;</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">...</span>
</span></span><span style="display:flex;"><span> <span style="color:#960050;background-color:#1e0010">0</span><span style="color:#a6e22e">x0060</span> IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]<span style="color:#75715e">;</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">}</span> <span style="color:#a6e22e">IMAGE_OPTIONAL_HEADER32</span>, <span style="color:#f92672">*</span>PIMAGE_OPTIONAL_HEADER32<span style="color:#75715e">;</span>
</span></span></code></pre></div><p>From here, we don‚Äôt have additional bytes to sum, it means that we are pointing to the first structure pointed by DataDirectory, that is, according to the documentation the <strong>IMAGE_DIRECTORY_ENTRY_EXPORT</strong> also known as <strong>Export Directory</strong>.</p>
<blockquote>
<p>üí° <em>See Reference section to find out a more clear image about the whole PE structure</em></p>
</blockquote>
<h3 id="retrieve-the-function-pointer">Retrieve the function pointer</h3>
<p>Once the code in charge to collect and compare exported functions has been completed, and a match is found, it&rsquo;s time to retrieve the actual function pointer using some of the structures mentioned above. In fact, as you can see from the code related to the third box (that has been renamed accordingly), once the match if found, the structure <strong>AddressOfNameOrdinals</strong> it&rsquo;s used to retrieve the functions number that is going to address the structure <strong>AddressOfFunctions</strong> that contains the actual function pointers.</p>
<p><img src="/img/api_hashing/collect_api_pointer.png" alt="Figure 3: Collect the actual function pointer"></p>
<p>Figure 3: Collect the actual function pointer</p>
<blockquote>
<p>üí°<em>I don‚Äôt want to bother you with so much details at this point, since we have already analyzed throughly some structures and we still have additional contents to discuss. However, the image above has been thought to be self-contained. That said, to not get lost please remember that <strong>edi</strong> represents the <strong>Ldr_Module.BaseAddress</strong></em></p>
</blockquote>
<h3 id="analyze-the-hashing-routine">Analyze the hashing routine</h3>
<p>Through the information collected so far, this code should be childishly simple.</p>
<p><strong>ecx</strong> contains the hash name extracted from the export table that is going to forward as input to the hash function (identified, <em>in this case, as <a href="https://github.com/abrandoned/murmur2/blob/master/MurmurHash2.c">murmur2</a></em>). The function itself is quite long but does not take too much time to be understood and reimplemented. However, the purpose of this article is to emulate this code in order to find out the values of all hardcoded hashes.</p>
<p><img src="/img/api_hashing/murmur2_hashing_routine.png" alt="Figure 4: MurMur2 hashing routine">
Figure 4: MurMur2 hashing routine</p>
<p>As we have <a href="https://viuleeenz.github.io/posts/2023/12/applied-emulation-decrypting-ursnif-strings-with-unicorn/">already done</a>, we could select the function opcodes (without the return instruction) and put them in our code emulator routine. It‚Äôs worth mentioning that, <strong>ecx</strong> contains the function name that is going to be used as argument for hashing routine, because of that, it‚Äôs important to assign that register properly.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">MurMurHash2</span>(func_name):
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">=</span> bytes<span style="color:#f92672">.</span>fromhex(<span style="color:#e6db74">&#39;56 57 8B F9 8B D7 8D 4A 01 8A 02 42 84 C0 75 F9 2B D1 8B F2 83 F6 20 83 FA 04 7C 4D 53 8B DA C1 EB 02 6B C3 FC 03 D0 0F B6 4F 03 0F B6 47 02 C1 E1 08 0B C8 69 F6 95 E9 D1 5B 0F B6 47 01 C1 E1 08 0B C8 0F B6 07 C1 E1 08 83 C7 04 0B C8 69 C9 95 E9 D1 5B 8B C1 C1 E8 18 33 C1 69 C8 95 E9 D1 5B 33 F1 83 EB 01 75 BF 5B 83 EA 01 74 1C 83 EA 01 74 0E 83 EA 01 75 1D 0F B6 47 02 C1 E0 10 33 F0 0F B6 47 01 C1 E0 08 33 F0 0F B6 07 33 C6 69 F0 95 E9 D1 5B 8B C6 C1 E8 0D 33 C6 69 C8 95 E9 D1 5B 5F 5E 8B C1 C1 E8 0F 33 C1&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span> <span style="color:#75715e"># skip code </span>
</span></span><span style="display:flex;"><span>    uc<span style="color:#f92672">.</span>mem_write(data_base, func_name)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Set function argument</span>
</span></span><span style="display:flex;"><span>    uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_ECX, data_base)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span> <span style="color:#75715e"># skip code</span>
</span></span><span style="display:flex;"><span>    uc<span style="color:#f92672">.</span>emu_start(target_base, target_end, timeout<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, count<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">...</span> <span style="color:#75715e"># skip code</span>
</span></span><span style="display:flex;"><span>    EAX <span style="color:#f92672">=</span> uc<span style="color:#f92672">.</span>reg_read(UC_X86_REG_EAX)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EAX
</span></span></code></pre></div><p>Let‚Äôs take a test. Using the <strong>LoadLibraryW</strong> name, we get back <strong>0xab87776c</strong>. If we explore a little bit our code, we will find almost immediately this value! it is called each time a new hash needs to be resolved.</p>
<p><img src="/img/api_hashing/loadLibrary_hash.png" alt="Figure 5: LoadLibraryW Hash"></p>
<p>Figure 5: LoadLibraryW Hash</p>
<p>This behavior is a clear indication that before proceeding to extract exported functions, we need to load the associated library (DLL) in memory. With that information we could be sure that our emulator works fine.</p>
<h3 id="build-a-rainbow-table">Build a rainbow table</h3>
<p>Building a rainbow table can be done in a few lines of code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>filter <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;ntdll.dll&#39;</span>]
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_all_export_function_from_dlls</span>():
</span></span><span style="display:flex;"><span>    exported_func <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> dirpath, dirnames, filenames <span style="color:#f92672">in</span> os<span style="color:#f92672">.</span>walk(<span style="color:#e6db74">&#34;C:</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Windows</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">System32&#34;</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> filename <span style="color:#f92672">in</span> [f <span style="color:#66d9ef">for</span> f <span style="color:#f92672">in</span> filenames <span style="color:#66d9ef">if</span> f <span style="color:#f92672">in</span> filter]:
</span></span><span style="display:flex;"><span>            path_to_dll <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>join(dirpath, filename)
</span></span><span style="display:flex;"><span>            pe <span style="color:#f92672">=</span> pefile<span style="color:#f92672">.</span>PE(path_to_dll)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> export <span style="color:#f92672">in</span> pe<span style="color:#f92672">.</span>DIRECTORY_ENTRY_EXPORT<span style="color:#f92672">.</span>symbols:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> export<span style="color:#f92672">.</span>name:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>: 
</span></span><span style="display:flex;"><span>                    exported_func[hex(MurMurHash2(export<span style="color:#f92672">.</span>name))] <span style="color:#f92672">=</span> export<span style="color:#f92672">.</span>name
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> exported_func
</span></span></code></pre></div><p>The code presented above should be pretty clear, however, I would like to point out the role of the <em><strong>filter</strong></em> variable. Emulation brings a lot of advantages to reverse engineering, nevertheless, it also has a drawback related to performance. In fact, code that contains an emulation routine could be tremendously slow, and if you don‚Äôt pay attention it could take forever. Using a filter variable keeps our code more flexible, resolving tailored functions names without wasting time.</p>
<blockquote>
<p>üí°<em>Of course, in this case we could look for libraries names used within the code. However, we could not be so lucky in the future. Because of that, I prefer to show a way that could be used in multiple situations.</em></p>
</blockquote>
<h2 id="automation">Automation</h2>
<p>Now that we have built almost all fundamental components, it‚Äôs time to combine everything in a single and effective script file. What we are still missing is a regular expression that is going to look for hashes and forward them to the MurMur2 emulator.</p>
<p>Observing the code, an easy pattern to follow involves a register and an immediate values:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> REG, IMM
</span></span></code></pre></div><p>Implementing this strategy and filtering results only on <em>kernel32.dll,</em> we are able to extract all referenced hashes:</p>
<p><img src="/img/api_hashing/hashes_resolved.png" alt="Figure 6: Some hashes related to Kernel32.dll "></p>
<p>Figure 6: Some hashes related to Kernel32.dll</p>
<h2 id="conclusion">Conclusion</h2>
<p>As always, going deep in each section requires an entire course and at the moment it‚Äôs an impossible challenge. However, through this blog post I tried to scratch the surface giving some essential concepts (that could be applied straightaway) to make reversing time a lot more fun.</p>
<p>Another important thing to highlight here, is related to combine emulation and scripting techniques. Emulation is great, however, writing a script that contains some emulated routine could be a challenging task if we think about efficiency. Writing a single script for a single sample its not a big deal and it won‚Äôt have a great impact in a single analysis, however, doing it a scale is a different kettle of fish.</p>
<p>That said, it‚Äôs time to conclude, otherwise, even reading this post could be a challenging task! :)</p>
<p>Have fun and keep reversing!</p>
<h2 id="references">References:</h2>
<p>Windows PE file format:</p>
<ul>
<li><a href="https://raw.githubusercontent.com/corkami/pics/master/binary/pe102/pe102.svg">PE file overview</a></li>
</ul>
<p>LummaStealer Hash resolver:</p>
<ul>
<li><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/LummaStealer/lummaStealer_v2_hash_resolver.py">lummaStealer_v2_hash_resolver.py</a></li>
</ul>
<p>LummaSteler sample:</p>
<ul>
<li><a href="https://bazaar.abuse.ch/sample/277d7f450268aeb4e7fe942f70a9df63aa429d703e9400370f0621a438e918bf/">MalwareBazaar</a></li>
</ul>
<h2 id="bonus">Bonus</h2>
<p>In order to understand how API Hashing works it‚Äôs very useful to make your hand dirty on low level components. However, once you have some experience, it is also very helpful to have some tools that speed up your analysis. An amazing project is <a href="https://github.com/OALabs/hashdb">HashDB</a> maintained by OALabs. It is a simple and effective plugin for IDA and Binary Ninja that is going to resolve hashes, if the routine is implemented. If you want to try out this plugin for this LummaStealer sample, my pull request has already been  merged ;)</p>
<h2 id="appendix-1---addressofnames">Appendix 1 - AddressOfNames</h2>
<p>The algorithm to retrieve the <strong>RVA</strong> associated to a function is quite straightforward:</p>
<ol>
<li>Iterate over the <strong>AddressOfNames</strong> structures.</li>
<li>Once you find a match with a specific function, suppose at <em>i</em> position, the loader is going to use index <em>i</em> to address the structure <strong>AddressOfNamesOrdinals</strong>.
<ol>
<li>k = AddressOfNamesOrdinals[i]</li>
</ol>
</li>
<li>After collecting the value stored in <strong>AddressOfNamesOrdinals</strong> (2.a) we could use that value to address <strong>AddressOfFunctions</strong>, collecting the actual RVA of the function we were looking for.
<ol>
<li><code>function_rva</code> = AddressOfFunctions[k]</li>
</ol>
</li>
</ol>
<p><img src="/img/api_hashing/functions_and_names_pointers.png" alt="Figure 7: How to retrieve functions names and pointers"></p>
<p>Figure 7: How to retrieve functions names and pointers</p>
<blockquote>
<p>üí°<em>If you want to experiment a little bit more with this concept, I suggest to take the kernel32.dll library and follows this algorithm using <a href="https://github.com/hasherezade/pe-bear">PE-Bear</a></em></p>
</blockquote>
]]></content></item><item><title>Understanding PEB and LDR Structures using IDA and LummaStealer</title><link>https://Viuleeenz.github.io/posts/2024/02/understanding-peb-and-ldr-structures-using-ida-and-lummastealer/</link><pubDate>Sun, 04 Feb 2024 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2024/02/understanding-peb-and-ldr-structures-using-ida-and-lummastealer/</guid><description>&lt;p>In this post I‚Äôm going to explain how Process Environment Block (PEB) is parsed by malware devs and how that structure is abused. Instead of going too deep into a lot of details, I would like to follow an easier approach pairing the theory with a practical real example using IDA and LummaStealer, without overwhelming the reader with a lot of technical details trying to simplify the data structure involved in the process. At the end of the theory part, I‚Äôm going to &lt;strong>apply PEB and all related structures in IDA&lt;/strong>, inspecting malware parsing capabilities that are going to be applied for resolving hashed APIs.&lt;/p></description><content type="html"><![CDATA[<p>In this post I‚Äôm going to explain how Process Environment Block (PEB) is parsed by malware devs and how that structure is abused. Instead of going too deep into a lot of details, I would like to follow an easier approach pairing the theory with a practical real example using IDA and LummaStealer, without overwhelming the reader with a lot of technical details trying to simplify the data structure involved in the process. At the end of the theory part, I‚Äôm going to <strong>apply PEB and all related structures in IDA</strong>, inspecting malware parsing capabilities that are going to be applied for resolving hashed APIs.</p>
<p>Let‚Äôs start.</p>
<h3 id="peb-structure">PEB Structure</h3>
<p>The PEB is a crucial data structure that contains various <strong>information</strong> about a <strong>running process</strong>. Unlike other Windows structure (e.g., EPROCESS, ETHREAD, etc..), it exists in the user address space and is available for every process at a <strong>fixed</strong> address in memory (PEB can be found at <code>fs:[0x30]</code> in the Thread Environment Block (TEB) for x86 processes as well as at <code>gs:[0x60]</code> for x64 processes). Some of documented fields that it‚Äôs worth knowing are:</p>
<ul>
<li>BeingDebugged: Whether the process is being debugged;</li>
<li><strong>Ldr</strong>: A pointer to a <code>PEB_LDR_DATA</code> structure providing information about loaded modules;</li>
<li>ProcessParameters: A pointer to a <code>RTL_USER_PROCESS_PARAMETERS</code> structure providing information about process startup parameters;</li>
<li>PostProcessInitRoutine: A pointer to a callback function called after DLL initialization but before the main executable code is invoked</li>
</ul>
<h3 id="image-loader-aka-ldr">Image Loader aka Ldr</h3>
<p>When a process is started on the system, the kernel creates a process object to represent it and performs various kernel-related initialization tasks. However, these tasks do not result in the execution of the application, but in the <strong>preparation of its context and environment</strong>. This work is performed by the <em><strong>image loader</strong></em> (<strong>Ldr</strong>).</p>
<p>The loader is responsible for several main tasks, including:</p>
<ul>
<li>Parsing the import address table (IAT) of the application to look for all DLLs that it requires (and then recursively parsing the IAT of each DLL), followed by parsing the export table of the DLLs to make sure the function is actually present.</li>
<li>Loading and unloading DLLs at runtime, as well as on demand, and maintaining a list of all
loaded modules (the module database).</li>
</ul>
<p><img src="/img/peb_parsing/list_structure.png" alt="Figure 1: PEB, LDR_DATA and LDR_MODULE interactions"></p>
<p>Figure 1: PEB, LDR_DATA and LDR_MODULE interactions</p>
<p>At first glance, these structures might seem a little bit confusing. However, let&rsquo;s simplify them to make them more understandable. We could think about them as a <strong>list where the structure PEB_LDR_DATA is the head of the list</strong> and <strong>each module information is accessed through a double linked list</strong> (<em>InOrderLoaderModuleList</em> in this case) that points to <strong>LDR_MODULE</strong>.</p>
<h3 id="how-those-structures-are-abused">How those structures are abused</h3>
<p>Most of the times when we see <strong>PEB and LDR_MODULE structure parsing</strong> we are dealing with malwares that are potentially using <strong>API Hashing technique.</strong> Shellcode will typically walk through those structures in order to find the base address of loaded dlls and extract all their exported functions, collecting names and <strong>pointers to the functions that are intended to call</strong>, avoiding to leave direct reference of them within the malware file.</p>
<p>This is a simple trick that tries to evade some basic protections mechanism that could arise when we see clear references to malware-related functions such as: <em>VirtualAlloc, VirtualProtect, CreateProcessInterW, ResumeThread, etc‚Ä¶</em></p>
<h3 id="api-hashing">API Hashing</h3>
<p>By employing API hashing, malware creators can ensure that specific Windows APIs remain hidden from casual observation. Through this approach, malware developers try to add an extra layer of complexity by concealing suspicious Windows API calls within the Import Address Table (IAT) of PE.</p>
<p>API hashing technique is pretty straightforward and it could be divided in three main steps:</p>
<ol>
<li><em>Malware developers prepare a set of hashes corresponding to WINAPI functions.</em></li>
<li><em>When an API needs to be called, it looks for loaded modules through the PEB.Ldr structure.</em></li>
<li><em>Then, when a module is find, it goes through all the functions performing the hash function until the result matches with the given input.</em></li>
</ol>
<p><img src="/img/peb_parsing/api_hashing_overview.png" alt="Figure 2: API Hashing Overview"></p>
<p>Figure 2: API Hashing Overview</p>
<p>Now that we have a more understanding of the basic concepts related to API hashing, PEB and Ldr structures, let‚Äôs try to put them in practice using LummaStealer as an example.</p>
<h3 id="parsing-peb-and-ldr-with-lummastealer">Parsing PEB and LDR with LummaStealer</h3>
<p>Opening up the sample in IDA and scrolling a little after the main function it is possible to bump into very interesting functions that perform some actions on a couple of parameters that are quite interesting and correlated to explanation so far.</p>
<p><img src="/img/peb_parsing/sus_hash.png" alt="Figure 3: Wrapper function for hash resolving routine in LummaStealer"></p>
<p>Figure 3: Wrapper function for hash resolving routine in LummaStealer</p>
<p>Before function <em><strong>call sub_4082D3</strong></em> (highlighted) we could see some mov operation of two values:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span> <span style="color:#a6e22e">mov</span> edx, aKernel32Dll_0
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">...</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">mov</span> ecx, <span style="color:#ae81ff">0x7328f505</span>
</span></span></code></pre></div><p>Those parameters are quite interesting because:</p>
<ul>
<li>The former represents an interesting dll that contains some useful functions such as <em>LoadLibrary, VirtualAlloc, etc..</em></li>
<li>The latter appears to be a hash (maybe correlated to the previous string).</li>
</ul>
<p>If we would like to make an educated guess, it is possible that this function is going to find a function (within <em>kernel32.dll</em>) whose hash corresponds to the input hash. However, let‚Äôs try to understand if and how those parameters are manipulated in the function call, validating also our idea.</p>
<p><img src="/img/peb_parsing/code_compare.png" alt="Figure 4: Parsing PEB and LDR_MODULE for API hash routine. "></p>
<p>Figure 4: Parsing PEB and LDR_MODULE for API hash routine.</p>
<p>Through Figure 6, you can see the exact same code, before (left side) and after (right side) renaming structures. Examining the code a little bit we should be able to recall the concepts already explained in the previous sections.</p>
<p>Let‚Äôs examine the first block of code. Starting from the top of the code we could spot the instruction <code>mov eax, (large)fs:30h</code>  that is going to collect the <strong>PEB pointer</strong>, storing its value in <strong>eax.</strong> Then, right after this instruction we could see <strong>eax</strong> <strong>used with an offset</strong>(<strong>0xC</strong>). In order to understand what is going on, its possible to collect the PEB structure  and look for the 0xC offset. Doing that, it‚Äôs clear that <strong>eax is going to collect the Ldr pointer</strong>. The last instruction of the first block is <code>mov edi, [eax+10h]</code> . This is a crucial instruction that needs a dedicated explanation:</p>
<p>If you are going to look at <strong>PEB_LDR_DATA</strong> you will see that 0x10 offset (for x64 bit architecture)  points to <strong>InLoadOrderModuleList</strong> (that contains, according to its description, <code>pointers to previous and next LDR_MODULE in initialization order</code>). Through this instruction, malware is going to take a <strong>LDR_MODULE</strong> structure (as explained in Figure 3), settling all the requirements to parse it.</p>
<p>Without going too deep in the code containing the loop (this could be left as an exercise), it is possible to see that the next three blocks are going to find the <em>kernel32.dll</em> iterating over the <strong>LDR_MODULE</strong> structure parameters.</p>
<p>At the very end of the code, we could see the last block calling a function using the dll pointers retrieved through the loop, using another hash value. This behavior give us another chance for a couple of insight:</p>
<ul>
<li>This code is a candidate to settle all parameters that are going to be used for API hash resolving routine (as illustrated in the API Hashing section), since that its output will be used as a function call.</li>
<li>The string <em>kernel32.dll</em> gave us some hints about possible candidate functions (e.g., <em>LoadLibraryA, VirtualAlloc, etc..</em>).</li>
</ul>
<p>With this last consideration, it&rsquo;s time to conclude this post avoiding adding more layers of complexity, losing our focus on PEB and related structures.</p>
<h3 id="function-recap">Function recap</h3>
<p>Before concluding, let‚Äôs try to sum up, what we have seen so far, in order to make the analysis even more clear:</p>
<ol>
<li>The function <code>4082D3</code> takes <strong>two parameters</strong> that are a hash <strong>value</strong> and a string containing a <strong>dll library</strong>.</li>
<li>Iterating over the loaded modules, it looks for the module name containing the hardcoded <strong>kernel32.dll</strong>.</li>
<li>Once the module is found, it invokes another function (<code>40832A</code>), passing a pointer to the base address of the module and a hash value.</li>
<li>The function returns a pointer to a function that takes as an argument the <strong>dll name passed to</strong> 4082D3. This behavior suggests that some sort of <em>LoadLibrary</em> has been resolved on point 3.</li>
<li>As a final step, the function <code>40832A</code> is called once again, using the hash value passed as a parameter in the function <code>4082D3</code> and a base address retrieved from the point 4.</li>
</ol>
<p>Following all the steps it&rsquo;s easy to spot that the <code>40832A</code> function is the actual API hash resolving routine and the function <code>4082D3</code> has been used to settle all the required variables.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Through this blog post I tried to explain a little bit better how the PEB and related structures are parsed and abused by malwares. However, I also tried to show how malware analysis could be carried out examining the code and renaming structures accordingly. This brief introduction will be also used as a starting point for the next article where I would like to take the same sample and emulate the API hashing routine in order to resolve all hashes, making this sample ready to be analyzed.</p>
<h3 id="note-about-simplification">Note about simplification</h3>
<p>It‚Äôs worth mentioning that to make those steps easier, there has been a simplification. In fact, PEB_LDR_DATA contains three different structures that could be used to navigate modules, but for this blogpost, their use could be ignored. Another structure that is worth mentioning it‚Äôs LDR_DATA_TABLE_ENTRY that could be considered a corresponding to the LDR_MODULE structure.</p>
<h3 id="references">References:</h3>
<p>Undocumented Windows Internal Structures:</p>
<ul>
<li><a href="http://undocumented.ntinternals.net/">The Undocumented Functions</a></li>
<li><a href="https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntpsapi_x/peb_ldr_data.htm">PEB_LDR_DATA</a></li>
</ul>
<p>LummaSteler sample:</p>
<ul>
<li><a href="https://bazaar.abuse.ch/sample/277d7f450268aeb4e7fe942f70a9df63aa429d703e9400370f0621a438e918bf/">MalwareBazaar</a></li>
</ul>
]]></content></item><item><title>Applied Emulation - Decrypting Ursnif strings with Unicorn</title><link>https://Viuleeenz.github.io/posts/2023/12/applied-emulation-decrypting-ursnif-strings-with-unicorn/</link><pubDate>Wed, 20 Dec 2023 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2023/12/applied-emulation-decrypting-ursnif-strings-with-unicorn/</guid><description>&lt;h3 id="introduction">Introduction&lt;/h3>
&lt;p>Here we go with another chapter of the Applied Emulation series. In the previous blogpost we have talked about emulation and more specifically, the usage of &lt;em>Dumpulator&lt;/em> to perform a quick triage. However, in this blogpost we are going to use a completely different approach, taking advantage of &lt;strong>static analysis to&lt;/strong> &lt;strong>understand and emulate a string decryption algorithm through &lt;a href="https://www.unicorn-engine.org/">Unicorn&lt;/a>&lt;/strong>. As always, I would like to give a practical example on a real case scenario. Because of that, I have chosen to analyze an &lt;strong>Ursnif&lt;/strong> sample.&lt;/p></description><content type="html"><![CDATA[<h3 id="introduction">Introduction</h3>
<p>Here we go with another chapter of the Applied Emulation series. In the previous blogpost we have talked about emulation and more specifically, the usage of <em>Dumpulator</em> to perform a quick triage. However, in this blogpost we are going to use a completely different approach, taking advantage of <strong>static analysis to</strong> <strong>understand and emulate a string decryption algorithm through <a href="https://www.unicorn-engine.org/">Unicorn</a></strong>. As always, I would like to give a practical example on a real case scenario. Because of that, I have chosen to analyze an <strong>Ursnif</strong> sample.</p>
<p>It‚Äôs worth mentioning that this sample is part of weekly challenges related to the <a href="https://courses.zero2auto.com/">Zero2Auto</a> course. However, instead of automating the full code extraction, as requested by the challenge, I found even more interesting going into unexplored paths applying emulation instead.</p>
<h3 id="unicorn-challenges">Unicorn challenges</h3>
<p>Using pure static analysis came with few limitations, in fact, Unicorn is a CPU emulator framework that does not have built in capabilities to invoke syscall directly. Because of that we need to overcome at least a couple of challenges before emulating our code:</p>
<ul>
<li>
<p>The first and probably the most challenging constraint is that we are going to emulate CPU instructions, instead of using direct calls to Windows API. Because of that, we need to choose our code carefully.</p>
</li>
<li>
<p>After that we have identified a candidate algorithm, we still need to set up the emulation environment variables (e.g., stack memory, registers, sections, start and end code, algorithm parameters, etc‚Ä¶).</p>
</li>
</ul>
<p>Speaking about ‚Äúgood candidate function‚Äù, we could look for a custom and self-contained algorithm. Even if those requirements seem to be strict constraints, an experienced reverser knows that most of the malware out there have these components as a part of their decryption routine. However, let‚Äôs take a step back. Someone may wonder why we don&rsquo;t use Dumpulator instead of Unicorn, considering all these limitations. The answer is straightforward:</p>
<p><strong>Dumpulator may not be usable if we are unable to run the code</strong> and set up the user mode space. Nevertheless, I strongly believe that it is more <strong>important to understand where and when a technique should be applied</strong>, even if it adds a few layers of complexity, rather than rushing for the easiest or the first solution that comes to our mind.</p>
<h3 id="ursnif-decryption-routine">Ursnif decryption routine</h3>
<p>Decryption routine is pretty straightforward to locate, it just follows the campaignDate variable that is going to be used as a decryption key for the .bss segment. Key generation algorithm has been already described <a href="https://www.0ffset.net/reverse-engineering/challenge-1-gozi-string-crypto/">here</a>, however, I would like to focus on the decryption routine itself, in order to understand all requirements to emulate this code.</p>
<p><img src="/img/emulation_ursnif/decryption_routine_explained.png" alt="Figure 1: Decryption routine explained">
Figure 1: Decryption routine explained</p>
<p>At the first glance we could see that the function is self-contained and most of the operations are simple math (sub, add) that involves the key and the encrypted data. However, before proceeding it&rsquo;s important to have a look at the following instruction:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> [ecx], eax
</span></span></code></pre></div><p><strong>[ecx] is going to be the place to save the output of each decrypted byte</strong>. Nevertheless, ecx is also used as a counter to get the next byte from the <strong>.bss segment</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> eax, [edx<span style="color:#f92672">+</span>ecx]
</span></span></code></pre></div><p>Because of that we need to handle that situation very carefully. In fact, <strong>if we do not consider those instructions, we are going to have an access memory violation</strong> with ecx pointing to an unallocated memory region. In order to solve this issue, there are two ways:</p>
<ul>
<li>Allocating memory at <strong>0x000000</strong>. In this case, ecx will be used as a counter and as a pointer without any issue;</li>
<li>Otherwise, we could use a <strong>hook</strong> on our emulator that is going to analyze each instruction and when we are dealing with <strong>[ecx]</strong>, we could skip that instruction, redirecting the decrypted output towards another variable.</li>
</ul>
<p>For this blogpost we are going to use the first solution. Considering this post as an introduction of Unicorn, I don‚Äôt want to overwhelm readers with a lot of content (setting up the environment will be quite challenging to follow). It‚Äôs always good to master some basic concept before proceeding towards more advanced techniques</p>
<h3 id="setting-up-emulation-environment">Setting up emulation environment</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> unicorn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> unicorn.x86_const <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> pefile
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> struct
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>file_data <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#39;unpacked_ursnif.bin&#39;</span>,<span style="color:#e6db74">&#39;rb&#39;</span>)<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>pe <span style="color:#f92672">=</span> pefile<span style="color:#f92672">.</span>PE(data<span style="color:#f92672">=</span>file_data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> pe<span style="color:#f92672">.</span>sections:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;.bss&#39;</span> <span style="color:#f92672">in</span> s<span style="color:#f92672">.</span>Name[:<span style="color:#ae81ff">6</span>]: 
</span></span><span style="display:flex;"><span>        bss_virtual_address <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span>VirtualAddress
</span></span><span style="display:flex;"><span>        bss_section_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x1000</span>
</span></span><span style="display:flex;"><span>        bss_section_data <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span>get_data()
</span></span></code></pre></div><p>First of all we need to import the Unicorn module and also unicorn constants that we are going to use to interact with registers. Then we could use the pefile module to load our bin file and take notes of <strong>.bss segment data.</strong>.</p>
<p>Then, we need to take the whole code that needs to be emulated. Before proceeding, it&rsquo;s important to keep in mind that emulation is quite slow and we need to use only the code needed for our purpose. For instance, prolog and epilogue instructions are not very useful for us, since we are emulating a single function without knowing any information about previous ESP and EBP values. Because of that we could skip them.</p>
<p>To get the proper bytes, with IDA, we could highlight the code that is going to be emulated and, using <strong>shift+e</strong>, spawn a popup with all selected bytes, ready to be pasted in our code.</p>
<p><img src="/img/emulation_ursnif/select_code_to_emulate.png" alt="Figure 2: Select code to emulate">
Figure 2: Select code to emulate</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>code <span style="color:#f92672">=</span> bytes<span style="color:#f92672">.</span>fromhex(<span style="color:#e6db74">&#39;8B040A8BF885C0750AC744241001000000EB0D2B74240C03C689018BF783C104FF4C241075DA&#39;</span>)
</span></span></code></pre></div><p>Now things are starting to heat up, trying to settle our emulation. First of all, we need to instantiate Unicorn, then we need to set up stack memory, ESP, data memory (using .bss content) and then fill the code section with our bytes. To make it easier to read, I have split the whole script in multiple parts, as follow:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Unicorn emulator setup.</span>
</span></span><span style="display:flex;"><span>uc <span style="color:#f92672">=</span> Uc(UC_ARCH_X86, UC_MODE_32)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stack_base <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00100000</span>
</span></span><span style="display:flex;"><span>stack_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00100000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ESP is moved in the middle of the stack in order to handle.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># instruction that uses ESP as base address (e.g., [esp + 0xc]).</span>
</span></span><span style="display:flex;"><span>ESP <span style="color:#f92672">=</span> stack_base <span style="color:#f92672">+</span> (stack_size <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Map the stack memory into the emulator and feed it with null byte.</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_map(stack_base, stack_size)
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_write(stack_base, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> stack_size)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Write python variable ESP in emulator ESP register.</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_ESP, ESP) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>data_base <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00200000</span>
</span></span><span style="display:flex;"><span>data_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00100000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Map the data memory with r/w/x permissions avoiding access violation.</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_map(data_base, data_size, UC_PROT_ALL)
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_write(data_base, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> data_size)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Data section needs to be filled with .bss data.</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_write(data_base, bss_section_data)
</span></span></code></pre></div><p>Through this snippet of code, we have prepared everything related to the stack and data section. More precisely, with <strong>uc.mem_map</strong> we have mapped a memory address with its size and protections ( rwx permissions have been chosen to avoid exceptions).</p>
<p>It‚Äôs worth mentioning that, what really makes those memories different is the ESP register that represents a pointer onto the stack. However, under the hood, there are no differences between the allocated memories.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># ----- Arguments Setup --------- #</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Setting up key parameter.</span>
</span></span><span style="display:flex;"><span>key <span style="color:#f92672">=</span> gen_key(bss_virtual_address)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Generate key bytes.</span>
</span></span><span style="display:flex;"><span>key_bytes <span style="color:#f92672">=</span> struct<span style="color:#f92672">.</span>pack(<span style="color:#e6db74">&#39;&lt;I&#39;</span>, key)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Write key byte on the stack.</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_write(ESP, key_bytes)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># key bytes are located at ESP+0xC.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># To handle that istrution properly, we need to shift ESP of 0xC bytes.</span>
</span></span><span style="display:flex;"><span>ESP <span style="color:#f92672">-=</span> <span style="color:#ae81ff">0xC</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># EDX is going to be used as a pointer to the encrypted data.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># It will be used as a base address: [edx + ecx].</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># It needs to be initialized at base address of our data.</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_EDX, data_base)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ECX is a counter starting from 0.</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_ECX, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Write new stack position.</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>reg_write(UC_X86_REG_ESP, ESP)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ----- Arguments Setup End ----- #</span>
</span></span></code></pre></div><p>In order to get the key, we have called a gen_key routine (omitted here, to focus on emulation setup) that is going to return a string containing the decryption key. Then, once we get the key, we have to store it on the stack, respecting the <a href="https://docs.python.org/3/library/struct.html">little endian format</a>. Along with key parameters we have also settled all other arguments needed for the function, such as: encrypted data (edx), counter (ecx) as well as updated the esp according to the instruction [esp+0xC] that is going to take the key bytes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># ---- Handling ECX access violation ---- #</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># mov [ecx], eax.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>decrypted_base <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00000000</span>
</span></span><span style="display:flex;"><span>decrypted_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00100000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_map(decrypted_base, decrypted_size, UC_PROT_ALL)
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_write(decrypted_base, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> decrypted_size)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -- Handling ECX access violation end -- #</span>
</span></span></code></pre></div><p>As mentioned above, since that ecx will be either a pointer and a counter, we are going to create a memory space located to <strong>0x00000000</strong>. In this case, when we are going to deal with   <strong>mov [ecx] ,eax</strong> instruction, we will avoid any exception.</p>
<p>To conclude we need to setup memory for our code. This is a pretty straightforward task if have followed the previous steps. Map the code address, fill it with null bytes and then write the bytes stored in the code variable.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>code_base <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00400000</span>
</span></span><span style="display:flex;"><span>code_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x00100000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Map target memory with r/w/x permissions</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_map(code_base, code_size, UC_PROT_ALL)
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_write(code_base, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">*</span> code_size)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Write our code into the target memory</span>
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>mem_write(code_base, code)
</span></span><span style="display:flex;"><span>code_end <span style="color:#f92672">=</span> code_base <span style="color:#f92672">+</span> len(code)
</span></span><span style="display:flex;"><span>uc<span style="color:#f92672">.</span>emu_start(code_base, code_end, timeout<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, count<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span></code></pre></div><p>Now we have satisfied all setting requirements for our emulation and its time to test it out.</p>
<h3 id="testing">Testing</h3>
<p>Running our emulator against few Ursnif samples reveal that we have correctly settled all the environment variables. As you can see from the image below, it has been possible to retrieve all encrypted strings. Some of them could be very useful in order to do a step further in our analysis, since that we have references to infrastructure, powershell script as well as network requests template.</p>
<p><img src="/img/emulation_ursnif/decrypted_strings.png" alt="Figure 3: Decrypted strings">
Figure 3: Decrypted strings</p>
<h3 id="conclusion--further-development">Conclusion &amp; Further Development</h3>
<p>Emulation is a powerful tool, like a swiss knife, and it needs to be considered anytime we are dealing with malware automation. I hope that some of you had fun reading this post and learnt something new, to the point that you can&rsquo;t wait to apply this technique to your own sample.</p>
<p>I‚Äôm still planning to write some structured content about this topic. I don‚Äôt have a deadline for that but it is in my new year resolution list! In the meantime, keep reversing!</p>
<h3 id="references">References</h3>
<p>Sample analyzed:</p>
<ul>
<li><a href="https://www.unpac.me/results/3a3eb893-10fe-42c1-a2c4-5d86cc572fa4#/">Unpacme</a></li>
<li><a href="https://bazaar.abuse.ch/sample/413cf6a694eef7a4f1725a11938f1ab2df1957bfb3bf20cf6a47017bebbad2a9/">MalwareBazaar</a></li>
</ul>
<p>Unicorn:</p>
<ul>
<li><a href="https://www.unicorn-engine.org/">Unicorn engine</a></li>
</ul>
<p>Emulator:</p>
<ul>
<li><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/Ursnif/ursnif_emulate_decryption.py">ursnif_string_decryptor.py</a></li>
</ul>
]]></content></item><item><title>Applied Emulation - Analysis of MarsStealer</title><link>https://Viuleeenz.github.io/posts/2023/11/applied-emulation-analysis-of-marsstealer/</link><pubDate>Wed, 15 Nov 2023 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2023/11/applied-emulation-analysis-of-marsstealer/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>&lt;strong>Emulation is a technique that could be very handy and effective&lt;/strong> when we have to deal with &lt;strong>malware triage&lt;/strong>, &lt;strong>configuration extractor&lt;/strong> and &lt;strong>deobfuscate part of the code without rewriting complex algorithms&lt;/strong>. Even if it seems magic (and it&amp;rsquo;s not unfortunately) it&amp;rsquo;s still not possible to apply emulation on random code. However, if applied correctly this method could really speed up our malware analysis and triage. Through this blogpost I would like to give an overview about emulation usage and apply it in a real case scenario.&lt;/p></description><content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p><strong>Emulation is a technique that could be very handy and effective</strong> when we have to deal with <strong>malware triage</strong>, <strong>configuration extractor</strong> and <strong>deobfuscate part of the code without rewriting complex algorithms</strong>. Even if it seems magic (and it&rsquo;s not unfortunately) it&rsquo;s still not possible to apply emulation on random code. However, if applied correctly this method could really speed up our malware analysis and triage. Through this blogpost I would like to give an overview about emulation usage and apply it in a real case scenario.</p>
<p>Recently, I followed a twitter warning about Vidar malware in the wild and eager to revalidate an IDA-python script to deobfuscate strings, I immediately jumped into it. However, extracting that sample it was pretty obvious that I was dealing with another stealer, called MarsStealer. Since I did have a lot of information about that sample, I thought that could be a good choice to experiment with emulation. The result was quite promising and because of that <strong>I want to take this occasion to show a few basic emulations that could, hopefully, help someone else to speed up its analysis</strong>.</p>
<h3 id="payload-extraction">Payload extraction</h3>
<p>Opening up in IDA the original sample, it was clear that a lot of strings were actually obfuscated and the code was partially packed, because of the references to jumps or calls towards registries and un-initialized DWORD.</p>
<p><img src="/img/mars_stealer/ms_ida_packed_code.png" alt="Figure 1: MarsStealer packed code"></p>
<p>Figure 1: MarsStealer packed code</p>
<p>In order to extract the actual payload that will contain a deobfuscation string routine and additional code, it&rsquo;s necessary to go for dynamic analysis and speed up our extraction. As always one of the quickest methods to extract unpacked information is to look for <strong>VirtualAlloc</strong> and <strong>VirtualProtect.</strong></p>
<p><img src="/img/mars_stealer/ms_unpacked_payload.png" alt="Figure 2: Unpacked payload retrieved"></p>
<p>Figure 2: Unpacked payload retrieved</p>
<h3 id="deobfuscation-routine-analysis">Deobfuscation routine analysis</h3>
<p>Since that our purpose is to find out code to emulate, we could look for a deobfuscation routine within the payload extracted. Our search won‚Äôt last long because, almost <strong>immediately after the VirtualProtect</strong> call the malware jumps directly to the allocated memory, <strong>starting the name resolving routine.</strong></p>
<p><img src="/img/mars_stealer/ms_deobfuscation_wrapper.png" alt="Figure 3: Deobfuscation wrapper"></p>
<p>Figure 3: Deobfuscation wrapper</p>
<p>The highlighted function is a wrapper that contains the actual routine. The code is quite easy to spot because of the <strong>three push instructions</strong>. Opening the payload in IDA, it&rsquo;s possible to go a little bit deeper and explore the deobfuscation routine, reconstructing its signature and from that point, understanding the function flow.</p>
<p><img src="/img/mars_stealer/ms_deobfuscation_routine.png" alt="Figure 4: Deobfuscation routine"></p>
<p>Figure 4: Deobfuscation routine</p>
<p>Regardless of the red box related memory errors, it&rsquo;s very easy to understand its core functionality and control flow. However, even if it seems quite easy to reconstruct its logic, I‚Äôm going to take this code as a use case to try a completely different approach, using <strong>emulation to resolve all the strings</strong>.</p>
<h3 id="emulation-requirements">Emulation requirements</h3>
<p>Before proceeding with emulation, there are few things to settle. The first one is that for emulating this code, we need to emulate the user mode because we are dealing with instructions that are going to make additional <strong>calls to WindowsAPI</strong>. For that reason, we are going to use <a href="https://github.com/mrexodia/dumpulator">dumpulator</a>, implementing if needed some API calls. The second thing to talk about are <strong>the requirements for dumpulator</strong>. To make it effective, it&rsquo;s necessary to take a <strong>minidump</strong> of the process that we are analyzing and understand the parameters for <strong>starting</strong> and <strong>stopping</strong> <strong>emulation</strong>.</p>
<ul>
<li>In order to <strong>take a minidump</strong>, its possible to use <strong><strong><strong><strong><strong><strong>x32dbg/x64dbg</strong></strong></strong></strong></strong></strong> that include it as a command (e.g., minidump  mstealer.dump);</li>
<li>then to take the <strong>starting point</strong>, it‚Äôs possible to take references to deobfuscation calls and save those addresses for later.</li>
</ul>
<p><img src="/img/mars_stealer/ms_references_to_deobfuscation_function.png" alt="Figure 5: References to deobfuscation function"></p>
<p>Figure 5: References to deobfuscation function</p>
<p>Now that we have two out of three requirements, it&rsquo;s necessary to focus on the <strong>emulation ending point</strong>. Of course, this one is the most important requirement and could impact your result in terms of efficiency (emulation is tremendously slow) and code writing (could be required to write more code that fits your needs).</p>
<p>For the purpose of this analysis/tutorial about emulation I‚Äôm going straight to the point using <strong>hints collected from IDA</strong> and doing some dynamic code analysis.</p>
<h3 id="emulation-ending-point-extraction">Emulation ending point extraction</h3>
<p>Observing carefully the Figure 4, it&rsquo;s easy to spot that the plaintext string is settled <strong>after the for loop</strong> and <strong>before the VirtualProtect call</strong>. Looking at the assembly with the information acquired, it‚Äôs easy to understand that emulation should stop at the instruction <strong>push ecx</strong>. In fact, <strong>ecx register is going to be a pointer for the plaintext string</strong>.</p>
<p><img src="/img/mars_stealer/ms_plaintext_resolution.png" alt="Figure 6: Plaintext resolution"></p>
<p>Figure 6: Focus on plaintext resolution</p>
<p>With all this information, the <strong>emulation end variable</strong> could be easily retrieved within the debugger at the address <strong>0x031f4De5</strong>.</p>
<p><img src="/img/mars_stealer/ms_end_address.png" alt="Figure 7: Emulation stop address"></p>
<p>Figure 7: Emulation stop address</p>
<h3 id="string-resolving-automation">String Resolving Automation</h3>
<p>Since that we have collected all the requirements for the emulation, we are ready to setup our code as follow:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#Dumpulator libraries</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> dumpulator <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> dumpulator.native <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> dumpulator.handles <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> dumpulator.memory <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">deobfuscate</span>(address):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    start:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            [x] push ciphertext
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                push key
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                push key_length
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    end:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            [x] push ecx
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            call VirtualProtect
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    end <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x031F4DE5</span>
</span></span><span style="display:flex;"><span>    dp <span style="color:#f92672">=</span> Dumpulator(<span style="color:#e6db74">&#34;mars_stealer.dump&#34;</span>,quiet<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>    dp<span style="color:#f92672">.</span>start(address,  end<span style="color:#f92672">=</span>end )
</span></span><span style="display:flex;"><span>    out <span style="color:#f92672">=</span> dp<span style="color:#f92672">.</span>read_str(dp<span style="color:#f92672">.</span>regs<span style="color:#f92672">.</span>ecx)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> out
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>starting_points <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0x031F2E46</span>,<span style="color:#ae81ff">0x031F2E5F</span>,<span style="color:#ae81ff">0x031F2E78</span>,<span style="color:#ae81ff">0x031F2E91</span>,<span style="color:#ae81ff">0x031F2EAA</span>,<span style="color:#ae81ff">0x031F2EC3</span>,<span style="color:#ae81ff">0x031F2EDC</span>,<span style="color:#ae81ff">0x031F2EF5</span>,<span style="color:#ae81ff">0x031F2F0E</span>,<span style="color:#ae81ff">0x031F2F27</span>,<span style="color:#ae81ff">0x031F2F40</span>,<span style="color:#ae81ff">0x031F2F59</span>,<span style="color:#ae81ff">0x031F2F72</span>,<span style="color:#ae81ff">0x031F2F8B</span>,<span style="color:#ae81ff">0x031F2FA4</span>,<span style="color:#ae81ff">0x031F2FBD</span>,<span style="color:#ae81ff">0x031F2FD6</span>,<span style="color:#ae81ff">0x031F2FEF</span>,<span style="color:#ae81ff">0x031F3008</span>,<span style="color:#ae81ff">0x031F3021</span>,<span style="color:#ae81ff">0x031F303A</span>,<span style="color:#ae81ff">0x031F3053</span>,<span style="color:#ae81ff">0x031F306C</span>,<span style="color:#ae81ff">0x031F3085</span>,<span style="color:#ae81ff">0x031F309E</span>,<span style="color:#ae81ff">0x031F30B7</span>,<span style="color:#ae81ff">0x031F30D0</span>,<span style="color:#ae81ff">0x031F30E9</span>,<span style="color:#ae81ff">0x031F3102</span>,<span style="color:#ae81ff">0x031F311B</span>,<span style="color:#ae81ff">0x031F3134</span>,<span style="color:#ae81ff">0x031F314D</span>,<span style="color:#ae81ff">0x031F3166</span>,<span style="color:#ae81ff">0x031F317F</span>,<span style="color:#ae81ff">0x031F3198</span>,<span style="color:#ae81ff">0x031F31B1</span>,<span style="color:#ae81ff">0x031F31CA</span>,<span style="color:#ae81ff">0x031F31E3</span>,<span style="color:#ae81ff">0x031F3206</span>,<span style="color:#ae81ff">0x031F321F</span>,<span style="color:#ae81ff">0x031F3238</span>,<span style="color:#ae81ff">0x031F3251</span>,<span style="color:#ae81ff">0x031F326A</span>,<span style="color:#ae81ff">0x031F3283</span>,<span style="color:#ae81ff">0x031F329C</span>,<span style="color:#ae81ff">0x031F32B5</span>,<span style="color:#ae81ff">0x031F32CE</span>,<span style="color:#ae81ff">0x031F32E7</span>,<span style="color:#ae81ff">0x031F3300</span>,<span style="color:#ae81ff">0x031F3319</span>,<span style="color:#ae81ff">0x031F3332</span>,<span style="color:#ae81ff">0x031F334B</span>,<span style="color:#ae81ff">0x031F3364</span>,<span style="color:#ae81ff">0x031F337D</span>,<span style="color:#ae81ff">0x031F3396</span>,<span style="color:#ae81ff">0x031F33AF</span>,<span style="color:#ae81ff">0x031F33C8</span>,<span style="color:#ae81ff">0x031F33E1</span>,<span style="color:#ae81ff">0x031F33FA</span>,<span style="color:#ae81ff">0x031F3413</span>,<span style="color:#ae81ff">0x031F342C</span>,<span style="color:#ae81ff">0x031F3445</span>,<span style="color:#ae81ff">0x031F345E</span>,<span style="color:#ae81ff">0x031F3477</span>,<span style="color:#ae81ff">0x031F3490</span>,<span style="color:#ae81ff">0x031F34A9</span>,<span style="color:#ae81ff">0x031F34C2</span>,<span style="color:#ae81ff">0x031F34DB</span>,<span style="color:#ae81ff">0x031F34F4</span>,<span style="color:#ae81ff">0x031F350D</span>,<span style="color:#ae81ff">0x031F3526</span>,<span style="color:#ae81ff">0x031F353F</span>,<span style="color:#ae81ff">0x031F3558</span>,<span style="color:#ae81ff">0x031F3571</span>,<span style="color:#ae81ff">0x031F358A</span>,<span style="color:#ae81ff">0x031F35A3</span>,<span style="color:#ae81ff">0x031F35BC</span>,<span style="color:#ae81ff">0x031F35D5</span>,<span style="color:#ae81ff">0x031F35EE</span>,<span style="color:#ae81ff">0x031F3607</span>,<span style="color:#ae81ff">0x031F3620</span>,<span style="color:#ae81ff">0x031F3639</span>,<span style="color:#ae81ff">0x031F3652</span>,<span style="color:#ae81ff">0x031F366B</span>,<span style="color:#ae81ff">0x031F3684</span>,<span style="color:#ae81ff">0x031F369D</span>,<span style="color:#ae81ff">0x031F36B6</span>,<span style="color:#ae81ff">0x031F36CF</span>,<span style="color:#ae81ff">0x031F36E8</span>,<span style="color:#ae81ff">0x031F3701</span>,<span style="color:#ae81ff">0x031F371A</span>,<span style="color:#ae81ff">0x031F3733</span>,<span style="color:#ae81ff">0x031F374C</span>,<span style="color:#ae81ff">0x031F3765</span>,<span style="color:#ae81ff">0x031F377E</span>,<span style="color:#ae81ff">0x031F3797</span>,<span style="color:#ae81ff">0x031F37B0</span>,<span style="color:#ae81ff">0x031F37C9</span>,<span style="color:#ae81ff">0x031F37E2</span>,<span style="color:#ae81ff">0x031F37FB</span>,<span style="color:#ae81ff">0x031F3814</span>,<span style="color:#ae81ff">0x031F382D</span>,<span style="color:#ae81ff">0x031F3846</span>,<span style="color:#ae81ff">0x031F385F</span>,<span style="color:#ae81ff">0x031F3878</span>,<span style="color:#ae81ff">0x031F3891</span>,<span style="color:#ae81ff">0x031F38AA</span>,<span style="color:#ae81ff">0x031F38C3</span>,<span style="color:#ae81ff">0x031F38DC</span>,<span style="color:#ae81ff">0x031F38F5</span>,<span style="color:#ae81ff">0x031F390E</span>,<span style="color:#ae81ff">0x031F3927</span>,<span style="color:#ae81ff">0x031F3940</span>,<span style="color:#ae81ff">0x031F3959</span>,<span style="color:#ae81ff">0x031F3972</span>,<span style="color:#ae81ff">0x031F398B</span>,<span style="color:#ae81ff">0x031F39A4</span>,<span style="color:#ae81ff">0x031F39BD</span>,<span style="color:#ae81ff">0x031F39D6</span>,<span style="color:#ae81ff">0x031F39EF</span>,<span style="color:#ae81ff">0x031F3A08</span>,<span style="color:#ae81ff">0x031F3A21</span>,<span style="color:#ae81ff">0x031F3A3A</span>,<span style="color:#ae81ff">0x031F3A53</span>,<span style="color:#ae81ff">0x031F3A6C</span>,<span style="color:#ae81ff">0x031F3A85</span>,<span style="color:#ae81ff">0x031F3A9E</span>,<span style="color:#ae81ff">0x031F3AB7</span>,<span style="color:#ae81ff">0x031F3AD0</span>,<span style="color:#ae81ff">0x031F3AE9</span>,<span style="color:#ae81ff">0x031F3B02</span>,<span style="color:#ae81ff">0x031F3B1B</span>,<span style="color:#ae81ff">0x031F3B34</span>,<span style="color:#ae81ff">0x031F3B4D</span>,<span style="color:#ae81ff">0x031F3B66</span>,<span style="color:#ae81ff">0x031F3B7F</span>,<span style="color:#ae81ff">0x031F3B98</span>,<span style="color:#ae81ff">0x031F3BB1</span>,<span style="color:#ae81ff">0x031F3BCA</span>,<span style="color:#ae81ff">0x031F3BE3</span>,<span style="color:#ae81ff">0x031F3BFC</span>,<span style="color:#ae81ff">0x031F3C15</span>,<span style="color:#ae81ff">0x031F3C2E</span>,<span style="color:#ae81ff">0x031F3C47</span>,<span style="color:#ae81ff">0x031F3C60</span>,<span style="color:#ae81ff">0x031F3C79</span>,<span style="color:#ae81ff">0x031F3C92</span>,<span style="color:#ae81ff">0x031F3CAB</span>,<span style="color:#ae81ff">0x031F3CC4</span>,<span style="color:#ae81ff">0x031F3CDD</span>,<span style="color:#ae81ff">0x031F3CF6</span>,<span style="color:#ae81ff">0x031F3D0F</span>,<span style="color:#ae81ff">0x031F3D28</span>,<span style="color:#ae81ff">0x031F3D41</span>,<span style="color:#ae81ff">0x031F3D5A</span>,<span style="color:#ae81ff">0x031F3D73</span>,<span style="color:#ae81ff">0x031F3D8C</span>,<span style="color:#ae81ff">0x031F3DA5</span>,<span style="color:#ae81ff">0x031F3DBE</span>,<span style="color:#ae81ff">0x031F3DD7</span>,<span style="color:#ae81ff">0x031F3DF0</span>,<span style="color:#ae81ff">0x031F3E09</span>,<span style="color:#ae81ff">0x031F3E22</span>,<span style="color:#ae81ff">0x031F3E3B</span>,<span style="color:#ae81ff">0x031F3E54</span>,<span style="color:#ae81ff">0x031F3E6D</span>,<span style="color:#ae81ff">0x031F3E86</span>,<span style="color:#ae81ff">0x031F3E9F</span>,<span style="color:#ae81ff">0x031F3EB8</span>,<span style="color:#ae81ff">0x031F3ED1</span>,<span style="color:#ae81ff">0x031F3EEA</span>,<span style="color:#ae81ff">0x031F3F03</span>,<span style="color:#ae81ff">0x031F3F1C</span>,<span style="color:#ae81ff">0x031F3F35</span>,<span style="color:#ae81ff">0x031F3F4E</span>,<span style="color:#ae81ff">0x031F3F67</span>,<span style="color:#ae81ff">0x031F3F80</span>,<span style="color:#ae81ff">0x031F3F99</span>,<span style="color:#ae81ff">0x031F3FB2</span>,<span style="color:#ae81ff">0x031F3FCB</span>,<span style="color:#ae81ff">0x031F3FE4</span>,<span style="color:#ae81ff">0x031F3FFD</span>,<span style="color:#ae81ff">0x031F4016</span>,<span style="color:#ae81ff">0x031F402F</span>,<span style="color:#ae81ff">0x031F4048</span>,<span style="color:#ae81ff">0x031F4061</span>,<span style="color:#ae81ff">0x031F407A</span>,<span style="color:#ae81ff">0x031F4093</span>,<span style="color:#ae81ff">0x031F40AC</span>,<span style="color:#ae81ff">0x031F40C5</span>,<span style="color:#ae81ff">0x031F40DE</span>,<span style="color:#ae81ff">0x031F40F7</span>,<span style="color:#ae81ff">0x031F4110</span>,<span style="color:#ae81ff">0x031F4129</span>,<span style="color:#ae81ff">0x031F4142</span>,<span style="color:#ae81ff">0x031F415B</span>,<span style="color:#ae81ff">0x031F4174</span>,<span style="color:#ae81ff">0x031F418D</span>,<span style="color:#ae81ff">0x031F41A6</span>,<span style="color:#ae81ff">0x031F41BF</span>,<span style="color:#ae81ff">0x031F41D8</span>,<span style="color:#ae81ff">0x031F41F1</span>,<span style="color:#ae81ff">0x031F420A</span>,<span style="color:#ae81ff">0x031F4223</span>,<span style="color:#ae81ff">0x031F423C</span>,<span style="color:#ae81ff">0x031F4255</span>,<span style="color:#ae81ff">0x031F426E</span>,<span style="color:#ae81ff">0x031F4287</span>,<span style="color:#ae81ff">0x031F42A0</span>,<span style="color:#ae81ff">0x031F42B9</span>,<span style="color:#ae81ff">0x031F42D2</span>,<span style="color:#ae81ff">0x031F42EB</span>,<span style="color:#ae81ff">0x031F4304</span>,<span style="color:#ae81ff">0x031F431D</span>,<span style="color:#ae81ff">0x031F4336</span>,<span style="color:#ae81ff">0x031F434F</span>,<span style="color:#ae81ff">0x031F4368</span>,<span style="color:#ae81ff">0x031F4381</span>,<span style="color:#ae81ff">0x031F439A</span>,<span style="color:#ae81ff">0x031F43B3</span>,<span style="color:#ae81ff">0x031F43CC</span>,<span style="color:#ae81ff">0x031F43E5</span>,<span style="color:#ae81ff">0x031F43FE</span>,<span style="color:#ae81ff">0x031F4417</span>,<span style="color:#ae81ff">0x031F4430</span>,<span style="color:#ae81ff">0x031F4449</span>,<span style="color:#ae81ff">0x031F4462</span>,<span style="color:#ae81ff">0x031F447B</span>,<span style="color:#ae81ff">0x031F4494</span>,<span style="color:#ae81ff">0x031F44AD</span>,<span style="color:#ae81ff">0x031F44C6</span>,<span style="color:#ae81ff">0x031F44DF</span>,<span style="color:#ae81ff">0x031F44F8</span>,<span style="color:#ae81ff">0x031F4511</span>,<span style="color:#ae81ff">0x031F452A</span>,<span style="color:#ae81ff">0x031F4543</span>,<span style="color:#ae81ff">0x031F455C</span>,<span style="color:#ae81ff">0x031F4575</span>,<span style="color:#ae81ff">0x031F458E</span>,<span style="color:#ae81ff">0x031F45A7</span>,<span style="color:#ae81ff">0x031F45C0</span>,<span style="color:#ae81ff">0x031F45D9</span>,<span style="color:#ae81ff">0x031F45F2</span>,<span style="color:#ae81ff">0x031F460B</span>,<span style="color:#ae81ff">0x031F4624</span>,<span style="color:#ae81ff">0x031F463D</span>,<span style="color:#ae81ff">0x031F4656</span>,<span style="color:#ae81ff">0x031F466F</span>,<span style="color:#ae81ff">0x031F4688</span>,<span style="color:#ae81ff">0x031F46A1</span>,<span style="color:#ae81ff">0x031F46BA</span>,<span style="color:#ae81ff">0x031F46D3</span>,<span style="color:#ae81ff">0x031F46EC</span>,<span style="color:#ae81ff">0x031F4705</span>,<span style="color:#ae81ff">0x031F471E</span>,<span style="color:#ae81ff">0x031F4737</span>,<span style="color:#ae81ff">0x031F4750</span>,<span style="color:#ae81ff">0x031F4769</span>,<span style="color:#ae81ff">0x031F4782</span>,<span style="color:#ae81ff">0x031F479B</span>,<span style="color:#ae81ff">0x031F47B4</span>,<span style="color:#ae81ff">0x031F47CD</span>,<span style="color:#ae81ff">0x031F47E6</span>,<span style="color:#ae81ff">0x031F47FF</span>,<span style="color:#ae81ff">0x031F4818</span>,<span style="color:#ae81ff">0x031F4831</span>,<span style="color:#ae81ff">0x031F484A</span>,<span style="color:#ae81ff">0x031F4863</span>,<span style="color:#ae81ff">0x031F487C</span>,<span style="color:#ae81ff">0x031F4895</span>,<span style="color:#ae81ff">0x031F48AE</span>,<span style="color:#ae81ff">0x031F48C7</span>,<span style="color:#ae81ff">0x031F48E0</span>,<span style="color:#ae81ff">0x031F48F9</span>,<span style="color:#ae81ff">0x031F4912</span>,<span style="color:#ae81ff">0x031F492B</span>,<span style="color:#ae81ff">0x031F4944</span>,<span style="color:#ae81ff">0x031F495D</span>,<span style="color:#ae81ff">0x031F4976</span>,<span style="color:#ae81ff">0x031F498F</span>,<span style="color:#ae81ff">0x031F49A8</span>,<span style="color:#ae81ff">0x031F49C1</span>,<span style="color:#ae81ff">0x031F49DA</span>,<span style="color:#ae81ff">0x031F49F3</span>,<span style="color:#ae81ff">0x031F4A0C</span>,<span style="color:#ae81ff">0x031F4A25</span>,<span style="color:#ae81ff">0x031F4A3E</span>,<span style="color:#ae81ff">0x031F4A57</span>,<span style="color:#ae81ff">0x031F4A70</span>,<span style="color:#ae81ff">0x031F4A89</span>,<span style="color:#ae81ff">0x031F4AA2</span>,<span style="color:#ae81ff">0x031F4ABB</span>,<span style="color:#ae81ff">0x031F4AD4</span>,<span style="color:#ae81ff">0x031F4AED</span>,<span style="color:#ae81ff">0x031F4B06</span>,<span style="color:#ae81ff">0x031F4B1F</span>,<span style="color:#ae81ff">0x031F4B38</span>,<span style="color:#ae81ff">0x031F4B51</span>,<span style="color:#ae81ff">0x031F4B6A</span>,<span style="color:#ae81ff">0x031F4B83</span>,<span style="color:#ae81ff">0x031F4B9C</span>,<span style="color:#ae81ff">0x031F4BB5</span>,<span style="color:#ae81ff">0x031F4BCE</span>,<span style="color:#ae81ff">0x031F4BE7</span>,<span style="color:#ae81ff">0x031F4C00</span>,<span style="color:#ae81ff">0x031F4C19</span>,<span style="color:#ae81ff">0x031F4C32</span>,<span style="color:#ae81ff">0x031F4C4B</span>,<span style="color:#ae81ff">0x031F4C64</span>,<span style="color:#ae81ff">0x031F4C7D</span>,<span style="color:#ae81ff">0x031F4C96</span>,<span style="color:#ae81ff">0x031F4CAF</span>,<span style="color:#ae81ff">0x031F4CC8</span>,<span style="color:#ae81ff">0x031F4CE1</span>,<span style="color:#ae81ff">0x031F4CFA</span>]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> starting_points:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># push offset is 4byte. </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 3 push instuction before call</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 0xC bytes backward to take all function parameters</span>
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">=</span> s <span style="color:#f92672">-</span> <span style="color:#ae81ff">0xC</span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Address </span><span style="color:#e6db74">{</span>hex(s)<span style="color:#e6db74">}</span><span style="color:#e6db74"> : </span><span style="color:#e6db74">{</span>deobfuscate(s)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span></code></pre></div><p>Launching this script we are able to extract a lot of information on Mars Stealer, starting our triage without even reversing the whole malware. In fact, from the resolved string we have something related to common stealer targets such as: credit cards, browser, crypto wallet, etc..</p>
<p><img src="/img/mars_stealer/ms_deobfuscated_strings.png" alt="Figure 8: Retrieved strings"></p>
<p>Figure 8: Retrieved strings</p>
<p>Additionally we also have a chance to get a few insights about anti-analysis or reversing-aware functions such as: <strong>IsDebuggerPresent</strong> or <strong>CreateToolhelp32Snapshot</strong>. Additionally we have also some indications about anti-sandbox techniques with <strong>HAL9TH</strong>, that should be the Microsoft sandbox computer name. All deobfuscated strings could be found within the <strong>Reference section</strong>.</p>
<h3 id="conclusion-and-next-chapter">Conclusion and next chapter</h3>
<p>Emulation represents the state of the art for analyzing malware functions or triaging sample without losing yourself in complex and heavily obfuscated routine. It was pretty fun to analyze Mars Stealer through this technique. I‚Äôm thinking of creating additional and probably more structured content (maybe a Whitepaper) about malware emulation.</p>
<p>The script above could be used as a reference for further analysis, it&rsquo;s quite simple (and not perfect) but very effective and I used that as a ‚Äú<em>soft</em>‚Äù introduction to this topic and also to give an idea of emulation capabilities.</p>
<p>Hope you enjoyed reading this post as much as I had reversing this malware and writing this article!</p>
<h3 id="references">References</h3>
<p>Sample analyzed:</p>
<ul>
<li><a href="https://bazaar.abuse.ch/sample/81dbad520f8f4d8163e02d7b01866918e8392bb549df2cb73f1b8148f6fd5b51/">MalwareBazaar Sample</a></li>
</ul>
<p>Minidump:</p>
<ul>
<li><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/MarsStealer/mars_stealer_minidump.7z">mars_stealer_minidump.7z</a></li>
</ul>
<p>String resolver:</p>
<ul>
<li><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/MarsStealer/MarsStealer_stringResolver.py">MarsStealer_stringResolver.py</a></li>
</ul>
<p>Extracted strings:</p>
<ul>
<li><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/MarsStealer/strings.txt">strings.txt</a></li>
</ul>
<p>Dumpulator:</p>
<ul>
<li><a href="https://github.com/mrexodia/dumpulator">Reference</a></li>
</ul>
]]></content></item><item><title>Vidar - payload inspection with static analysis</title><link>https://Viuleeenz.github.io/posts/2023/10/vidar-payload-inspection-with-static-analysis/</link><pubDate>Wed, 25 Oct 2023 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2023/10/vidar-payload-inspection-with-static-analysis/</guid><description>&lt;h2 id="behind-this-post">Behind this post&lt;/h2>
&lt;p>Through this blogpost I‚Äôm going to talk about one of the latest Vidar samples that I had a chance to analyze. The payload is actually part of a campaign delivered in July 2023 using PEC mails and this analysis comes from a post related to &lt;a href="https://cert-agid.gov.it/tag/vidar/">Cert-Agid&lt;/a> in the same period. Even if the payload seems to be out of time, it&amp;rsquo;s still a valid example for further analysis of more recents ones.&lt;/p></description><content type="html"><![CDATA[<h2 id="behind-this-post">Behind this post</h2>
<p>Through this blogpost I‚Äôm going to talk about one of the latest Vidar samples that I had a chance to analyze. The payload is actually part of a campaign delivered in July 2023 using PEC mails and this analysis comes from a post related to <a href="https://cert-agid.gov.it/tag/vidar/">Cert-Agid</a> in the same period. Even if the payload seems to be out of time, it&rsquo;s still a valid example for further analysis of more recents ones.</p>
<p>The purpose of this article is to give an overview of Vidar, helping people that are tracking this threat to properly deal with it. Moreover, it is also an excuse <strong>to tweak a little bit with IDA to show a possible solution related to common issues when we are dealing with highly obfuscated malware</strong>.</p>
<h2 id="static-analysis">Static Analysis</h2>
<p>Opening up the Vidar sample with IDA, it‚Äôs immediately clear that it contains few obfuscated strings and garbage code that prevents analysts from directly examining the sample. More precisely, it has been possible to discover three functions, analyzed in this blogpost, that are in charge of:</p>
<ul>
<li><strong>Detecting VMs execution</strong>;</li>
<li><strong>Detecting ‚Äúdefault settings</strong>‚Äù;</li>
<li><strong>Decrypting Strings</strong>.</li>
</ul>
<p><img src="https://lh7-us.googleusercontent.com/RUhAbxUgIAJQKmsvcjyWa6zNEr4ryy9wKguHx0GUVynFje3aEE0pyIF0zkVwVvYnbFOtAeDSuSFFsEImJEkC3leG8DbpwX-QXK5liy-uZfsg1OLFLs2yU8WIOmOSCihExjDcObga9dfCaiJb5sMJ2t0" alt="Figure 1 - Vidar main function with garbage code"></p>
<p>Figure 1 - Vidar main function with garbage code</p>
<h3 id="anti-analysis-implementation">Anti-Analysis implementation</h3>
<p>In this sample, there are three main functions that are in charge of performing anti-analysis checks.</p>
<p>The first one is implemented through the function <strong>VirtualAllocExNuma</strong> that checks if the sample is running on a system with one or more physical CPU:</p>
<p><img src="https://lh7-us.googleusercontent.com/-HDWHV34_5kdT04VICJmciGOaRD7ZDMrmP-DmNfc_oftxhumwvommeGnMfWFupVgEo7osoENveFybbs9YHKkQVzyHtXJtkxrnK2jjfceQ6hNTzdi6Bf2peaSK1YlGUFcr2Ma5_fn2KXXGwuAmVSEvCI" alt="Figure 2 - Call to VirtualAllocExNuma for physical CPU controls."></p>
<p>Figure 2 - Call to VirtualAllocExNuma for physical CPU controls.</p>
<p>Another techniques that prevent payload execution is related to <strong>the number of processors available on the machine</strong> that are required to be at least 2:</p>
<p><img src="https://lh7-us.googleusercontent.com/o9yejv6GNkWp4yTsJWF_PSOyxKHco5lfkCMLLGbIkkyVhKHHkWiJtv4JCppNsQZs0BBSBvuvFsInQg-4nrqrBH6_dzl65lzyV1cSeSWGzy2I0nRmkr6EK9CYRq3L_-g2V9RQQaOztA8bXIBfJN-WMZk" alt="Figure 3 - Call to GetSystemInfo for Processors‚Äôs checks"></p>
<p>Figure 3 - Call to GetSystemInfo for Processors‚Äôs checks</p>
<p>The last checks that have been identified are related to the Username and Computer Name that is currently used. In particular there are two matches that verify if the username corresponds to <strong>John Doe</strong> and then the <strong>ComputerName</strong> is equal to <strong>HAL9TH</strong>.</p>
<blockquote>
<p>It turns out that Microsoft Defender&rsquo;s Sandbox computername is HAL9TH, so, you can check for the computer name in your malware before detonation, if the name matches HAL9TH, it means you&rsquo;re inside defender&rsquo;s sandbox, so you can make your program exit.</p>
</blockquote>
<p><img src="https://lh7-us.googleusercontent.com/Jlr2e4g6gpjrrFi1uxvrWJZ2usZnGZR_smo3v1PEviMjw8kspy4PL0pm0kMozeRVi3I988gpt0tEvGmHN58pfFXHaw0m_i22FgHhcMnNixAfh-onZBxHmES16D6ZltkhiyEaWdLd7WFuFmLVQwRDZqQ" alt="Figure 4 - Checking for ‚Äúspecific settings‚Äù"></p>
<p>Figure 4 - Checking for ‚Äúspecific settings‚Äù</p>
<p>If one of those checks fails, the payload will call the function <strong>ExitProcess(0)</strong> terminating its execution.</p>
<h3 id="decryption-routine">Decryption routine</h3>
<p>As already mentioned, Vidar payload contains few encrypted strings to slow down the analysis and probably to evade few monitoring solutions. Because of that, there is a function that is in charge to retrieve the plaintext associated with each encrypted string.</p>
<p><img src="https://lh7-us.googleusercontent.com/O34JU_qxsazBuGRm4zbwGM8YimF1fGb1ppOvjoy_Freuwe95fHNFwWn-iaF28q__xg92YpjDPylvOZIeP0CvICtdoG7iYI5hyd5786JE4PXDgc8AwYOzLCpZq7lcY5w2MgXeMfuPSzdDTjrBLACNM00" alt="Figure 5 - Encrypted Strings"></p>
<p>Figure 5 - Encrypted Strings</p>
<p>The function it&rsquo;s fairly easy to spot especially observing the number of times it will be called and its signature (that recall a quite simple decryption procedure):</p>
<ul>
<li><strong>decryption_routine</strong>(encrypted_string , key , length)</li>
</ul>
<p>As expected the decryption routine it&rsquo;s not so hard to understand, in fact it iterates over the key length and performs an <strong>XOR</strong> operation between the <strong>encrypted_string</strong> and <strong>key</strong> parameters.</p>
<p><img src="https://lh7-us.googleusercontent.com/nEm9g0DmlIQNnO4HVGmAokxfV_MiWn1pgAX-XD3ut6Gy2nSIGY_IdTWmAVwb7iZVIMonhgdwGwqb1pxank2vEqReC50L5LnYPOfwlW7UrOzM5LiQ-3b67KZfgGEWcKuGNUYFgjErruihN5D0S0p6-VY" alt="Figure 6 - Decryption routine"></p>
<p>Figure 6 - Decryption routine</p>
<p><img src="https://lh7-us.googleusercontent.com/ztZ7Z6oxeCfGDB_ki1WvSAF-jChkBAyv00n-W0W3cfdjUzbuIeNMA4Y3TfatAuXwrZa07em1ps2j_47P3n5cdfaMiTGvG5hOSMx2sVe-R_IrkXl62zeTxT7FL4NLtAT7mlWq37cxgKKadxjxow1_nRE" alt="Figure 7 - String decrypted"></p>
<p>Figure 7 - String decrypted</p>
<p>It‚Äôs worth noting that IDA has few limitations, in fact sometimes it does not perform the proper variable renaming and due to the obfuscation implemented few instructions could be misinterpreted. Because of that an effective method to <strong>keep track of decrypted variables is to locate their offset and append a comment</strong>.</p>
<p>In that case, we should have a nice reference that could be used later on, to rename the variable accordingly. Keeping that in mind, it&rsquo;s possible to speed up our analysis by writing an <a href="https://viuleeenz.github.io/posts/2023/06/ida-python-locate-a-function-independently-from-its-offset/">IDA-python</a> script that takes care of those strings.</p>
<h3 id="fixing-functions">Fixing Functions</h3>
<p>As mentioned above, IDA sometimes could be confused by obfuscation that could lead to mis-interpret instructions or inhibit its ability to recognize a function. In fact, <strong>at the end of main</strong> there is a jump to a location that is not currently interpreted as a function. However, looking at strings and references to that text section there is clearly an error from the IDA interpreter.</p>
<p><img src="https://lh7-us.googleusercontent.com/_i129YO91RRHlKrIIzaqJSO77K63-3EjGKLWqMSwkXw96T_mWeO5lvgEC8RkFi8mpGQvtgaVhwgNbr3z__vbm3cZws9y4jgwq-qXoHt72h5gvEyxMRlszrabva2jI8e4nYMCn-n8vFvvrMfdRLXrqNw" alt="Figure 8 - Mis-intepreted function"></p>
<p>Figure 8 - Mis-intepreted function</p>
<p>To fix that, it‚Äôs possible to select the block of code and force IDA to treat that as a function. However, this practice it‚Äôs not always painless. In fact, it&rsquo;s still possible that we could get some issues from IDA that are not capable of interpreting all code correctly. An example is given from the figure below, where we have strings related to <strong>JUMPOUT</strong> and <strong>MEMORY</strong>.</p>
<p><img src="https://lh7-us.googleusercontent.com/9E5IDw_OiMauChtO3a8kmYcvag0cD-w8srPJduXSg_8niBztLjuwgX10a7wKUUCOgAmBSCaDdO4l8xqxGVsmjrifWZL-CeeHJiGoHb7zlZo8rREHqIihxtikMgHtUAV3VTz77mQ7VixYwiO5xJ-_UI0" alt="Figure 9 - Function interpreted as data"></p>
<p>Figure 9 - Function interpreted as data</p>
<p>This issue could be solved easily by fixing the byte related to the <strong>JUMPOUT</strong> instruction, however, in order to avoid losing focus on our main tasks, this issue will probably be discussed in a dedicated thread.</p>
<p>Nevertheless, we have now all pieces to complete our static analysis and go deep in all malicious activities related to this malware.</p>
<h2 id="additional-analysis">Additional Analysis</h2>
<p>String decryption was an effective method to extract IOCs from this Vidar sample. Examinig those strings we could see that, as expected, it works as an InfoStealer querying browser information (credentials on local storage) and multiple installed programs. At the time of writing, it supports most of the main used browsers, such as: Chrome, Firefox, Opera, Tor, etc.</p>
<p>Another interesting feature is related to the <strong>chrome extension</strong> checks feature, that aims to verify if specific extensions are actually installed. Mainly monitored extensions are related to <strong>crypto wallets</strong> and <strong>password managers</strong>.</p>
<p><img src="https://lh7-us.googleusercontent.com/aV7S2p8iQiUzjzkHNTFC0HLUbA1mJ7_gLJNYHEh_pmrpA39UtlOQEHpxUzdPLeMqPz6KX-tWZSGb7csNwhzTsXXiInuIO_cC29ZtN-Q3cmhRQ2qqKVwGUXJUHI6LUxc8eFGAdrBxl0lBTbfO8Yummd8" alt="Figure 10 - Monitored chrome extensions"></p>
<p>Figure 10 - Monitored chrome extensions</p>
<h2 id="network-communication">Network Communication</h2>
<p>According to the examined functions related to the network communication, it is possible to recreate the POST request structure that could be monitored and used as an indicator of compromise of this actor:</p>
<ul>
<li><strong>Content Disposition: form-data; name=&lt;Vidar_parameter&gt;</strong></li>
</ul>
<p>It‚Äôs worth mentioning that parameters observed are:</p>
<ul>
<li><strong>ID</strong> for BOT identification;</li>
<li><strong>HWID</strong> that uniquely identifies a machine (used for monitoring multiple infection from the same machine, indicating an analyzing attempts from researcher);</li>
<li><strong>Token:</strong> Exfiltrated token available on the victim‚Äô machine;</li>
<li><strong>File:</strong> An archive of all information gathered from the victim‚Äôs machine.</li>
</ul>
<p><img src="https://lh7-us.googleusercontent.com/yIAa0snonhSg0z1Th0EeZMkPMap6PnuZ3tueBAOL5KLjHWFMLc3150BY7KGaaCftMjiSg1IgEMYQmdCO8RwbTCV6d7gcNsMvph6KaWLLP54RtLpvsCTeORzZeY6QwCfpnrthNtTEkfiYf6gOGt_qBso" alt="Figure 11 - POST request structure"></p>
<p>Figure 11 - POST request structure</p>
<h2 id="references">References</h2>
<p>Sample:</p>
<ul>
<li>556f8b06b92ddbc4008dea5298eab3934c61647a1cd7333a9087c37cc5a75456 (SHA256)<a href="https://bazaar.abuse.ch/sample/556f8b06b92ddbc4008dea5298eab3934c61647a1cd7333a9087c37cc5a75456/">MalwareBazaar</a></li>
</ul>
<p>Ida-python scrypt:</p>
<ul>
<li><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/Vidar/ida_vidar_string_decrypt.py">ida_vidar_string_decrypt.py</a>
Microsoft Defender&rsquo;s Sandbox:</li>
<li>BlackHat 2018 <a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Bulazel-Windows-Offender-Reverse-Engineering-Windows-Defenders-Antivirus-Emulator.pdf">detailed analysis </a></li>
</ul>
<h2 id="iocs">IOCs</h2>
<ul>
<li>
<p>Network indicators</p>
<ul>
<li>https://t.]me/game4serv</li>
<li>https://steamcommunity.]com/profiles/76561199523054520</li>
<li>http://bigsnowstone.]com/</li>
</ul>
</li>
<li>
<p>Targets</p>
<table>
  <thead>
      <tr>
          <th>Browsers</th>
          <th>Browser Extensions - Wallets</th>
          <th>Authenticator/Password Manager</th>
          <th>Desktop Programs</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Mozilla Firefox</td>
          <td>TronLink</td>
          <td>Authenticator</td>
          <td>LevelDB</td>
      </tr>
      <tr>
          <td>Pale Moon</td>
          <td>Meta</td>
          <td>Authy</td>
          <td>Thunderbird</td>
      </tr>
      <tr>
          <td>Google Chrome</td>
          <td>BinanceChainWallet</td>
          <td>EOS Authenticator</td>
          <td>Telegram</td>
      </tr>
      <tr>
          <td>Chromium</td>
          <td>Yoroi</td>
          <td>GAuth Authenticator</td>
          <td>WinSCP</td>
      </tr>
      <tr>
          <td>Amigo</td>
          <td>NiftyWallet</td>
          <td></td>
          <td>IndexedDB</td>
      </tr>
      <tr>
          <td>Torch</td>
          <td>MathWallet</td>
          <td></td>
          <td>Steam</td>
      </tr>
      <tr>
          <td>Comodo Dragon</td>
          <td>Coinbase</td>
          <td></td>
          <td>Jaxx_Desktop</td>
      </tr>
      <tr>
          <td>Epic Privacy Browser</td>
          <td>Guarda</td>
          <td></td>
          <td>Binance Desktop</td>
      </tr>
      <tr>
          <td>Vivaldi</td>
          <td>EQUALWallet</td>
          <td></td>
          <td>Bitcoin Core</td>
      </tr>
      <tr>
          <td>CocCoc</td>
          <td>JaxxLiberty</td>
          <td></td>
          <td>Bitcoin Core Old</td>
      </tr>
      <tr>
          <td>Cent Browser</td>
          <td>BitAppWallet</td>
          <td></td>
          <td>Raven Core</td>
      </tr>
      <tr>
          <td>TorBro Browser</td>
          <td>iWallet</td>
          <td></td>
          <td>Ledger Live</td>
      </tr>
      <tr>
          <td>Chedot Browser</td>
          <td>Wombat</td>
          <td></td>
          <td>Blockstream</td>
      </tr>
      <tr>
          <td>Brave_Old</td>
          <td>MewCx</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>7Star</td>
          <td>GuildWallet</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>Microsoft Edge</td>
          <td>RoninWallet</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>360 Browser</td>
          <td>NeoLine</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>QQBrowser</td>
          <td>CloverWallet</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>Opera</td>
          <td>LiqualityWallet</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>OperaGX</td>
          <td>Terra_Station</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>CryptoTab Browser</td>
          <td>Keplr</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>Brave</td>
          <td>Sollet</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>AuroWallet</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>PolymeshWallet</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>ICONex</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>Harmony</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>EVER Wallet</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>KardiaChain</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>Trezor Password Manager</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>Rabby</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>Phantom</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>BraveWallet</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>PaliWallet</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>BoltX</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>Xdefi</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>Nami</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>MaiarDeFiWallet</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>WavesKeeper</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>Solflare</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>CyanoWallet</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>KHC</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>TezBox</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>Temple</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>Goby</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>RoninWalletEdge</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>Wasabi Wallet</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td></td>
          <td>Daedalus Mainnet</td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
</li>
</ul>
]]></content></item><item><title>Agent Tesla - Building an effective decryptor</title><link>https://Viuleeenz.github.io/posts/2023/08/agent-tesla-building-an-effective-decryptor/</link><pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2023/08/agent-tesla-building-an-effective-decryptor/</guid><description>&lt;h3 id="general-information-and-preface">General Information and preface&lt;/h3>
&lt;p>Agent Tesla, according to the &lt;a href="https://cert.europa.eu/static/threat-intelligence/TLP-CLEAR-CB-23-08.pdf">data&lt;/a> provided by CERT-EU, is one the most prominent threats that are hitting European cyberspace. Because of that, I found that it could be quite interesting understanding its behavior. However, as I usually prefer, instead of focusing on the infection chain or information about TA methodologies, sharing knowledge that were already provided by more authoritative sources, I preferred to focus mostly on malware analysis and in this specific case to the latest encryption algorithm adopted. Then, upon the knowledge acquired, I would like to write a decryptor script that extracts payload configuration.&lt;/p></description><content type="html"><![CDATA[<h3 id="general-information-and-preface">General Information and preface</h3>
<p>Agent Tesla, according to the <a href="https://cert.europa.eu/static/threat-intelligence/TLP-CLEAR-CB-23-08.pdf">data</a> provided by CERT-EU, is one the most prominent threats that are hitting European cyberspace. Because of that, I found that it could be quite interesting understanding its behavior. However, as I usually prefer, instead of focusing on the infection chain or information about TA methodologies, sharing knowledge that were already provided by more authoritative sources, I preferred to focus mostly on malware analysis and in this specific case to the latest encryption algorithm adopted. Then, upon the knowledge acquired, I would like to write a decryptor script that extracts payload configuration.</p>
<h3 id="encryption-variants">Encryption variants</h3>
<p>Agent Tesla first appeared in 2014, however, its evolution over time could be tracked by multiple TTPs. For the purpose of this article, I‚Äôm versioning it through the encryption algorithm adopted. At the time of writing there have been 4 different versions with unique characteristics:</p>
<p><strong>Encryption v1</strong>: Through this encryption implementation, strings are stored (encrypted) in base64. The decryption function uses a password and a salt ( both hardcoded) as input for the SHA1 algorithm, in order to generate the decryption key. Then, ciphertext and key are eventually used with AES in CBC mode.</p>
<p><strong>Encryption v2</strong>: The main difference from the previous method, is that each encrypted string is paired with a dedicated key and an IV. The algorithm used is still AES in CBC mode.</p>
<p><strong>Encryption v3</strong>: In this version, TA completely changed their approach, shifting to a pure <em>xor decryption</em>. The decryption function is defined within the <em>.cctor()</em> constructor. The structure of encrypted strings is quite simple. Each string is contained in a byte array paired with a key. The size of the ciphertext allows the decryption routine to iterate over the byte array distinguishing all parameters.</p>
<p><strong>Encryption v4</strong>: The latest version of Agent Tesla is based on a <em>xor string</em> algorithm that stores information within a macro-structure that contains raw data organized as follow:</p>
<p><img src="https://lh4.googleusercontent.com/rgMJHsQLR6JB0OjAGzCeIZGYJAEiuThnX5uPyZPB9ukmC7vPMclavaVnoQgB9G3tRnv8IOZ2Lvjbcav4pjEUS1uxqeF8fktYlITE4YsNZ9yLtgZJsmsQjCzjKvLfKA0oKT6hzNNZNWE3COKWp0Smm9k" alt="Figure 1: Encrypted data structure"></p>
<p>Figure 1 - Encrypted data structure</p>
<p>In this version we have a macro-struct that contains the encrypted data. It‚Äôs actually possible to visualize it as an array where each element follows a specific structure where the first 4 bytes are dedicated to define the encryption data length, then other 4 bytes are used to describe the encryption key and the remaining bytes are reserved for the actual data.</p>
<p>As always, the decryption routine iterates over the encrypted data, using key bytes.</p>
<h3 id="analysis-of-encryption-v4-and-obfuscation-routine">Analysis of encryption v4 and obfuscation routine</h3>
<p>As I wrote in the first paragraph Agent Tesla analysis will be carried out on the latest encryption mechanism. Because of that, let‚Äôs start analyzing the main components of this algorithm:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">byte</span>[] RXOR(<span style="color:#66d9ef">byte</span>[] data, <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">int</span> key)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>key = RandomNumberGenerator.GetInt32(<span style="color:#66d9ef">int</span>.MaxValue);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// RXOR Cipher: reverse array order and decrypt byte by byte using single XOR</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n = data.Length - <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; n; i++, n--)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>data[i] ^= data[n];
</span></span><span style="display:flex;"><span>data[n] ^= (<span style="color:#66d9ef">byte</span>) (data[i] ^ key);
</span></span><span style="display:flex;"><span>data[i] ^= data[n];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (data.Length % <span style="color:#ae81ff">2</span> != <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>data[data.Length &gt;&gt; <span style="color:#ae81ff">1</span>] ^= (<span style="color:#66d9ef">byte</span>) key; <span style="color:#75715e">// x &gt;&gt; 1 == x / 2</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> data;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The key is generated randomly through <strong>RandomNumberGenerator.GetInt32(int.MaxValue)</strong> function. The <em>int.MaxValue</em> constraint is related to the key size limitation of 4 bytes within the encrypted data structure. The algorithm it&rsquo;s pretty straightforward, performing <em>xor</em> between plaintext and key bytes. However, what really matters here is the <strong>obfuscator</strong> that happens at runtime.</p>
<p>The <strong>obfuscation routine</strong> is part of an open source <a href="https://github.com/dr4k0nia/XorStringsNET">project</a>. Basically, this obfuscation works creating multiple placeholders that are going to be replaced at runtime. Analyzing the sample statically, this technique messes up with code decompilers such as DnSpy. However, the author wrote a detailed <a href="https://dr4k0nia.github.io/posts/Encrypting-Strings-In-NET/">blogpost</a> explaining obfuscator features and its modus operandi:</p>
<blockquote>
<p>&ldquo;After processing all methods we need to do some patches in the injected runtime. First, we need to set up the placeholder struct with the correct attribute values. The struct needs a <strong>ClassLayout</strong> with <strong>packing size 1</strong> and the <strong>length of the encrypted data as its size</strong>.&rdquo;</p>
</blockquote>
<blockquote>
<p>&ldquo;We also need to create a new <strong>field which will be an initialized version of our struct</strong>. By adding a DataSegment in its <strong>FieldRva</strong>, we can use the field to store any raw data we want, in this case, our encrypted string data.&rdquo;</p>
</blockquote>
<p>Following the indication provided by the author, we should have a more clear idea of what these components are and how to hunt for them in the code. Now it‚Äôs possible to start looking at the code gathering as much information as possible (e.g., locating these placeholders) and finding out a pattern to write an effective configuration decryptor.</p>
<h3 id="binary-inspection">Binary inspection</h3>
<p>If we open up DnSpy, we could be overwhelmed by the mess that is going to be presented in front of us. However, trying to follow the code flow, we could start exploring.</p>
<p><img src="https://lh5.googleusercontent.com/zuONKbBX5bsAJ-9VLBUlNoqYkhrk3PdCdn3WHkNawFSZG6MvRT636ILfvDcipjFTT0GlhrCzBdbnxiDNMWsQpDpViMBIgFZFJZ1fhqZZJZdi_bi3lRoGkMNJ2pv16lful5B_TWsxw7m6nMatFOupgRw" alt="Figure 2: Entry point"></p>
<p>Figure 2 - Entry point</p>
<p>Starting from the Entry Point, it‚Äôs possible to locate something promising. Exploring variable and function calls and following references to the object <strong>GWZl2RFJ6nA</strong>, it&rsquo;s possible to bump into quite interesting piece of code.</p>
<p><img src="https://lh4.googleusercontent.com/U3w0tnCvmRyhyBt97-Pk36cwOrTPTGa6KoRQIWPwArHkdyJ8nwQZWrchT7r4dQiU7BbazIGGDoDYDl1wPIknrnyjdzR1ZZo4jC-mLGlcbqllKjfDRnBR8UdJOAU7UlPiHWo4Uzd48Hj-AY0tSpXuG48" alt="Figure 3: Obfuscated decryption routine"></p>
<p>Figure 3 - Obfuscated decryption routine</p>
<p>First of all, we see the function <strong>cpblk</strong> that it‚Äôs necessary to perform the injection at runtime, moreover, scrolling the code it&rsquo;s possible to get insight about pointer operations paired with xor. In fact, observing the line 104 in Figure 3, it is very similar to the encryption routine that we saw in the previous paragraph.¬† Nevertheless, on the top of that, as a final proof that we are looking in the right place, scrolling at the end of the code we see a class that fulfills all requirements requested by the obfuscator.</p>
<ul>
<li><strong>ClassLayout</strong></li>
<li><strong>Pack size = 1</strong></li>
<li><strong>Size = encrypted data length</strong></li>
</ul>
<p><img src="https://lh4.googleusercontent.com/SscVl6FW0XbBVt3px_oGIjxBChRw68fi7Zrez6Mumu_WF7sdJBsNRMVqrIqaXeIo-mPaMQf0V8VnILZKPbprhbATjKxIjhWxLwULyM9FngDrwEdjA2C09QVdog2oUeMjqfngeFViG5m6TJrDQqb37wA" alt="Figure 4 - Class placeholder for runtime decryption"></p>
<p>Figure 4 - Class placeholder for runtime decryption</p>
<p>Moreover, following the instruction provided by the author, we should be able to locate the encrypted string in raw bytes within the binary. If we have a closer look to struct <strong>zqRrwrwgu</strong> examining the raw value, we are redirected to a very suspicious sequence of bytes.</p>
<p><img src="https://lh3.googleusercontent.com/SGwLKd7RiZ-or8mXHPy7frC_MDAQgyn3RcHZ9sK_vs3jU_yReO3wmC_4le_AFu-l8jxsvGEF2Li5sgbNIa5ObmTDEjkJysNMQUrbwfhkGkESbwRg_gApWFALZmnSVnIyFpe412KCqGRwGy2ryp3H63o" alt="figure 5 - Encrypted String"></p>
<p>Figure 5 - Encrypted string</p>
<p>Analyzing those bytes, it&rsquo;s immediate to find out that we are dealing with an encrypted payload that is ready to be decrypted.</p>
<h3 id="decrypting-strings">Decrypting Strings</h3>
<p><strong>The idea behind this script is simple</strong>:</p>
<ul>
<li>Find out a class that is big enough to contain the encrypted data ( usually the biggest class in the code). Then we could retrieve raw bytes related to its size from the binary file and forward them towards our decryption routine</li>
</ul>
<p>Before proceeding, it&rsquo;s worth mentioning that I‚Äôm quite a newbie in .NET interaction with python and generally, I‚Äôm still learning .NET layout. Because of that, if someone else is going to produce more efficient code. Please do it! But for now, let‚Äôs do a quick look to this this script:</p>
<p><img src="https://lh6.googleusercontent.com/YgvfXQ1w_ggTUJ8u7Gd0oP5hPymmMYsmLFFVX0FmNoNx9oYpJ6ALMGdINsjWlQ3b25nzLXobQmcMt0-TmyWwVClZ28nHmJbO4Jmw92ck25uN-2A5XwGmtwx1EoTFYSugv8RD9JN9hn8liM6dALueaTY" alt="Figure 6 - Agent Tesla decryptor"></p>
<p>Figure 6 - Agent Tesla decryptor</p>
<ul>
<li><strong>Line 40 - 44:</strong> Gathered references to ClassLayout and FieldRVA Tables.</li>
<li><strong>Line 46 - 47:</strong> Following the initial idea that encrypted data should be stored in a quite large class, I started to enumerate class, selecting the biggest (likely the one that contains the encrypted strings)</li>
<li><strong>Line 51:</strong> retrieve the last element of the FieldRVA table that contains our data (I don‚Äôt know if it is an unexpected behavior caused by the obfuscation process applied, but the raw data containing the encryption string resulted to be always the last element of the FieldRVA table).</li>
</ul>
<p>Running our script on one of the latest Agent Tesla sample, we got the following result:</p>
<p><img src="https://lh3.googleusercontent.com/MtQZbbAOaz2HR4EEGvuVnAH2VoTzbz3P31VeZe0WPg_qMGpPuDOOQH7vn5jxriHiljyrfpK_3T_lejGWJ3Scwq1vNJDICyjvmkhZzI8g423d7e20_R8XSulLtXB9Db_-Si7wu5H6dPT95HPotd-BY7o" alt="Figure 7 - Decryptor result"></p>
<p>Figure 7 - Decryptor result</p>
<h3 id="references">References</h3>
<p>Agent Tesla Decryptor:</p>
<ul>
<li><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/AgentTesla/agent_tesla_decryptor_v4.py">agent_tesla_decryptor_v4.py</a></li>
</ul>
<p>DotNet references:</p>
<ul>
<li>General .NET implementation <a href="https://www.ntcore.com/files/dotnetformat.htm">info</a></li>
<li>Python <a href="https://github.com/pan-unit42/dotnetfile">parser</a> for .NET</li>
</ul>
<p>Samples:</p>
<ul>
<li>ae26382f191225447550e9a691453fc3ea2e02127222787c662efc8db63c59e3 (SHA256) <a href="https://bazaar.abuse.ch/sample/ae26382f191225447550e9a691453fc3ea2e02127222787c662efc8db63c59e3/">MalwareBazaar</a></li>
<li>acedd97c8350bacc485e87ae56c851d08b497c202deb46df28c3e7218cb4469a (SHA256) <a href="https://bazaar.abuse.ch/sample/acedd97c8350bacc485e87ae56c851d08b497c202deb46df28c3e7218cb4469a/">MalwareBazaar</a></li>
<li>f5751d89bc6f15c3ade6513d3cf44f92a25e8cd25d2f5ad239b8c44f8f732cb8 (SHA256)<a href="https://bazaar.abuse.ch/sample/f5751d89bc6f15c3ade6513d3cf44f92a25e8cd25d2f5ad239b8c44f8f732cb8">MalwareBazaar</a></li>
</ul>
]]></content></item><item><title>IDA-Python - Locate a function independently from its offset</title><link>https://Viuleeenz.github.io/posts/2023/06/ida-python-locate-a-function-independently-from-its-offset/</link><pubDate>Tue, 27 Jun 2023 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2023/06/ida-python-locate-a-function-independently-from-its-offset/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>Analyzing samples statically could be not an easy going taks, especially when you deal with heavily obfuscated or encrypted data. Because of that, it‚Äôs useful to find out the decryption/deobfuscation routine and write a little script that makes sense of strings or function names before starting to analyze the whole sample.&lt;/p>
&lt;p>The idea behind this technique was inspired by the infinite amount of tweaking I have made to run multiple Ida-python scripts that were heavily machine-setting dependents. The idea is very simple and it‚Äôs based on pattern matching as for YARA rules. The scope here is to create a kind of signature for a function that we would like to locate (e.g., deobfuscation routine) and apply its execution to its parameters in order to simplify our analysis &lt;strong>without tweaking specific parameters&lt;/strong> making it &lt;strong>independent from the function offset&lt;/strong>. I have already got good results experimenting with malware samples (e.g, Qbot) and custom binaries from CTFs as well as other samples that used some sort of obfuscation. Because of that, I decided to create this post to share this approach that could be useful for writing better scripts.&lt;/p></description><content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Analyzing samples statically could be not an easy going taks, especially when you deal with heavily obfuscated or encrypted data. Because of that, it‚Äôs useful to find out the decryption/deobfuscation routine and write a little script that makes sense of strings or function names before starting to analyze the whole sample.</p>
<p>The idea behind this technique was inspired by the infinite amount of tweaking I have made to run multiple Ida-python scripts that were heavily machine-setting dependents. The idea is very simple and it‚Äôs based on pattern matching as for YARA rules. The scope here is to create a kind of signature for a function that we would like to locate (e.g., deobfuscation routine) and apply its execution to its parameters in order to simplify our analysis <strong>without tweaking specific parameters</strong> making it <strong>independent from the function offset</strong>. I have already got good results experimenting with malware samples (e.g, Qbot) and custom binaries from CTFs as well as other samples that used some sort of obfuscation. Because of that, I decided to create this post to share this approach that could be useful for writing better scripts.</p>
<p>Generally speaking, approaching to these sample could be done through multiple perspective (e.g., starting with dynamic analysis and proceeding backwards), however, for the purpose of this blogpost I‚Äôm going to take a custom sample written by me, where strings are partially obfuscated with custom algorithm and I‚Äôm going to show an easy but effective method to write an ida-python script to <strong>locate and deobfuscate variables</strong>.</p>
<h2 id="practical-example">Practical example</h2>
<p>First go first. In order to deobfuscate a piece of code, it&rsquo;s still required to analyze the function that is going to perform this task and replicate its behavior implementing it within our script. For the purpose of this post, this step is out of scope, however, I‚Äôm going to directly analyze the assembly code in order to find out how to write the IDA-python script to collect all obfuscated variables to apply the proper routine.</p>
<p>The steps that we are going are pretty much the following:</p>
<ul>
<li>Find out the deobfuscation function;</li>
<li>Create a ‚Äúsignature‚Äù to retrieve all its references;</li>
<li>Collect the obfuscated parameters;</li>
<li>Apply the deobfuscation routine;</li>
</ul>
<h2 id="creating-function-signature">Creating function signature</h2>
<p>Since that sample it&rsquo;s actually very easy, finding the proper function it‚Äôs not so tricky. In fact, we could see that there is a DWORD that is going to be passed to a function called ‚Äú<strong>DeobfuscateString</strong>‚Äù. However, what really matters here, is to create a signature of this function in order to locate it in multiple samples, independently from the offset that is going to be loaded.</p>
<p><img src="/img/ida_python/function_overview.png" alt="Figure 1 - Main function overview">
Figure 1 - Main function overview</p>
<p>To do so, it&rsquo;s possible to open the <strong>text</strong> view and explore the function to collect a few bytes that could be useful for this signature-like phase. I have chosen to get something related to the <strong>strcspn</strong> function that is part of the deobfuscation routine. More precisely, I have chosen to gather 16 bytes (<strong>8D 55 E0 52 8D 45 E4 50 FF 15 CC 20 40 00</strong>).</p>
<p><img src="/img/ida_python/deob_function.png" alt="Figure 2 - Deobfuscation routine">
Figure 2 - Deobfuscation routine</p>
<p>Now we could try to find out if our collected bytes are enough to identify this function. Let‚Äôs write a little script that checks this out.</p>
<h2 id="searching-for-the-function-characteristics">Searching for the function characteristics</h2>
<p>The first thing to do is to gather the <strong>.text</strong> segment and then, start to look for our signature. One of the easiest ways to get the segment requested is to iterate over all segments until the <strong>idc.get_segm_name</strong> contains the ‚Äú<strong>.text‚Äù</strong> name:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_text_segment</span>(seg_name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;.text&#34;</span>):
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> idautils<span style="color:#f92672">.</span>Segments():
</span></span><span style="display:flex;"><span>  start <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>get_segm_start(s)
</span></span><span style="display:flex;"><span>  end <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>get_segm_end(s)
</span></span><span style="display:flex;"><span>  name <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>get_segm_name(s)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> name <span style="color:#f92672">==</span> seg_name:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> start, end
</span></span></code></pre></div><p>Then, we should write a function that is capable to locate our signature:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">patternSearch</span>(address_start, address_end):
</span></span><span style="display:flex;"><span>    pattern <span style="color:#f92672">=</span> idaapi<span style="color:#f92672">.</span>compiled_binpat_vec_t()
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> idaapi<span style="color:#f92672">.</span>parse_binpat_str(
</span></span><span style="display:flex;"><span>        pattern,
</span></span><span style="display:flex;"><span>        address_start,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;8D 55 E0 52 8D 45 E4 50 FF 15 CC 20 40 00&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">16</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> res <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;[!] Pattern not Found&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        ea <span style="color:#f92672">=</span> idaapi<span style="color:#f92672">.</span>bin_search(address_start, address_end, pattern, idaapi<span style="color:#f92672">.</span>BIN_SEARCH_CASE)
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;[+] Pattern found at: </span><span style="color:#e6db74">{0}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(hex(ea)))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ea
</span></span></code></pre></div><p>At first glance this code could seem a mess, but it‚Äôs easier than expected. Let‚Äôs do a deep dive. The parameters <strong>address_start</strong> | <strong>address_end</strong> are related to the text segment, since we are looking for the signature within the whole segment space. To understand the parameters passed to <strong>idaapi.parse_binpat_str</strong>, we could refer to its <a href="https://www.hex-rays.com/products/ida/support/idapython_docs/ida_bytes.html">documentation</a>. However, for interruption its signature is given here:</p>
<blockquote>
<p><strong>parse_binpat_str(out, ea, _in, radix, strlits_encoding=0) -&gt; str</strong> (the odd variable could be represented by the out parameter. However it represents a vector of compiled binary patterns, that will be later used with bin_search()). Running those functions together it‚Äôs possible to observe few references related to the deobfuscation string used within the <strong>.text</strong> segment, then if we look for those references in IDA we could see that with those few bytes we were able to get all we needed to move forward to collect all the obfuscated parameters.</p>
</blockquote>
<p><img src="https://lh5.googleusercontent.com/4gWjUL1uVbmX1aIjD6h6emg_1IjrTWq7m9I8iUt5oaI7sOwSddMLk9LJj9usj0Zo4OeMkQfAIf8sqBzkwRJwXB_-7_adbxB0V3YZCtk_QS7Ar4ykqA1ovZYgEgDhEAniCKz569KUV5jBsiQw8VoQPSQ" alt="Figure 3 - Code reference of deobfuscation routine">
Figure 3 - Code reference of deobfuscation routine</p>
<h2 id="collecting-parameters">Collecting parameters</h2>
<p>Now we have tested that our script successfully identifies the function within the <strong>.text</strong> segment, however, before proceeding collecting its parameters, it is important to also get information related to its usage. To do so, we could use the returning value from the <strong>bin_search</strong> function and use them as a parameter for <strong>idaapi.get_func()</strong> that will return the addresses where our deobfuscation routine is actually used. As a final step to locate all its references it‚Äôs possible to use the function <strong>idautils.XrefsTo</strong> as follow:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">locate_decrypt_function</span>(function_address):
</span></span><span style="display:flex;"><span>    xref_list <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> xref <span style="color:#f92672">in</span> idautils<span style="color:#f92672">.</span>XrefsTo(function_address):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> xref<span style="color:#f92672">.</span>frm <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> xref_list:
</span></span><span style="display:flex;"><span>            xref_list<span style="color:#f92672">.</span>append(xref<span style="color:#f92672">.</span>frm)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> list(xref_list)
</span></span></code></pre></div><p>Through this method I‚Äôve just created a list that is going to contain all function references. From that list, it is possible to iterate all over the function call and retrieve the obfuscated string.</p>
<p><img src="https://lh6.googleusercontent.com/oeQLy6NE6GfIe-DTLErQgVmQwSBzaCf-EM5DB666-y--7RES2yKOYnQXaTQ8evd24clMhEvmhiKXYQvMUSohzaTWMmgqigSMNu74lr-6czaTyxRp8VL7mR82Ge9JKdXQq6FWMYOMb7dcSmGR91OdN_0" alt="Figure 4 - finding function code and its usage">
Figure 4 - finding function code and its usage</p>
<p>Now, in order to find out the parameters, it‚Äôs necessary to observe the pattern used by this sample to understand how to collect the obfuscated string. Observing all the occurrences retrieved, it‚Äôs possible to create a function that retrieves all parameters named ‚Äúoffset‚Äù with mnemonic push (opcode <strong>68</strong>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">gather_string_offset</span>(xref_address):
</span></span><span style="display:flex;"><span>    function_start <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>get_func_attr(xref_address, FUNCATTR_START)
</span></span><span style="display:flex;"><span>    new_address <span style="color:#f92672">=</span> xref_address
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>        prev_address <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>prev_head(new_address)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> prev_address <span style="color:#f92672">&lt;=</span> function_start:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> idc<span style="color:#f92672">.</span>print_insn_mnem(prev_address) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;push&#34;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> idc<span style="color:#f92672">.</span>print_operand(prev_address,<span style="color:#ae81ff">0</span>)<span style="color:#f92672">.</span>split()[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;offset&#34;</span>: 
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> idc<span style="color:#f92672">.</span>get_operand_value(prev_address, <span style="color:#ae81ff">0</span>) 
</span></span><span style="display:flex;"><span>        new_address <span style="color:#f92672">=</span> prev_address
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;[!] Offset not found.&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span></code></pre></div><p>The function presented here, it‚Äôs pretty straightforward. It takes the <strong>fucntion_start</strong> parameters that represents the function block that contains the instruction <strong>call DeobfuscateString</strong> (since the code it‚Äôs all written within the main function, <strong>fucntion_start</strong> will be the first instruction in the main. However, in other example our DeobfuscateString function could be part of another subroutine and in that case, the function_start will point to the first instruction of that routine ) Then, from the function the instruction call DeobfuscateString, we start to move backward in order to find out the <strong>offset</strong> parameter that will point to our obfuscated string. It‚Äôs worth mentioning that the code <strong>prev_address &lt;= function_start it‚Äôs used to avoid going over the main function boundaries</strong> (it doest make any sense to go backward over that line, since our code should be located there).</p>
<p>Now that we have collected all string references related to each call, we are still required to get the whole obfuscated string. In fact, through our code we were able to get the first byte of each string but it‚Äôs required to get the whole reference to forward the string to the deobfuscation routine:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">retrive_string</span>(offset):
</span></span><span style="display:flex;"><span>    obfuscated_string <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> chr(idaapi<span style="color:#f92672">.</span>get_byte(offset <span style="color:#f92672">+</span> counter)) <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span>:
</span></span><span style="display:flex;"><span>        obfuscated_string <span style="color:#f92672">+=</span> chr(idaapi<span style="color:#f92672">.</span>get_byte(offset <span style="color:#f92672">+</span> counter))
</span></span><span style="display:flex;"><span>        counter <span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> obfuscated_string
</span></span></code></pre></div><p>The script here, takes the first string byte and it starts to move forward until a NULL byte it‚Äôs located (In this case, the null byte represents the end of our string).</p>
<h2 id="deobfuscation-function">Deobfuscation function</h2>
<p>After retrieving the string, it‚Äôs a matter of implementing the deobfuscation routine and applying it to the collected strings. Implementation details are left as an exercise for curious reversers that would like to make it on their own. Since implementation of this specific case it‚Äôs actually pointless for a real case scenario, it will be skipped from this article and will be directly implemented within the final IDA-python script.</p>
<h2 id="script-testing">Script Testing</h2>
<p>To run our script it‚Äôs possible to go in <em>File &gt; Script</em> <em>file</em>, selecting the proper <em>ida_python</em> script. Testing the script in IDA, it&rsquo;s possible to observe that all obfuscated strings have been correctly deobfuscated and a little comment has been added to the end of each string reference.</p>
<p><img src="https://lh6.googleusercontent.com/CZC2L6z-Ie0G8mb6v0Nutciep3hXx7AerWk-c6vr52u1QyEIicO-E76156SnByknVj8_JtB-m2lZCxuSB_NBst6miGqVh8vcz3zNg81m4raC4QCVV1can-KqGLdLRNp5YH1IzPm9MzhEANTWX-J4XFY" alt="Figure 5 - Variable deobfuscated successfully">
Figure 5 - Variable deobfuscated successfully</p>
<h2 id="conclusion">Conclusion</h2>
<p>This post has been written to illustrate an effective and quite useful technique to locate interesting functions within a binary and to write a custom IDA-python script that is capable of finding all function occurrences. This approach it‚Äôs actually very helpful also to avoid configuration dependencies, giving to our script the ability to be shared <strong>without tweaking specific parameters</strong> that could rely on IDA instances.</p>
<h3 id="references">References</h3>
<ul>
<li>Ida-python script: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/IDA-python/function_search/fSearch.py">fSearch.py</a></li>
<li>source code: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/IDA-python/function_search/test/obfuscation.c">obfuscation.c</a></li>
<li>compiled sample: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/IDA-python/function_search/test/obfuscation.exe">obfuscation.exe</a></li>
</ul>
]]></content></item><item><title>Extracting DDosia targets from process memory</title><link>https://Viuleeenz.github.io/posts/2023/05/extracting-ddosia-targets-from-process-memory/</link><pubDate>Mon, 08 May 2023 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2023/05/extracting-ddosia-targets-from-process-memory/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>This post is part of an analysis that I have carried out during my spare time, motivated by a friend that asked me to have a look at the DDosia project related to the NoName057(16) group. The reason behind this request was caused by DDosia client changes for performing the DDos attacks. Because of that, all procedures used so far for monitoring NoName057(16) activities did not work anymore.&lt;/p>
&lt;p>Before starting to reverse DDosia Windows sample, I preferred to gather as much information as possible about NoName057(16) TTPs and a few references to their samples.&lt;/p></description><content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>This post is part of an analysis that I have carried out during my spare time, motivated by a friend that asked me to have a look at the DDosia project related to the NoName057(16) group. The reason behind this request was caused by DDosia client changes for performing the DDos attacks. Because of that, all procedures used so far for monitoring NoName057(16) activities did not work anymore.</p>
<p>Before starting to reverse DDosia Windows sample, I preferred to gather as much information as possible about NoName057(16) TTPs and a few references to their samples.</p>
<p><a href="https://decoded.avast.io/martinchlumecky/ddosia-project-how-noname05716-is-trying-to-improve-the-efficiency-of-ddos-attacks/">Avast</a> wrote a very detailed article about that project and described thoroughly all changes observed in the last few months. Because of that, before proceeding with this post, If you feel you are missing something, I strongly¬† recommend that you read their article.</p>
<h2 id="client-setup">Client Setup</h2>
<p>According to the information retrieved from the Telegram channel of DDosia Project, there are a couple of requirements before executing the client. The very first action is to create your id through a dedicated bot that will be used later on for authentication purposes. After that, it&rsquo;s necessary to put the client_id.txt file (generated from DDosia bot) and the executable file in the same folder. If everything has been done properly, it should be possible to observe that authentication process will be done correctly and the client is going to download targets from its server:</p>
<p><img src="/img/ddosia/c_a.png" alt="Figure 1: Client authenticated correctly"></p>
<p>Figure 1: Client authenticated correctly</p>
<h2 id="dynamic-analysis-and-process-memory-inspection">Dynamic analysis and process memory inspection</h2>
<p>Here we are with the fun part. Because of the issues of analyzing GO binaries statically, I preferred to use a dynamic approach supported by Cape sandbox. In fact, executing the client with Cape it was possible to gather behavioral information to speed up our analysis (<a href="https://capesandbox.com/analysis/385183/">ref</a>). Since the executable is going to be used for DDoS attacks, it&rsquo;s easy to expect that most of the functions are related to network routines. One of the most interesting WindowsAPI refers to <a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsastartup">WSAStartup</a>. This is interesting for us, because according to Microsoft documentation, it must be the first function to be used in order to retrieve socket implementation for further network operations:</p>
<blockquote>
<p>The WSAStartup function must be the first Windows Sockets function called by an application or DLL. It allows an application or DLL to specify the version of Windows Sockets required and retrieve details of the specific Windows Sockets implementation. The application or DLL can only issue further Windows Sockets functions after successfully calling WSAStartup.</p>
</blockquote>
<p>Moreover, starting to monitor network requests with Wireshark, give us additional information about client-server interactions and targets retrieving procedure:</p>
<p><img src="/img/ddosia/network_communication.png" alt="Figure 2 - Request for target list"></p>
<p>Figure 2 - Request for target list</p>
<p>As already mentioned on Avast blogspot, the target list is encrypted and retrieved after the authentication process. However, performing DDoS attacks requires a decryption routine to make targets in cleartext and forward them to a proper procedure. With this insight, it‚Äôs possible to open up a debugger and set a breakpoint of WSAStartup and start exploring the process flow from that point.</p>
<p><img src="/img/ddosia/control_flow.png" alt="Figure 3 - Exploring DDosia executable control flow"></p>
<p>Figure 3 - Exploring DDosia executable control flow</p>
<p>Exploring the process execution, it‚Äôs possible to observe that <strong>WSAStartup API is called two times before starting the attack.</strong> The first one has been used from the main thread to perform the authentication process on the server side, instead the second call will be done right after retrieving the target file and it will be used from another thread to start the attack phase. Since that information we are looking for has been already downloaded and hopefully decrypted (at the time of the second call) we could explore the process memory trying to identify our target list.</p>
<p><img src="/img/ddosia/cleartext_targets.png" alt="Figure 4 - Target stored in cleartext within process memory">
Figure 4 - Target stored in cleartext within process memory</p>
<p>As we expected, information is actually decrypted right before being used from threads that are in charge to flood the targets. From the cleartext sample, it‚Äôs also possible to reconstruct the original json file structure that follow this format:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{<span style="color:#f92672">&#34;target_id&#34;</span>:<span style="color:#e6db74">&#34;435te3af574b95e395847362&#34;</span>,<span style="color:#f92672">&#34;request_id&#34;</span>:<span style="color:#e6db74">&#34;23cer8c5mmp4434dlad53f2s&#34;</span>,<span style="color:#f92672">&#34;host&#34;</span>:<span style="color:#e6db74">&#34;www.tartuhly.ee&#34;</span>,<span style="color:#f92672">&#34;ip&#34;</span>:<span style="color:#e6db74">&#34;90.190.99.85&#34;</span>,<span style="color:#f92672">&#34;type&#34;</span>:<span style="color:#e6db74">&#34;http&#34;</span>,<span style="color:#f92672">&#34;method&#34;</span>:<span style="color:#e6db74">&#34;GET&#34;</span>,<span style="color:#f92672">&#34;port&#34;</span>:<span style="color:#ae81ff">443</span>,<span style="color:#f92672">&#34;use_ssl&#34;</span>:<span style="color:#66d9ef">true</span>,<span style="color:#f92672">&#34;path&#34;</span>:<span style="color:#e6db74">&#34;/otsi/$_1&#34;</span>,<span style="color:#f92672">&#34;body&#34;</span>:{<span style="color:#f92672">&#34;type&#34;</span>:<span style="color:#e6db74">&#34;&#34;</span>,<span style="color:#f92672">&#34;value&#34;</span>:<span style="color:#e6db74">&#34;&#34;</span>},<span style="color:#f92672">&#34;headers&#34;</span>:<span style="color:#66d9ef">null</span>}
</span></span></code></pre></div><p>At this point I have shown all procedures to quickly follow the execution flow until the decryption routine is called. From now on, it&rsquo;s just a matter of looking for those data within process memory and extracting them for your own purpose. It‚Äôs worth noting that information won‚Äôt be stored decrypted forever, in fact, as the executable keeps running, the json file is actually mangled in a way that is not easy to resemble it properly.</p>
<h2 id="a-little-bit-of-automation">A little bit of automation</h2>
<p>Even if the analysis has been completed and targets are correctly retrieved, I thought that giving a little tool to extract that information would be useful. Instead of doing complex stuff, I wrote two simple scripts called targets.js and recover.py. The purpose of these two files is to allow analysts from different backgrounds to extract those targets, even performing a simple memory dump. Probably there are easier and smarter techniques out there, but it was also a good chance to put in practice DBI, which I have already covered in a previous <a href="https://viuleeenz.github.io/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/">post</a>.</p>
<ul>
<li>
<p><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/DDosia_Targets/targets.js">target.js</a>: Frida script that aims to get a memory dump after the WSAStartup has been called for the second time (when payloads are in cleartext in memory).</p>
</li>
<li>
<p><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/DDosia_Targets/recover.py">recover.py</a>: it‚Äôs a simple python script that retrieves structured information from the files dumped. It‚Äôs worth noting that I limited my script to look for structured information, retrieving IP and Hostname (additional improvements are left to user‚Äôs needs).</p>
</li>
</ul>
<h2 id="script-testing">Script Testing</h2>
<p>In order to run the mentioned scripts there are two requirements to fulfill:</p>
<ul>
<li>Installing frida-tool (pip install frida-tools).</li>
<li>Create a folder named ‚Äúdumps‚Äù in the same place where you run the target.js file.</li>
</ul>
<p>If all requirements are satisfied it‚Äôs just a matter of running those scripts and getting the results. The first step is to run frida.exe, using the targets.js file that contains all the information to dump the process memory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>frida.exe &lt;ddosia_client.exe&gt;  -l targets.js
</span></span></code></pre></div><p>If everything has been done correctly (please keep in mind the requirements), you should be able to see a message ‚Äú[END] Memory dumped correctly‚Äù in your console.</p>
<p><img src="/img/ddosia/frida_dump.png" alt="Figure 5 - Dumping process Memory with Frida"></p>
<p>Figure 5 - Dumping process Memory with Frida</p>
<p>Now you can navigate in dumps folder and run the python script using the following command line that is going to forward all dumped file from the current directory to the script that is going to print the result in your console:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>python.exe recover.py (Get-Item .\*dump)
</span></span></code></pre></div><p><img src="/img/ddosia/target_extraction.png" alt="Figure 6 - Extracting DDosia targets from dumped files"></p>
<p>Figure 6 - Extracting DDosia targets from dump files</p>
<h2 id="final-notes">Final Notes</h2>
<p>Before concluding, It‚Äôs worth mentioning that updates on these scripts and new techniques to dealing with further improvements of DDosia project are not going to be shown, because it represents a topic that I‚Äôm not following personally and I‚Äôm sure that more authoritative voices will keep track of this threat and its evolution.</p>
<hr>
<h3 id="2023-11---update-">[2023-11 - UPDATE ]</h3>
<p>As mentioned in the section above I‚Äôm not able to provide updates on real-time DDosia Project changes, but since it represents a quite good challenge to sharpen my reversing skills on GO binaries (and I received unexpected feedback about this work), I decided to look in their new Windows client version.</p>
<p>Since I would like to keep this update note as brief as possible, I‚Äôll go straight to the point. What really changes and makes the previous frida script ineffective are slightly binary improvements (mostly related to the syscalls used). Because of that I tried to switch monitored syscall to <a href="https://learn.microsoft.com/en-us/windows/console/writeconsole"><strong>WriteConsoleW</strong></a>, hooking on the message that confirmed the numbers of targets retrieved. I found out that I really needed to change 1 line of the previous script to keep it updated. (Great example of code reuse xD).</p>
<h3 id="note"><strong>Note:</strong></h3>
<p>The modification required was pretty easy, however, this change could be also more consistent for further updates (limiting to tweak a little bit with counter variable) since it exploits the feedback messages (e.g., target acquired, requests completed, rewards, etc..) that won‚Äôt be removed any time soon.</p>
<p>Moreover, most of this blogpost it&rsquo;s still a valid reference for setting up the environment and understanding the control flow to retrieve the actual targets, additionally, as far as I know, there were no great changes on the authentication layer. Previous configured environments needs to replace the old binary to the newer provided on DDosia channel.</p>
<ul>
<li>New frida script: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/DDosia_Targets/console.js">console.js</a></li>
</ul>
<hr>
<h3 id="references">References:</h3>
<table>
  <thead>
      <tr>
          <th>FileName</th>
          <th>Sha256</th>
          <th>Date</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><a href="https://www.virustotal.com/gui/file/726c2c2b35cb1adbe59039193030f23e552a28226ecf0b175ec5eba9dbcd336e">d_windows_amd64.exe</a></td>
          <td>726c2c2b35cb1adbe59039193030f23e552a28226ecf0b175ec5eba9dbcd336e</td>
          <td>2023/04/19</td>
      </tr>
      <tr>
          <td>(new sample) <a href="https://www.virustotal.com/gui/file/1b53443ebaabafd6f511d4cf7cb85ddf9fa32540c5dd5621f04a3c5eefa663a9">d_win_x64.exe</a></td>
          <td>1b53443ebaabafd6f511d4cf7cb85ddf9fa32540c5dd5621f04a3c5eefa663a9</td>
          <td>2023/11/09</td>
      </tr>
  </tbody>
</table>
]]></content></item><item><title>Dynamic Binary Instrumentation for Malware Analysis</title><link>https://Viuleeenz.github.io/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/</link><pubDate>Tue, 14 Mar 2023 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/</guid><description>&lt;h2 id="introduction">&lt;strong>Introduction&lt;/strong>&lt;/h2>
&lt;p>Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary.&lt;/p></description><content type="html"><![CDATA[<h2 id="introduction"><strong>Introduction</strong></h2>
<p>Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary.</p>
<p>Since I would like to skip redundant topics that are already written all over the internet by people that are Jedi in this field, I‚Äôm going to limit this post linking references that would be nice to have to understand everything easily.</p>
<ul>
<li><a href="https://frida.re/docs/javascript-api/">Frida</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">Windows API</a></li>
<li><a href="https://research.checkpoint.com/2020/gozi-the-malware-with-a-thousand-faces/">Ursnif/Gozi</a></li>
</ul>
<h2 id="intercepting-function-calls"><strong>Intercepting function calls</strong></h2>
<p>Most of the time, malware, in order to write memory and run code from the newly allocated space, make use of two functions, such as: <strong>VirtualAlloc</strong> (<a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">ref.</a>) and <strong>VirtualProtect</strong> (<a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">ref</a>.). For the purpose of our task, I have chosen the VirtualProtect function, because at the time of its calling, the data (payload) should be already there and it would be easier to analyze.</p>
<p>So let‚Äôs start to write out the code that retrieves the <strong>reference</strong> of this function and the interceptor that is going to be used to monitor function calls entry and return. Thanks to Frida, it is possible to directly retrieve function arguments through the variable <strong>args</strong> and check their values. The most important parameter and the one that will be used for our purpose is the <strong>lpAddress</strong> that represents the address space that is involved in this function call.</p>
<p><img src="https://lh3.googleusercontent.com/mra9ne7fbva4FUzxVzhFwTz2QWCiv3W5nM6SvVJT-fMqx2VoyXA-SMrFV_5yx6mVkbWUiLNg9Xxx-c_uEuMRGFrVCGRDp5Cg7cPOOQ9V6lBUu592qFLb4ebOsaVA8ra1ykjAxnhz6F4nbZDjU-RwZqc" alt="Figure 1 - References to VirtualProtect and call Interceptor"></p>
<p>Figure 1 - References to VirtualProtect and call Interceptor</p>
<p>Because of the purpose of the article we are not interested in all <strong>VirtualProtect</strong> calls but we would like to limit our scope to ones that contain a PE header.¬† To do this, it&rsquo;s possible to verify if <strong>lpAddress</strong> starts with ‚Äú<strong>MZ</strong>‚Äù or ‚Äú<strong>5d4a</strong>‚Äù. If so, we could print out some values in order to check them against the running executable using tools such as <strong>ProcessMonitor</strong> or <strong>ProcessHacker</strong>.</p>
<p><img src="https://lh6.googleusercontent.com/YwJkMozUWoo0bIKWP2QTX_Fr18F3LdGhRu4P2AznmONaPx305jNoDDQRHaAeHQExP96jrpxPjM6QDjxJ2IlFQfaN5oIbAYPImYP-Wq7JalzBHtuPWvcDBptVWvbiInjyAtFl5NUEE9XXvjsV8gE6Vkk" alt="Figure 2 - Printing VirtualProtect arguments"></p>
<p>Figure 2 - Printing VirtualProtect arguments</p>
<h2 id="retrieving-the-payload"><strong>Retrieving the payload</strong></h2>
<p>Now comes the tricky part. If we simply apply this technique to dump the memory that contains the <strong>MZ</strong>, it would be possible for us to also dump the binary that we originally started the infection with. However, analyzing Ursnif code, it&rsquo;s possible to see that it creates a dedicated memory space to write its final stage that is commonly referenced as a DLL. In order to avoid that, it&rsquo;s possible to use a function <em>findModuleByAddress</em> that belongs to the <em>Process</em> object.</p>
<p>As reported by Frida documentation:</p>
<blockquote>
<p>Process.findModuleByAddress(address) returns a <strong><a href="https://frida.re/docs/javascript-api/#module"><code>Module</code></a></strong> whose <em>address</em> or <em>name</em> matches the one specified. In the event that no such module could be found, the <em>find</em>-prefixed functions return <em>null</em> whilst the <em>get</em>-prefixed functions throw an exception.</p>
</blockquote>
<p>In order to avoid exception handling stuff I have preferred to go with find prefix function and then checking if the Module returned is equal to null. Otherwise, we would have an existing module object and¬† module.base = image base.</p>
<p>Now, as a final step before moving on and dumping the actual payload, it&rsquo;s necessary to retrieve the page size to which¬† <strong>lpAddress</strong> belongs. That information could be retrieved using the findRangeByAddress that¬† return an object with details about the range (memory page) containing address.</p>
<p><img src="https://lh4.googleusercontent.com/disgHE5VRs6Ob1F0hCt2bKCsfuc3AsxUFViJkqkf_EfYYCmpsiUOILazwCz6asBUsj3paJZ5Libw9N0dYYGSzY60PQRmukGzwFTDfkONM_V2McgqX69kVVlUzrRksfiuM48oDS_GzsPzMQA9gz_GN5E" alt=" Figure 3 - Checking for payload address"></p>
<p>Figure 3 - Checking for payload address</p>
<h2 id="dumping-config-file"><strong>Dumping config file</strong></h2>
<p>Now that we have all the information required, it‚Äôs time to dump the actual Ursnif payload. In order to do this, it&rsquo;s possible to read the page related to <strong>lpAddress</strong> using the <em>readByteArray</em> using the <strong>module.size</strong>. Once the information has been stored, it‚Äôs possible to write it in a file that could be used later on for further manipulation and analysis.</p>
<p><img src="https://lh3.googleusercontent.com/ju4MZv16hQgyeT6Si6wn_Y6-ble6sl4Oq8L2Jx93vCt3OpxmJBjDvdRCDD9yDVsUIRueQSPksuWVEMsxNUppGE1DsNM5F_PGdanWV4_wqOSuNpUnst2UdLT7emcpaaJMYuLigwBKRvHzuTyY86E3q2U" alt=" Figure 4 - Dumping Ursnif payload"></p>
<p>Figure 4 - Dumping Ursnif payload</p>
<p>It‚Äôs worth noting that before proceeding with the configuration extraction phase, it‚Äôs necessary to modify <code>Raw addresses</code> and <code>Virtual Addresses</code> of each section¬† header accordingly. This step is necessary because the payload was extracted directly from memory.</p>
<h2 id="script-testing"><strong>Script Testing</strong></h2>
<p>Now that we have completed our script it&rsquo;s time for testing with a real case! Let‚Äôs take one of the recent samples delivered by the TA and see if it works. For this example I have chosen a publicly available sample on <a href="https://bazaar.abuse.ch/sample/83ece9c5d6ffe0e99276becec96bc1c181a731ebd2fb95eaef329d2fbbec7271/">MalwareBazar</a>.</p>
<p>Running the script against this sample with Frida as follow:</p>
<p><code>frida.exe &lt;mal_executable&gt; -l &lt;your_script.js&gt;</code></p>
<p>It will produce a file called <strong>0x2cf0000_mz.bin</strong> (it may vary from the memory address allocation on your machine).</p>
<p><img src="/img/dbi/extractionWithFrida.png" alt="Figure 5 - Ursnif payload extraction with Frida"></p>
<p>Figure 5 - Ursnif payload extraction with Frida</p>
<p>If we open this file with PE-Bear, what should alert us, is the import table that contains unresolved information. This happens, because our code has been extracted directly from memory and before proceeding with our analysis it is necessary to map the raw sections addresses with their virtual counterparts (for brevity I have prepared a script that is going to perform these steps automatically). After having settled the addresses properly, it‚Äôs possible to proceed with configuration extraction through a custom script (that is out of the scope for this post).</p>
<h2 id="reference">Reference</h2>
<ul>
<li>DBI script: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/DynamicBinaryInstrumentation/mon.js">mon.py</a></li>
</ul>
]]></content></item><item><title>Manually unpacking of packed executable</title><link>https://Viuleeenz.github.io/posts/2021/09/manually-unpacking-of-packed-executable/</link><pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate><guid>https://Viuleeenz.github.io/posts/2021/09/manually-unpacking-of-packed-executable/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>In this post, I will show how to manually unpack a simple executable that has been packed with WinUPack.
However, the goal of this post is to provide a general approach to start reversing code and, in general, packers.
Because of that it will be hard to cover all the techniques and strategies that could be applied,
but I will try to give the rights hints and the mindset to approach these challenges.&lt;/p></description><content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>In this post, I will show how to manually unpack a simple executable that has been packed with WinUPack.
However, the goal of this post is to provide a general approach to start reversing code and, in general, packers.
Because of that it will be hard to cover all the techniques and strategies that could be applied,
but I will try to give the rights hints and the mindset to approach these challenges.</p>
<p>I will also try to highlight references to concepts that are almost mandatory to understand when you start doing this activity.</p>
<p>Before to proceed, all files and tools used in this tutorial are available at the following links:</p>
<ul>
<li><a href="https://storage.ey.md/Technology%20Related/Programming%20%26%20Reversing/Tuts4You%20Collection/UnPackMe%20Collection/PE32/WinUpack%200.38.rar">Packed executable</a></li>
<li><a href="http://www.openrce.org/downloads/details/108/OllyDump">OllyDump</a></li>
<li><a href="https://webscene.ir/tools/show/Import-REConstructor-1.6-FINAL">Import Rec</a></li>
</ul>
<p>I expect that most of the people that are approaching this post are already aware of packing techniques and how these are generally implemented.
However, since I strongly dislike to take for granted even this little details, a good reference to dig deeper about this topic is:</p>
<ul>
<li><a href="https://techtalk.pcmatic.com/2017/10/04/debugging-unpacking-malicious-software/">Debugging and Unpacking malicious software</a></li>
</ul>
<p>Let&rsquo;s start to make our hands a little bit dirty :)</p>
<h2 id="loading-exe-file-in-ollydbg">Loading .exe file in OllyDbg</h2>
<p>As soon as you load this file in OllyDbg you&rsquo;ll see an error message related to a corrupted <a href="https://tech-zealots.com/malware-analysis/pe-portable-executable-structure-malware-analysis-part-2/">PE Header</a>.</p>
<p>However, this error won‚Äôt prevent us to debug the application, if we try to run it (F9) the application stopped at 770A01C8 (in my case) and if you follow the execution step-by-step (F8), it will terminate almost immediately with a message box.</p>
<p>So let&rsquo;s step back where the application stopped. On the stack tab, we&rsquo;ll see something like this:</p>
<pre tabindex="0"><code>0018FFF4      | 00401018   | UnPackMe.00401018 |
</code></pre><p>Since it is the only function that is still in the stack, we could be confident that it represents the address of entry point of our PE. This insight is confirmed exploring the PE Header, in fact we saw the ImageBase = 400000 and the AddressOfEntryPoint = 1018 (since it is a <a href="https://tech-zealots.com/malware-analysis/understanding-concepts-of-va-rva-and-offset/">relative address</a>, we need to sum it with the ImageBase).</p>
<p>According to the information acquired, we could start placing a breakpoint at 00401018 and try to follow the execution step-by-step. After few instructions the stack tab should be similar to this one:</p>
<pre tabindex="0"><code>......
0018FF80   75581222  kernel32.GetProcAddress
0018FF84   755849D7  kernel32.LoadLibraryA
0018FF88   004271B0  UnPackMe.004271B0
0018FF8C   755833CA  RETURN to kernel32.755833CA
0018FF90   7EFDE000
0018FF94  /0018FFD4
0018FF98  |770C9ED2  RETURN to ntdll.770C9ED2
0018FF9C  |7EFDE000
0018FFA0  |7540DB7C
0018FFA4  |00000000
0018FFA8  |00000000
0018FFAC  |7EFDE000
0018FFB0  |00000000
0018FFB4  |00000000
0018FFB8  |00000000
0018FFBC  |0018FFA0
0018FFC0  |00000000
0018FFC4  |FFFFFFFF  End of SEH chain
0018FFC8  |77101ECD  SE handler
0018FFCC  |0253E188
0018FFD0  |00000000
0018FFD4  \0018FFEC
0018FFD8   770C9EA5  RETURN to ntdll.770C9EA5 from ntdll.770C9EAB
0018FFDC   00401018  UnPackMe.00401018
0018FFE0   7EFDE000
0018FFE4   00000000
0018FFE8   00000000
0018FFEC   00000000
0018FFF0   00000000
0018FFF4   00401018  UnPackMe.00401018
0018FFF8   7EFDE000
0018FFFC   00000000
</code></pre><p>As you can see from the stack, we have the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/structured-exception-handling">SEH</a> (structured exception handling) and on the top of it, there are two interesting functions (<a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> and <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibraryA</a>).</p>
<p><strong>GetProcAddress</strong> retrieves the address of an exported function or variable from the specified dynamic-link library (DLL), instead the function <strong>LoadLibraryA</strong> loads the specified module into the address space of the calling process (note that this module may cause other modules to be loaded).</p>
<p>Since we are trying to follow a repeatable approach, according to the information retrieved so far we could start guessing
(and then proving or refusing) something about the application. As far as we know, the application starts to load some dll (e.g., kernel32.dll) and then from each of them retrieve all functions that are needed for the executable. Then when everything is correctly settled, the application should go back to the OEP (Original Entry Point).</p>
<p><strong>In order to follow this insight its important to understand where these function are called and place a breakpoint there.</strong></p>
<h2 id="examining-a-function-call">Examining a function call</h2>
<p>From here, there are uncountable ways to move forward in order to find the OEP. We could look through the code to understand where GetProcAddress or LoadLibraryA are called for the last time, or we could also find the last function and the last library loaded and from that point move forward to reach the OEP, otherwise we could also look for specific blocks that are commonly used to save the OEP.</p>
<p>However, showing a specific technique is out of scope (as I said, <strong>I would like to give some hints and a mindset to approach to these challenges</strong>),
I&rsquo;m going to explore a little bit more the binary in order to be able to retrieve the OEP, dump the binary and restoring also the IAT (Import Address Table).</p>
<p>After these clarifications we are now ready to proceed with our analysis.</p>
<p>Since we were able to identify GetProcAddress and LoadLibraryA functions on the stack, we could easily move forward until we don&rsquo;t see
that these function are actually called within the UnPackMe address space. In my case, these functions are called from the UnPackMe address space at the following addresses:</p>
<ul>
<li>LoadLibraryA   0049A053</li>
<li>GetProcAddress 0049A06A</li>
</ul>
<p>Now let&rsquo;s go deep a little bit in detail, examining the LoadLibraryA function call and its returning value (the approach is the same for GetProcAddress ).</p>
<p>If you followed the <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">link</a> related to this function you are now aware that LoadLibrabryA take a single parameter that represents the module name. According to the <a href="https://en.wikibooks.org/wiki/X86_Disassembly/Calling_Conventions">calling convention</a> in x86 this parameters are commonly pushed on the stack, instead the return value is stored in the EAX registry.</p>
<p><img src="/img/winupack/loadLibrary.png" alt="LoadLibraryA details"></p>
<p>From the figure above It is easy to spot that:</p>
<ul>
<li>ESI contains the module name &ldquo;USER32.DLL&rdquo;,</li>
<li>ECX contains the function address of LoadLibraryA.</li>
</ul>
<p>In order to check if EAX contains the module&rsquo;s handler, we do a single step forward after the call ECX instruction. After that instruction we are able to see that EAX contains the handler for the module USER32.</p>
<pre tabindex="0"><code>EAX 74EA0000 OFFSET USER32.#2338
</code></pre><p>Eventually, when the last call to the LoadLibraryA and GetProcAddress are performed the EIP will reach the address <code>0049A06F</code> that contains the <code>RETN</code> instruction that will lead us the actual OEP.</p>
<p><img src="/img/winupack/OEP.png#center" alt="OEP"></p>
<p>Since we were able to go back to the OEP, <strong>we are also confirming that our initial hypothesis was correct</strong>! (Yes I cheated a little bit, since I already knew that it was the right path :) .</p>
<p>From now on, its just a matter of:</p>
<ol>
<li>Dump the executable with Ollydump</li>
<li>Attach to the debugging process with ImportREC</li>
<li>Set the new OEP and search for the IAT.</li>
<li>Fix dump</li>
</ol>
<p>These steps are left as homework for the few people that reached this point :)</p>
<h2 id="conclusion">Conclusion</h2>
<p>To conclude, in this brief post we saw how to manually examine a binary that has been packed, looking for clues, formulate hypothesis and then working to confirm or reject them.</p>
<p>In my experience, reversing isn&rsquo;t going in the middle of the code without an idea, it‚Äôs important to follow a method that should be as general as possible. In order to get better, I strongly recommend to practice with other sample trying to apply the same approach we saw here.</p>
<p>In case of doubts, unclear part, or just feedback about this post, feel free to reach me on my mail account.</p>
]]></content></item></channel></rss>