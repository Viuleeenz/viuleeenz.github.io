<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="This blog post is part of a recent personal investigation into a malware loader known as Coper. Rather than providing a full, line-by-line dissection of the malware, the goal is to introduce a high-level approach to triaging an Android native library.
An increasing number of Android malware families now rely on native libraries to hide their payloads, making reverse engineering a little bit more challenging. Nowadays, having an understanding of what is happening on native libraries is a fundamental skill that needs to be mastered, since it also represents a pivotal point to start investigating other malware families and even architecture.
"><meta name=keywords content="malware,binary,digital forensics,exploit development,reverse engineering"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://Viuleeenz.github.io/posts/2025/12/reversing-android-native-libraries-coper-notes/><title>Reversing Android Native Libraries - Coper Notes :: Security Undisguised
</title><link rel=stylesheet href=../../../../scss/main.c2f26a20d135ff7bc7091bb95e626c68bc9d8e4c0852d733dbfe9527448dfa92.css integrity="sha256-wvJqINE1/3vHCRu5XmJsaLydjkwIUtcz2/6VJ0SN+pI="><link rel=stylesheet type=text/css href=../../../../style.css><link rel=apple-touch-icon sizes=180x180 href=../../../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../../../favicon-16x16.png><link rel=manifest href=../../../../site.webmanifest><link rel=mask-icon href=../../../../safari-pinned-tab.svg color><link rel="shortcut icon" href=../../../../favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="Reversing Android Native Libraries - Coper Notes"><meta itemprop=description content="This blog post is part of a recent personal investigation into a malware loader known as Coper. Rather than providing a full, line-by-line dissection of the malware, the goal is to introduce a high-level approach to triaging an Android native library.
An increasing number of Android malware families now rely on native libraries to hide their payloads, making reverse engineering a little bit more challenging. Nowadays, having an understanding of what is happening on native libraries is a fundamental skill that needs to be mastered, since it also represents a pivotal point to start investigating other malware families and even architecture."><meta itemprop=datePublished content="2025-12-23T00:00:00+00:00"><meta itemprop=dateModified content="2025-12-23T00:00:00+00:00"><meta itemprop=wordCount content="2609"><meta itemprop=image content="https://Viuleeenz.github.io/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://Viuleeenz.github.io/"><meta name=twitter:title content="Reversing Android Native Libraries - Coper Notes"><meta name=twitter:description content="This blog post is part of a recent personal investigation into a malware loader known as Coper. Rather than providing a full, line-by-line dissection of the malware, the goal is to introduce a high-level approach to triaging an Android native library.
An increasing number of Android malware families now rely on native libraries to hide their payloads, making reverse engineering a little bit more challenging. Nowadays, having an understanding of what is happening on native libraries is a fundamental skill that needs to be mastered, since it also represents a pivotal point to start investigating other malware families and even architecture."><meta property="og:url" content="https://Viuleeenz.github.io/posts/2025/12/reversing-android-native-libraries-coper-notes/"><meta property="og:site_name" content="Security Undisguised"><meta property="og:title" content="Reversing Android Native Libraries - Coper Notes"><meta property="og:description" content="This blog post is part of a recent personal investigation into a malware loader known as Coper. Rather than providing a full, line-by-line dissection of the malware, the goal is to introduce a high-level approach to triaging an Android native library.
An increasing number of Android malware families now rely on native libraries to hide their payloads, making reverse engineering a little bit more challenging. Nowadays, having an understanding of what is happening on native libraries is a fundamental skill that needs to be mastered, since it also represents a pivotal point to start investigating other malware families and even architecture."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-23T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-23T00:00:00+00:00"><meta property="og:image" content="https://Viuleeenz.github.io/"><meta property="article:published_time" content="2025-12-23 00:00:00 +0000 UTC"></head><body><div class=container><header class=header><span class=header__inner><a href=../../../../ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>$ cd /home/Viuleeenz</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=../../../../about/>About</a></li><li><a href=../../../../posts/>Posts</a></li><li><a href=../../../../whitepapers>Whitepapers</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span><span class="theme-toggle not-selectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span>
</span></span><script async src="https://www.googletagmanager.com/gtag/js?id=G-XNKLBC4D9D"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XNKLBC4D9D")}</script></header><div class=content><main class=post><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
13 minutes</p></div><article><h1 class=post-title><a href=https://Viuleeenz.github.io/posts/2025/12/reversing-android-native-libraries-coper-notes/>Reversing Android Native Libraries - Coper Notes</a></h1><div class=post-content><p>This blog post is part of a recent personal investigation into a malware loader known as <strong>Coper</strong>. Rather than providing a full, line-by-line dissection of the malware, the goal is to introduce a high-level approach to triaging an Android native library.</p><p>An increasing number of Android malware families now rely on native libraries to hide their payloads, making reverse engineering a little bit more challenging. Nowadays, having an understanding of what is happening on native libraries is a fundamental skill that needs to be mastered, since it also represents a pivotal point to start investigating other malware families and even architecture.</p><blockquote><p>üí°¬†<em>Through this blogpost, I try to make it as more understandable as possible, making reverse native libraries a little bit less disorienting. Because of that, I would like to make a soft introduction to native libraries, going against a real world example, covering something that goes over the mere basics, without losing the actual focus on learning new things along the way.</em></p></blockquote><p>Reference: <code>1e38419cea3379d8992d165f842f3fd78e9da32aa7f04bcb19e3bdf71d109e2f</code></p><h2 id=from-java-to-native-code-connection>From Java to Native Code Connection</h2><p>To execute a function from a native library, the Java code must first declare a corresponding native method. When this Java-declared native method is invoked, the <em>paired</em> native function within the compiled library (ELF/.so) is executed.</p><p>In Java, a native method looks like a regular method declaration, with two key differences: it is marked with the <code>native</code> keyword, and it contains no implementation. This is because the method‚Äôs logic resides entirely in the compiled native library rather than in Java code.</p><p><img src=../../../../img/coper_notes/loading_native_library.png alt="Figure 1: Loading Native Library"></p><p>Figure 1: Loading Native Library</p><p>The bytecode in an Android application‚Äôs <code>.dex</code> file declares the native methods. Each of these declarations is paired with a corresponding subroutine in a shared native library. Before any native method can be invoked from Java, the application must load the shared library (<code>.so</code> file) using <code>System.loadLibrary</code> or <code>System.load</code>. When one of these loading methods is called, the <code>JNI_OnLoad()</code> function in the shared library (if present) is automatically executed.</p><blockquote><p>üí°¬†<em>If you start exploring the native library straight way, you will see that we do not have the On_Load function. This could happen for many reasons. JNI_Onload method usually runs immediately when the library is loaded, breaking this pattern could give some advantages to attackers that could use a dedicated method instead of relying on the builtin routine, having full control over the library running methods under specific conditions (e.g., after verifying device environment variables to detect root or emulation). Moreover in this way its also possible to bypass automation techniques that look for common and standard routines.</em></p></blockquote><p>In order to run a native method from Java, the native method must be &lsquo;registered&rsquo;, meaning that the JNI knows how to pair the Java method definition with the correct function in the native library. This can be done either by leveraging the¬†<strong>RegisterNatives¬†JNI</strong> (static <em>linking</em>) function or through <code>discovery</code> based on the <strong>function names and function signatures matching</strong> (dynamic <em>linking</em>) in both Java and the¬†.so¬†. For either method, a string of the Java method name is required for the JNI to know which native function to call.</p><p>In this example we are going to see the usage of function name and signature discovery. In order to pair the Java declared native method and the function in the native library the naming conventions need to meet specific requirements. A native method name needs to be concatenated with the following components:</p><ul><li>the prefix Java_</li><li>a mangled fully-qualified class name</li><li>an underscore (‚Äú_‚Äù) separator</li><li>a mangled method name</li></ul><p><img src=../../../../img/coper_notes/jni_function_signature.png alt="Figure 2: JNI function signature"></p><p>Figure 2: JNI function signature</p><p>Looking at the signature, it&rsquo;s clear that something odd is still there. There are three int parameters that we have not identified in the Java call. What are they? Those parameters are part of the calling convention that actually hides a few things that our disassembler missed. If you look at JNI <a href=https://developer.android.com/ndk/guides/jni-tips>documentations</a> its possible to rewrite parameters as follow:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Java_com_morninghislbg_FxvheRBQy_odGLksAlj</span>(
</span></span><span style=display:flex><span>    JNIEnv <span style=color:#f92672>*</span>env,
</span></span><span style=display:flex><span>    jobject <span style=color:#66d9ef>this</span>,
</span></span><span style=display:flex><span>    jobject context
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><ul><li><code>JNIEnv *env</code> represents a getaway to the entire Java world. If we need to call Java methods, classes, objects, access or instantiate strings, etc‚Ä¶ <strong>It could be basically seen as a pointer to a structure that contains JNI</strong> <a href=https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html>interface function pointers</a>.</li><li><code>jobject this</code> is the Java object instance the methods belong to. This object allows the C function to access instance variables of the Java object itself, giving also a chance to call other methods on the same object</li><li><code>jobject context</code> is the actual parameter passed from Java</li></ul><blockquote><p>üí°¬†<em>I know, all the information provided so far could be a little bit disorienting, however,</em> <em>before proceeding directly examining the native code, it‚Äôs important to get some preliminary information about JNI specification and functions and include them within your decompiler/disassemble tool, missing this step would literally make the reverse session a nightmare since your are not able to distinguish native methods and classes that will be used to follow the overall flow. You can import those files directly in <a href=https://gist.github.com/Jinmo/048776db75067dcd6c57f1154e65b868>IDA</a> or <a href=https://github.com/extremecoders-re/ghidra-jni>Ghidra</a>.</em></p></blockquote><h2 id=resolving-names-and-creating-structure>Resolving Names and Creating Structure</h2><p>Exploring the code through a disassembler and guided by the previous insight we could easily go directly to <strong>Java_com_morninghislbg_FxvheRBQy_odGLksAlj</strong> function. However, as soon as we open up the code, we are flooded by a quite long list of variables and some strings as well as a lot of <em>strange</em> code that appears to be called from an offset related to the first parameter.</p><p><img src=../../../../img/coper_notes/unresolved_jni_names.png alt="Figure 3: Unresolved JNI names"></p><p>Figure 3: Unresolved JNI names</p><p>To make the code more readable, its time to set parameters properly, according to the one identified in the previous section. In this case <code>a1</code> its the <code>JNIEnv *</code> , so we could expect properly resolved functions.</p><p><img src=../../../../img/coper_notes/jnienv_typestruct_set.png alt="Figure 4: JNIEnv type structure set"></p><p>Figure 4: JNIEnv type structure set</p><p>Resolving type and renaming the variables properly we could have a little bit more readable code, however, it&rsquo;s far away from being explorable to reverse and understanding the general workflow. If we look at the beginning of this function we could easily spot a long sequence of <strong>strcpy</strong> with some interesting values like: <em><strong>com.morninghislbg:raw/urdvipkyjahgh</strong> and <strong>getResources</strong>.</em> Those are quite interesting since we are seeing a potential resource and a method to retrieve that. Why? Moreover, we are also able to see some strings related to reflection techniques such as: <em><strong>dalvik/system/DexClassLoader</strong>, <strong>setAccessible</strong> or even <strong>Reflect/Field</strong>.</em></p><p>From here, its possible to make hypothesis and exploring few questions:</p><ul><li>What is that resource in the APK files?<ul><li>Are those resources packed or encrypted? Does it contain code? Why is it used? Is there any relation between that and the DexClassLoader method?</li></ul></li></ul><p>From here there are a couple of options, resolving names for all variables (or at least most of them) or start exploring our hypothesis hoping for the good.</p><blockquote><p>üí°¬†<em>Generally speaking, renaming variables is one of the most important tasks before doing anything else. From this point, you could take your time starting renaming variables, setting proper types and structure until you will have a clear idea of what is happening. A good trick that I use most of the time is to start renaming variables that are involved in function calls and then let me drive from hypotheses that could also arise from resolved names. There aro no good or bad options, usually it depends also from the time you have for analyzing a sample.</em></p></blockquote><p>Because this is a kind of introduction to this topic, it&rsquo;s better to explore the code closely using a more structured approach. First of all, let‚Äôs start from the very beginning where the <strong>strcpy</strong> functions are invoked. From there we could be able to see a few patterns that should be a hint about how information is stored also in the original program.</p><p><img src=../../../../img/coper_notes/sequence_of_resolved_strings.png alt="Figure 5: Sequence of resolved strings"></p><p>Figure 5: Sequence of resolved strings</p><p>If your code looks like the figure above, it is caused by the obfuscation in place. Strings are stored on stack, however, the disassembler did not fully understand the whole structure and did its best to retrieve strings giving to us a partial, but still a good result. An example is the v108 where there is an array of 62 chars that contains two strings one after another. A more readable code should look like the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  strcpy(<span style=color:#f92672>&amp;</span>v108.<span style=color:#a6e22e>fullpath_resource</span>, <span style=color:#e6db74>&#34;com.morninghislbg:raw/urdvipkyjahgh&#34;</span>);
</span></span><span style=display:flex><span>  strcpy(<span style=color:#f92672>&amp;</span>v108.<span style=color:#a6e22e>resource_name</span>, <span style=color:#e6db74>&#34;urdvipkyjahgh&#34;</span>);
</span></span></code></pre></div><p>In order to make the overall code more there are two ways, using a global structure that embed this information or renaming variables directly as they are trying to include information about their values.</p><blockquote><p>üí°¬†<em>Since I‚Äôm trying to make some references that go over the mere Coper analysis, I will go through the structure path. However, it&rsquo;s important to keep in mind that creating a structure does not represent the best approach in general, it&rsquo;s all about time and purpose. From time to time, I go straight to the point of renaming very few variables, especially if the malware is already known and documented.</em></p></blockquote><p>In order to start creating a global structure that will contain all those variables we should inspect the code a little bit more. If we see the <strong>strcpy</strong> we could spot the offset <strong>where the first variable is written.</strong></p><p><img src=../../../../img/coper_notes/esp_calculation.png alt="Figure 6: ESP identification for calculating malware configuration structure"></p><p>Figure 6: ESP identification for calculating malware configuration structure</p><p>From the figure above it is possible to see that the very first variable is located at <strong>esp+50h</strong>, then exploring the stack all the way up it is possible to see that the latest variable is stored at <strong>esp+4C8h</strong>. If we calculated the size from those two values its possible to see that our struct should be <strong>0x47C</strong> bytes.</p><p><img src=../../../../img/coper_notes/malware_structure_applied.png alt="Figure 7: Malware structure applied and variable renaming"></p><p>Figure 7: Malware structure applied and variable renaming</p><h3 id=function-triage>Function Triage</h3><p>Now that we have resolved most of the names importing JNI functions and renaming variables through a proper structure, everything should be more readable and easier to get understood. This function could be divided into <strong>three main parts</strong>.</p><ul><li><p>Collecting resource information to see if the encrypted payload is available</p><p><img src=../../../../img/coper_notes/encrypted_payload.png alt="Figure 8: Check for encrypted payload"></p><p>Figure 8: Check for encrypted payload</p></li><li><p>Allocating a buffer, according to the resource size, that is going to contain the encrypted data</p><p><img src=../../../../img/coper_notes/alloc_memory.png alt="Figure 9: Allocate memory for decrypted buffer"></p><p>Figure 9: Allocate memory for decrypted buffer</p></li><li><p>Decrypt the resource, verifying that the process has been completed correctly and in the end load the <strong>.dex</strong> file into the application context.</p><p><img src=../../../../img/coper_notes/payload_dec_function.png alt="Figure 10: Payload decryption function"></p><p>Figure 10: Payload decryption function</p></li></ul><blockquote><p>üí°¬†As expected the <em>general flow of this library is pretty straightforward once you rename variables according to JNI specifications and strcpy values. Most of the effort in this case has been taken by the renaming task. I know, it could be boring and tedious but it happens most of the time that ‚Äúcomplex‚Äù code just lacks proper renaming to get understood.</em></p></blockquote><p>However, even if the general flow appears to be quite straightforward, how was it possible to understand that a decryption routine was in place? And which algorithm has been used?</p><h3 id=payload-decryption>Payload Decryption</h3><p>When exploring code, especially cryptographic routines, start looking for <em>known patterns</em> that usually give great hints about the algorithm itself and most of the time point towards the right solution. From the information collected we could easily start exploring <strong>zXnpkXjsasbB</strong> that takes <strong>key</strong>, <strong>buffer</strong> and the <strong>buffer_size</strong>.</p><p><img src=../../../../img/coper_notes/crypto_fucntion_ids.png alt="Figure 11: Identification of cryptographic functions"></p><p>Figure 11: Identification of cryptographic functions</p><p>From here there are two main functions to explore ( it‚Äôs worth noting that <strong>dpBcYXJbiaGo</strong> doesn‚Äôt affect decryption).</p><p>Exploring the <strong>UNUUvhZiuBaOFsX</strong> function we could immediately spot interesting values. It starts initializing a few variables using a structure.</p><p><img src=../../../../img/coper_notes/rc4_sbox_init.png alt="Figure 12: RC4 S-Box initialization"></p><p>Figure 12: RC4 S-Box initialization</p><p>However, what do those <em><strong>xmmword_</strong></em> values contain? Looking at the first two values we see some interesting values that go from 0 to 31. Exploring all those values we could discover that its actually goes from 0 to 255. Does it ring any bells?</p><p><img src=../../../../img/coper_notes/rc4_init.png alt="Figure 13: RC4 S-Box example"></p><p>Figure 13: RC4 S-Box example</p><p>If not, we could start exploring a little bit more the rest of this function. Let‚Äôs get some insight from what we see without renaming anything.</p><p><img src=../../../../img/coper_notes/rc4_ksa.png alt="Figure 14: RC4 KSA"></p><p>Figure 14: RC4 KSA</p><ul><li><strong>line 33</strong>: <code>key[i % key_len]</code></li><li><strong>line 34 - 38</strong>: <code>(value) % 256</code></li><li><strong>line 39-41</strong>: <code>swap(S[i], S[j])</code></li></ul><p>All those steps are done 256 times. What is happening in this code? Well, trying to use some known patterns from cryptographic functions, this is a good indicator that we a re dealing with <a href=https://blog.talosintelligence.com/an-introduction-to-recognizing-and/>RC4</a> key scheduling phase that could be seen (without obfuscation) through those few lines of pseudocode:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>j <span style=color:#f92672>=</span> 0
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> i <span style=color:#f92672>=</span> 0 to 255:
</span></span><span style=display:flex><span>       j <span style=color:#f92672>=</span> (j <span style=color:#f92672>+</span> S<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> key<span style=color:#f92672>[</span>i mod keylen<span style=color:#f92672>]</span>) mod 256
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>swap</span>(S<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>, S<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>)
</span></span></code></pre></div><p>So we could rename this function as <strong>rc4_ksa</strong>. As expected, since the algorithm is divided in two parts, the next function is the <strong>PRGA</strong> (Pseudo-Random number Generation Algorithm) that is going to include also the <strong>XOR</strong> operation with the encrypted resource bytes.</p><p>Now that has been possible to identify the RC4 routine, let‚Äôs try to understand the <strong>PRGA</strong> using the reverse strategy, starting from a pseudocode and trying to conciliate it with what we have in our disassembler. A general version for the prga, should looks like similar to this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>for</span> each <span style=color:#66d9ef>byte</span> in buffer:
</span></span><span style=display:flex><span>    i <span style=color:#f92672>=</span> (i <span style=color:#f92672>+</span> 1) <span style=color:#f92672>%</span> 256
</span></span><span style=display:flex><span>    j <span style=color:#f92672>=</span> (j <span style=color:#f92672>+</span> S<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>) <span style=color:#f92672>%</span> 256
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>swap</span>(S<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>, S<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span>    K <span style=color:#f92672>=</span> S<span style=color:#f92672>[</span>(S<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>+</span> S<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>) <span style=color:#f92672>%</span> 256<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    plaintext <span style=color:#f92672>=</span> K XOR ciphertext
</span></span></code></pre></div><p>Once we open up the <strong>lejwPBRiZws</strong> function, we should be able to spot some pattern that was already seen in the previous function. Basically, the <em>modulo</em> is hidden through <code>add</code> , <code>&</code> operations that tries to make this code a little bit less understandable. However, since this pattern has been already resolved, we could safely mark it and skip to the next block of instructions that are the <strong>XOR</strong> routine that decrypts the actual payload (blue rectangle).</p><p><img src=../../../../img/coper_notes/rc4_prga_xor.png alt="Figure 15: RC4 PRGA"></p><p>Figure 15: RC4 PRGA and XOR</p><blockquote><p>üí°¬†<em>At this point, I hope that everything sounds a little bit more clear. Obfuscation is something that prevents the code be seen clearly, but once you unfold the the most importants variables everything starts to make sense. There is no perfect solution, the idea is always start making hypothesis and continuously challenging them.</em></p></blockquote><h3 id=automation>Automation</h3><p>As always, making some automation about the overall process is also part of the fun. Because of that, I tried to make a script that takes care of all those steps decrypted in this blogpost.</p><p><img src=../../../../img/coper_notes/decrypted_payload.png alt="Figure 16: Decrypted payload"></p><p>Figure 16: Decrypted payload</p><blockquote><p>üí°¬†<em>It‚Äôs worth mentioning that the script provided has some limitations related to the target architecture (x86), moreover, it sometimes breaks because of APK malformation in place. Because of that, modifying the script directly doesn‚Äôt help us. To handle those errors correctly, you should create a pipeline that cleans up the APK in order to be properly processed by decryption and/or configuration extraction tools. Nevertheless, a more structured approach including dynamic analysis is actually encouraged, because of potential complexity that could arise exploring different builds.</em></p></blockquote><h3 id=conclusion>Conclusion</h3><p>This blog post aims to provide a soft introduction to Android native libraries and how to investigate them to extract useful information that can be reused in further analyses, as well as to develop effective decryption or unpacking routines. For a real-world example, the <strong>Coper loader</strong> was chosen due to its widespread presence and slightly more advanced logic, which includes a degree of obfuscation. Generally speaking, reversing Android native libraries can sometimes feel disorienting, especially without prior experience in x86 or ARM binaries. However, with the right mindset and some patience, it becomes feasible. Most of the techniques demonstrated in this blog post are broadly applicable: renaming variables, recognizing common code patterns, forming hypotheses, and testing them are always valid approaches, regardless of the specific malware being analyzed.</p><p>Hope you had fun and really enjoyed this blogpost. Thank you for reading! :)</p><h3 id=references>References:</h3><p>RC4 algorithm specifications:</p><ul><li><a href=https://blog.talosintelligence.com/an-introduction-to-recognizing-and/>TALOS blog</a></li><li><a href=https://goggleheadedhacker.com/blog/post/reversing-crypto-functions#rc4-algorithm>GoggleHeadedHacker</a> (I really love this blog, it&rsquo;s my favourite reference for a lot of topics)</li></ul><p>JNI references</p><ul><li><a href=https://docs.oracle.com/en/java/javase/17/docs/specs/jni/functions.html>Oracle JNI function reference</a></li><li><a href=https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/types.html>Oracle JNI type sgnature</a></li></ul><p>Sample:</p><ul><li><a href=https://www.virustotal.com/gui/file/1e38419cea3379d8992d165f842f3fd78e9da32aa7f04bcb19e3bdf71d109e2f>Coper Loader</a></li></ul><p>Coper Unpacker/Decryption script:</p><ul><li><a href=https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/Android/coper_unpacker.py>coper_unpacker.py</a></li></ul></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
2609 Words</p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2025-12-23 01:00</p></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2025</span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span></div></div></footer></div><script type=text/javascript src=../../../../bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc+cxaJzDdCYbAW0X1G+DgZYvtKFXe6MBex8jUJ2JT25mQx+YjACIng=="></script></body></html>