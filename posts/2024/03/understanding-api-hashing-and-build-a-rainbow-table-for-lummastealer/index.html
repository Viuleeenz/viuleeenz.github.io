<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="map[name:Alessandro Strino]"><meta name=description content="Understanding PEB and Ldr structures represents a starting point when we are dealing with API hashing. However, before proceeding to analyze a sample itâ€™s always necessary to recover obfuscated, encrypted or hashed data. Because of that, through this blogpost I would like to continue what I have started in the previous post, using emulation to create a rainbow table for LummaStealer and then write a little resolver script that is going to use the information extracted to resolve all hashes.
"><meta name=keywords content="malware,binary,digital forensics,exploit development,reverse engineering"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://Viuleeenz.github.io/posts/2024/03/understanding-api-hashing-and-build-a-rainbow-table-for-lummastealer/><title>Understanding API Hashing and build a rainbow table for LummaStealer :: Security Undisguised
</title><link rel=stylesheet href=../../../../scss/main.c2f26a20d135ff7bc7091bb95e626c68bc9d8e4c0852d733dbfe9527448dfa92.css integrity="sha256-wvJqINE1/3vHCRu5XmJsaLydjkwIUtcz2/6VJ0SN+pI="><link rel=stylesheet type=text/css href=../../../../style.css><link rel=apple-touch-icon sizes=180x180 href=../../../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../../../favicon-16x16.png><link rel=manifest href=../../../../site.webmanifest><link rel=mask-icon href=../../../../safari-pinned-tab.svg color><link rel="shortcut icon" href=../../../../favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="Understanding API Hashing and build a rainbow table for LummaStealer"><meta itemprop=description content="Understanding PEB and Ldr structures represents a starting point when we are dealing with API hashing. However, before proceeding to analyze a sample itâ€™s always necessary to recover obfuscated, encrypted or hashed data. Because of that, through this blogpost I would like to continue what I have started in the previous post, using emulation to create a rainbow table for LummaStealer and then write a little resolver script that is going to use the information extracted to resolve all hashes."><meta itemprop=datePublished content="2024-03-24T00:00:00+00:00"><meta itemprop=dateModified content="2024-03-24T00:00:00+00:00"><meta itemprop=wordCount content="1838"><meta itemprop=image content="https://Viuleeenz.github.io/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://Viuleeenz.github.io/"><meta name=twitter:title content="Understanding API Hashing and build a rainbow table for LummaStealer"><meta name=twitter:description content="Understanding PEB and Ldr structures represents a starting point when we are dealing with API hashing. However, before proceeding to analyze a sample itâ€™s always necessary to recover obfuscated, encrypted or hashed data. Because of that, through this blogpost I would like to continue what I have started in the previous post, using emulation to create a rainbow table for LummaStealer and then write a little resolver script that is going to use the information extracted to resolve all hashes."><meta property="og:url" content="https://Viuleeenz.github.io/posts/2024/03/understanding-api-hashing-and-build-a-rainbow-table-for-lummastealer/"><meta property="og:site_name" content="Security Undisguised"><meta property="og:title" content="Understanding API Hashing and build a rainbow table for LummaStealer"><meta property="og:description" content="Understanding PEB and Ldr structures represents a starting point when we are dealing with API hashing. However, before proceeding to analyze a sample itâ€™s always necessary to recover obfuscated, encrypted or hashed data. Because of that, through this blogpost I would like to continue what I have started in the previous post, using emulation to create a rainbow table for LummaStealer and then write a little resolver script that is going to use the information extracted to resolve all hashes."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-24T00:00:00+00:00"><meta property="article:modified_time" content="2024-03-24T00:00:00+00:00"><meta property="og:image" content="https://Viuleeenz.github.io/"><meta property="article:published_time" content="2024-03-24 00:00:00 +0000 UTC"></head><body><div class=container><header class=header><span class=header__inner><a href=../../../../ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>$ cd /home/Viuleeenz</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=../../../../about/>About</a></li><li><a href=../../../../posts/>Posts</a></li><li><a href=../../../../whitepapers/>Whitepapers</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span><span class="theme-toggle not-selectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span>
</span></span><script async src="https://www.googletagmanager.com/gtag/js?id=G-XNKLBC4D9D"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XNKLBC4D9D")}</script></header><div class=content><main class=post><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
9 minutes</p></div><article><h1 class=post-title><a href=https://Viuleeenz.github.io/posts/2024/03/understanding-api-hashing-and-build-a-rainbow-table-for-lummastealer/>Understanding API Hashing and build a rainbow table for LummaStealer</a></h1><div class=post-content><p>Understanding PEB and Ldr structures represents a starting point when we are dealing with API hashing. However, before proceeding to analyze a sample itâ€™s always necessary to recover obfuscated, encrypted or hashed data. Because of that, through this blogpost I would like to continue what I have started in the <a href=https://viuleeenz.github.io/posts/2024/02/understanding-peb-and-ldr-structures-using-ida-and-lummastealer/>previous post</a>, using emulation to create a rainbow table for LummaStealer and then write a little resolver script that is going to use the information extracted to resolve all hashes.</p><blockquote><p>ðŸ’¡<em>Itâ€™s worth mentioning that Iâ€™m trying to create self-contained posts. Of course, previous information will give a more comprehensive understanding of the whole process, however, the goal for this post is to have a guide that could be applied overtime even on different samples not related to LummaStealer.</em></p></blockquote><h2 id=resolving-hashes>Resolving Hashes</h2><p>Starting from where we left in the last post, we could explore the function routine that is in charge of <strong>collecting function names from a DLL and then perform a hashing algorithm</strong> to find a match with the input name.</p><p><img src=../../../../img/api_hashing/api_hashing_overview.png alt="Figure 1: LummaStealer API Hashing overview"></p><p>Figure 1: LummaStealer API Hashing overview</p><p>At the first glance, this function could be disorienting, however, understanding that <strong>ecx</strong> contains the module <strong>BaseAddress</strong> (explained in the previous article) it is possible to set a comment that is going to make the whole function easier to understand. Moreover, it has been also divided in three main parts( first two are going to be detailed in the next sections):</p><ol><li>Collecting exported function within a PE file;</li><li>Hashing routine;</li><li>Compare hashing result until a match is found, otherwise return 0; (<em>skipped because of a simple comparing routine</em>)</li></ol><h3 id=collecting-exported-function-within-a-pe-file>Collecting exported function within a PE file</h3><p>The first box starts with the instruction <strong>mov edi, ecx</strong> where <strong>ecx</strong> is a <em>BaseAddress</em> of a module that is going to be analyzed. This is a fundamental instruction that gives us a chance to infere the subsequent value of <strong>edi</strong> and <strong>ebx</strong>. In fact, if we rename values associated to these registers, it should be clear that this code is going to collect exported functions names through <strong>AddressOfNames</strong> and <strong>AddressOfNameOrdinals</strong> pointers.</p><p><img src=../../../../img/api_hashing/resolving_structures_names.png alt="Figure 2: Resolving structures names"></p><p>Figure 2: Resolving structures names</p><p>Those structures are very important in order to understand what is happening in the code. For now, you could think about those structures as <em>support structures</em> that could be chained together in order to collect the actual function pointer (after a match is found!) within the <strong>Address of a Function structure</strong>.</p><blockquote><p>ðŸ’¡ <em>At the end of this article I created a dedicated sections to explain those structures and their connections.</em></p></blockquote><p>Another step that could misleading is related to the following instruction:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#a6e22e>mov</span> ebx,[eax<span style=color:#f92672>+</span>edi<span style=color:#f92672>+</span>IMAGE_NT_HEADERS.OptionaHeader.DataDirectory.VirtualAddress]
</span></span></code></pre></div><p>where <strong>ebx</strong> becomes a pointer for <strong>IMAGE_EXPORT_DIRECTORY</strong>.</p><p>In order to explain this instruction its useful to have a look at <a href=https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32>IMAGE_OPTIONAL_HEADERS</a> documentation, where Microsoft states that <strong>DataDirectory</strong> is pointer to a dedicated structure called <a href=https://learn.microsoft.com/en-us/windows/desktop/api/winnt/ns-winnt-image_data_directory>IMAGE_DATA_DIRECTORY</a> that could be addressed through a <strong>number</strong>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span> <span style=color:#a6e22e>typedef</span> struct _IMAGE_OPTIONAL_HEADER <span style=color:#960050;background-color:#1e0010>{</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>...</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>IMAGE_DATA_DIRECTORY</span> DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]<span style=color:#75715e>;</span>
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>}</span>
</span></span></code></pre></div><p>With that information letâ€™s do some math unveiling the magic behind this assignment.</p><ul><li><strong>eax</strong> corresponds to the <strong>IMAGE_NT_HEADERS</strong> (because of its previous assignment)</li></ul><p>From there we have a <strong>0x78</strong> offset to sum. If we sum the first 18 bytes from <strong>eax</strong>, itâ€™s possible to jump to the <strong>IMAGE_OPTIONAL_HEADER</strong>. Using the 60 bytes remaining to reach the next field within this structure, we could see that we are directly pointing to DataDirectory.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#a6e22e>typedef</span> struct <span style=color:#f92672>**</span>_IMAGE_NT_HEADERS<span style=color:#f92672>**</span> <span style=color:#960050;background-color:#1e0010>{</span>
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x0000</span> <span style=color:#66d9ef>DWORD</span>                   Signature<span style=color:#75715e>;</span>
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x0004</span> IMAGE_FILE_HEADER       FileHeader<span style=color:#75715e>;</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>...</span>
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x0018</span> IMAGE_OPTIONAL_HEADER32 OptionalHeader<span style=color:#75715e>;</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>}</span> <span style=color:#a6e22e>IMAGE_NT_HEADERS32</span>, <span style=color:#f92672>*</span>PIMAGE_NT_HEADERS32<span style=color:#75715e>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>typedef</span> struct <span style=color:#f92672>**</span>_IMAGE_OPTIONAL_HEADER<span style=color:#f92672>**</span> <span style=color:#960050;background-color:#1e0010>{</span>
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x0000</span> <span style=color:#66d9ef>WORD</span>                 Magic<span style=color:#75715e>;</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>...</span>
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x001C</span> <span style=color:#66d9ef>DWORD</span>                ImageBase<span style=color:#75715e>;</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>...</span>
</span></span><span style=display:flex><span> <span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x0060</span> IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]<span style=color:#75715e>;</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>}</span> <span style=color:#a6e22e>IMAGE_OPTIONAL_HEADER32</span>, <span style=color:#f92672>*</span>PIMAGE_OPTIONAL_HEADER32<span style=color:#75715e>;</span>
</span></span></code></pre></div><p>From here, we donâ€™t have additional bytes to sum, it means that we are pointing to the first structure pointed by DataDirectory, that is, according to the documentation the <strong>IMAGE_DIRECTORY_ENTRY_EXPORT</strong> also known as <strong>Export Directory</strong>.</p><blockquote><p>ðŸ’¡ <em>See Reference section to find out a more clear image about the whole PE structure</em></p></blockquote><h3 id=retrieve-the-function-pointer>Retrieve the function pointer</h3><p>Once the code in charge to collect and compare exported functions has been completed, and a match is found, it&rsquo;s time to retrieve the actual function pointer using some of the structures mentioned above. In fact, as you can see from the code related to the third box (that has been renamed accordingly), once the match if found, the structure <strong>AddressOfNameOrdinals</strong> it&rsquo;s used to retrieve the functions number that is going to address the structure <strong>AddressOfFunctions</strong> that contains the actual function pointers.</p><p><img src=../../../../img/api_hashing/collect_api_pointer.png alt="Figure 3: Collect the actual function pointer"></p><p>Figure 3: Collect the actual function pointer</p><blockquote><p>ðŸ’¡<em>I donâ€™t want to bother you with so much details at this point, since we have already analyzed throughly some structures and we still have additional contents to discuss. However, the image above has been thought to be self-contained. That said, to not get lost please remember that <strong>edi</strong> represents the <strong>Ldr_Module.BaseAddress</strong></em></p></blockquote><h3 id=analyze-the-hashing-routine>Analyze the hashing routine</h3><p>Through the information collected so far, this code should be childishly simple.</p><p><strong>ecx</strong> contains the hash name extracted from the export table that is going to forward as input to the hash function (identified, <em>in this case, as <a href=https://github.com/abrandoned/murmur2/blob/master/MurmurHash2.c>murmur2</a></em>). The function itself is quite long but does not take too much time to be understood and reimplemented. However, the purpose of this article is to emulate this code in order to find out the values of all hardcoded hashes.</p><p><img src=../../../../img/api_hashing/murmur2_hashing_routine.png alt="Figure 4: MurMur2 hashing routine">
Figure 4: MurMur2 hashing routine</p><p>As we have <a href=https://viuleeenz.github.io/posts/2023/12/applied-emulation-decrypting-ursnif-strings-with-unicorn/>already done</a>, we could select the function opcodes (without the return instruction) and put them in our code emulator routine. Itâ€™s worth mentioning that, <strong>ecx</strong> contains the function name that is going to be used as argument for hashing routine, because of that, itâ€™s important to assign that register properly.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>MurMurHash2</span>(func_name):
</span></span><span style=display:flex><span>    code <span style=color:#f92672>=</span> bytes<span style=color:#f92672>.</span>fromhex(<span style=color:#e6db74>&#39;56 57 8B F9 8B D7 8D 4A 01 8A 02 42 84 C0 75 F9 2B D1 8B F2 83 F6 20 83 FA 04 7C 4D 53 8B DA C1 EB 02 6B C3 FC 03 D0 0F B6 4F 03 0F B6 47 02 C1 E1 08 0B C8 69 F6 95 E9 D1 5B 0F B6 47 01 C1 E1 08 0B C8 0F B6 07 C1 E1 08 83 C7 04 0B C8 69 C9 95 E9 D1 5B 8B C1 C1 E8 18 33 C1 69 C8 95 E9 D1 5B 33 F1 83 EB 01 75 BF 5B 83 EA 01 74 1C 83 EA 01 74 0E 83 EA 01 75 1D 0F B6 47 02 C1 E0 10 33 F0 0F B6 47 01 C1 E0 08 33 F0 0F B6 07 33 C6 69 F0 95 E9 D1 5B 8B C6 C1 E8 0D 33 C6 69 C8 95 E9 D1 5B 5F 5E 8B C1 C1 E8 0F 33 C1&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span> <span style=color:#75715e># skip code </span>
</span></span><span style=display:flex><span>    uc<span style=color:#f92672>.</span>mem_write(data_base, func_name)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Set function argument</span>
</span></span><span style=display:flex><span>    uc<span style=color:#f92672>.</span>reg_write(UC_X86_REG_ECX, data_base)
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span> <span style=color:#75715e># skip code</span>
</span></span><span style=display:flex><span>    uc<span style=color:#f92672>.</span>emu_start(target_base, target_end, timeout<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, count<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span> <span style=color:#75715e># skip code</span>
</span></span><span style=display:flex><span>    EAX <span style=color:#f92672>=</span> uc<span style=color:#f92672>.</span>reg_read(UC_X86_REG_EAX)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> EAX
</span></span></code></pre></div><p>Letâ€™s take a test. Using the <strong>LoadLibraryW</strong> name, we get back <strong>0xab87776c</strong>. If we explore a little bit our code, we will find almost immediately this value! it is called each time a new hash needs to be resolved.</p><p><img src=../../../../img/api_hashing/loadLibrary_hash.png alt="Figure 5: LoadLibraryW Hash"></p><p>Figure 5: LoadLibraryW Hash</p><p>This behavior is a clear indication that before proceeding to extract exported functions, we need to load the associated library (DLL) in memory. With that information we could be sure that our emulator works fine.</p><h3 id=build-a-rainbow-table>Build a rainbow table</h3><p>Building a rainbow table can be done in a few lines of code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>filter <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;ntdll.dll&#39;</span>]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_all_export_function_from_dlls</span>():
</span></span><span style=display:flex><span>    exported_func <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> dirpath, dirnames, filenames <span style=color:#f92672>in</span> os<span style=color:#f92672>.</span>walk(<span style=color:#e6db74>&#34;C:</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>Windows</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>System32&#34;</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> filename <span style=color:#f92672>in</span> [f <span style=color:#66d9ef>for</span> f <span style=color:#f92672>in</span> filenames <span style=color:#66d9ef>if</span> f <span style=color:#f92672>in</span> filter]:
</span></span><span style=display:flex><span>            path_to_dll <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>join(dirpath, filename)
</span></span><span style=display:flex><span>            pe <span style=color:#f92672>=</span> pefile<span style=color:#f92672>.</span>PE(path_to_dll)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> export <span style=color:#f92672>in</span> pe<span style=color:#f92672>.</span>DIRECTORY_ENTRY_EXPORT<span style=color:#f92672>.</span>symbols:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> export<span style=color:#f92672>.</span>name:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>: 
</span></span><span style=display:flex><span>                    exported_func[hex(MurMurHash2(export<span style=color:#f92672>.</span>name))] <span style=color:#f92672>=</span> export<span style=color:#f92672>.</span>name
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> exported_func
</span></span></code></pre></div><p>The code presented above should be pretty clear, however, I would like to point out the role of the <em><strong>filter</strong></em> variable. Emulation brings a lot of advantages to reverse engineering, nevertheless, it also has a drawback related to performance. In fact, code that contains an emulation routine could be tremendously slow, and if you donâ€™t pay attention it could take forever. Using a filter variable keeps our code more flexible, resolving tailored functions names without wasting time.</p><blockquote><p>ðŸ’¡<em>Of course, in this case we could look for libraries names used within the code. However, we could not be so lucky in the future. Because of that, I prefer to show a way that could be used in multiple situations.</em></p></blockquote><h2 id=automation>Automation</h2><p>Now that we have built almost all fundamental components, itâ€™s time to combine everything in a single and effective script file. What we are still missing is a regular expression that is going to look for hashes and forward them to the MurMur2 emulator.</p><p>Observing the code, an easy pattern to follow involves a register and an immediate values:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nasm data-lang=nasm><span style=display:flex><span><span style=color:#a6e22e>mov</span> REG, IMM
</span></span></code></pre></div><p>Implementing this strategy and filtering results only on <em>kernel32.dll,</em> we are able to extract all referenced hashes:</p><p><img src=../../../../img/api_hashing/hashes_resolved.png alt="Figure 6: Some hashes related to Kernel32.dll "></p><p>Figure 6: Some hashes related to Kernel32.dll</p><h2 id=conclusion>Conclusion</h2><p>As always, going deep in each section requires an entire course and at the moment itâ€™s an impossible challenge. However, through this blog post I tried to scratch the surface giving some essential concepts (that could be applied straightaway) to make reversing time a lot more fun.</p><p>Another important thing to highlight here, is related to combine emulation and scripting techniques. Emulation is great, however, writing a script that contains some emulated routine could be a challenging task if we think about efficiency. Writing a single script for a single sample its not a big deal and it wonâ€™t have a great impact in a single analysis, however, doing it a scale is a different kettle of fish.</p><p>That said, itâ€™s time to conclude, otherwise, even reading this post could be a challenging task! :)</p><p>Have fun and keep reversing!</p><h2 id=references>References:</h2><p>Windows PE file format:</p><ul><li><a href=https://raw.githubusercontent.com/corkami/pics/master/binary/pe102/pe102.svg>PE file overview</a></li></ul><p>LummaStealer Hash resolver:</p><ul><li><a href=https://github.com/Viuleeenz/Reversing_Notes/blob/main/MalwareAutomation/LummaStealer/lummaStealer_v2_hash_resolver.py>lummaStealer_v2_hash_resolver.py</a></li></ul><p>LummaSteler sample:</p><ul><li><a href=https://bazaar.abuse.ch/sample/277d7f450268aeb4e7fe942f70a9df63aa429d703e9400370f0621a438e918bf/>MalwareBazaar</a></li></ul><h2 id=bonus>Bonus</h2><p>In order to understand how API Hashing works itâ€™s very useful to make your hand dirty on low level components. However, once you have some experience, it is also very helpful to have some tools that speed up your analysis. An amazing project is <a href=https://github.com/OALabs/hashdb>HashDB</a> maintained by OALabs. It is a simple and effective plugin for IDA and Binary Ninja that is going to resolve hashes, if the routine is implemented. If you want to try out this plugin for this LummaStealer sample, my pull request has already been merged ;)</p><h2 id=appendix-1---addressofnames>Appendix 1 - AddressOfNames</h2><p>The algorithm to retrieve the <strong>RVA</strong> associated to a function is quite straightforward:</p><ol><li>Iterate over the <strong>AddressOfNames</strong> structures.</li><li>Once you find a match with a specific function, suppose at <em>i</em> position, the loader is going to use index <em>i</em> to address the structure <strong>AddressOfNamesOrdinals</strong>.<ol><li>k = AddressOfNamesOrdinals[i]</li></ol></li><li>After collecting the value stored in <strong>AddressOfNamesOrdinals</strong> (2.a) we could use that value to address <strong>AddressOfFunctions</strong>, collecting the actual RVA of the function we were looking for.<ol><li><code>function_rva</code> = AddressOfFunctions[k]</li></ol></li></ol><p><img src=../../../../img/api_hashing/functions_and_names_pointers.png alt="Figure 7: How to retrieve functions names and pointers"></p><p>Figure 7: How to retrieve functions names and pointers</p><blockquote><p>ðŸ’¡<em>If you want to experiment a little bit more with this concept, I suggest to take the kernel32.dll library and follows this algorithm using <a href=https://github.com/hasherezade/pe-bear>PE-Bear</a></em></p></blockquote></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
1838 Words</p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2024-03-24 01:00</p></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2025</span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span></div></div></footer></div><script type=text/javascript src=../../../../bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc+cxaJzDdCYbAW0X1G+DgZYvtKFXe6MBex8jUJ2JT25mQx+YjACIng=="></script></body></html>