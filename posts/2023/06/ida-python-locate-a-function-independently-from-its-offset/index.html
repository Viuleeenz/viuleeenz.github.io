<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="map[name:Alessandro Strino]"><meta name=description content="Introduction Analyzing samples statically could be not an easy going taks, especially when you deal with heavily obfuscated or encrypted data. Because of that, it’s useful to find out the decryption/deobfuscation routine and write a little script that makes sense of strings or function names before starting to analyze the whole sample.
The idea behind this technique was inspired by the infinite amount of tweaking I have made to run multiple Ida-python scripts that were heavily machine-setting dependents. The idea is very simple and it’s based on pattern matching as for YARA rules. The scope here is to create a kind of signature for a function that we would like to locate (e.g., deobfuscation routine) and apply its execution to its parameters in order to simplify our analysis without tweaking specific parameters making it independent from the function offset. I have already got good results experimenting with malware samples (e.g, Qbot) and custom binaries from CTFs as well as other samples that used some sort of obfuscation. Because of that, I decided to create this post to share this approach that could be useful for writing better scripts.
"><meta name=keywords content="malware,binary,digital forensics,exploit development,reverse engineering"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://Viuleeenz.github.io/posts/2023/06/ida-python-locate-a-function-independently-from-its-offset/><title>IDA-Python - Locate a function independently from its offset :: Security Undisguised
</title><link rel=stylesheet href=../../../../scss/main.c2f26a20d135ff7bc7091bb95e626c68bc9d8e4c0852d733dbfe9527448dfa92.css integrity="sha256-wvJqINE1/3vHCRu5XmJsaLydjkwIUtcz2/6VJ0SN+pI="><link rel=stylesheet type=text/css href=../../../../style.css><link rel=apple-touch-icon sizes=180x180 href=../../../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../../../favicon-16x16.png><link rel=manifest href=../../../../site.webmanifest><link rel=mask-icon href=../../../../safari-pinned-tab.svg color><link rel="shortcut icon" href=../../../../favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="IDA-Python - Locate a function independently from its offset"><meta itemprop=description content="Introduction Analyzing samples statically could be not an easy going taks, especially when you deal with heavily obfuscated or encrypted data. Because of that, it’s useful to find out the decryption/deobfuscation routine and write a little script that makes sense of strings or function names before starting to analyze the whole sample.
The idea behind this technique was inspired by the infinite amount of tweaking I have made to run multiple Ida-python scripts that were heavily machine-setting dependents. The idea is very simple and it’s based on pattern matching as for YARA rules. The scope here is to create a kind of signature for a function that we would like to locate (e.g., deobfuscation routine) and apply its execution to its parameters in order to simplify our analysis without tweaking specific parameters making it independent from the function offset. I have already got good results experimenting with malware samples (e.g, Qbot) and custom binaries from CTFs as well as other samples that used some sort of obfuscation. Because of that, I decided to create this post to share this approach that could be useful for writing better scripts."><meta itemprop=datePublished content="2023-06-27T00:00:00+00:00"><meta itemprop=dateModified content="2023-06-27T00:00:00+00:00"><meta itemprop=wordCount content="1510"><meta itemprop=image content="https://Viuleeenz.github.io/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://Viuleeenz.github.io/"><meta name=twitter:title content="IDA-Python - Locate a function independently from its offset"><meta name=twitter:description content="Introduction Analyzing samples statically could be not an easy going taks, especially when you deal with heavily obfuscated or encrypted data. Because of that, it’s useful to find out the decryption/deobfuscation routine and write a little script that makes sense of strings or function names before starting to analyze the whole sample.
The idea behind this technique was inspired by the infinite amount of tweaking I have made to run multiple Ida-python scripts that were heavily machine-setting dependents. The idea is very simple and it’s based on pattern matching as for YARA rules. The scope here is to create a kind of signature for a function that we would like to locate (e.g., deobfuscation routine) and apply its execution to its parameters in order to simplify our analysis without tweaking specific parameters making it independent from the function offset. I have already got good results experimenting with malware samples (e.g, Qbot) and custom binaries from CTFs as well as other samples that used some sort of obfuscation. Because of that, I decided to create this post to share this approach that could be useful for writing better scripts."><meta property="og:url" content="https://Viuleeenz.github.io/posts/2023/06/ida-python-locate-a-function-independently-from-its-offset/"><meta property="og:site_name" content="Security Undisguised"><meta property="og:title" content="IDA-Python - Locate a function independently from its offset"><meta property="og:description" content="Introduction Analyzing samples statically could be not an easy going taks, especially when you deal with heavily obfuscated or encrypted data. Because of that, it’s useful to find out the decryption/deobfuscation routine and write a little script that makes sense of strings or function names before starting to analyze the whole sample.
The idea behind this technique was inspired by the infinite amount of tweaking I have made to run multiple Ida-python scripts that were heavily machine-setting dependents. The idea is very simple and it’s based on pattern matching as for YARA rules. The scope here is to create a kind of signature for a function that we would like to locate (e.g., deobfuscation routine) and apply its execution to its parameters in order to simplify our analysis without tweaking specific parameters making it independent from the function offset. I have already got good results experimenting with malware samples (e.g, Qbot) and custom binaries from CTFs as well as other samples that used some sort of obfuscation. Because of that, I decided to create this post to share this approach that could be useful for writing better scripts."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-27T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-27T00:00:00+00:00"><meta property="og:image" content="https://Viuleeenz.github.io/"><meta property="article:published_time" content="2023-06-27 00:00:00 +0000 UTC"></head><body><div class=container><header class=header><span class=header__inner><a href=../../../../ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>$ cd /home/Viuleeenz</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=../../../../about/>About</a></li><li><a href=../../../../posts/>Posts</a></li><li><a href=../../../../whitepapers/>Whitepapers</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span><span class="theme-toggle not-selectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span>
</span></span><script async src="https://www.googletagmanager.com/gtag/js?id=G-XNKLBC4D9D"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XNKLBC4D9D")}</script></header><div class=content><main class=post><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
8 minutes</p></div><article><h1 class=post-title><a href=https://Viuleeenz.github.io/posts/2023/06/ida-python-locate-a-function-independently-from-its-offset/>IDA-Python - Locate a function independently from its offset</a></h1><div class=post-content><h2 id=introduction>Introduction</h2><p>Analyzing samples statically could be not an easy going taks, especially when you deal with heavily obfuscated or encrypted data. Because of that, it’s useful to find out the decryption/deobfuscation routine and write a little script that makes sense of strings or function names before starting to analyze the whole sample.</p><p>The idea behind this technique was inspired by the infinite amount of tweaking I have made to run multiple Ida-python scripts that were heavily machine-setting dependents. The idea is very simple and it’s based on pattern matching as for YARA rules. The scope here is to create a kind of signature for a function that we would like to locate (e.g., deobfuscation routine) and apply its execution to its parameters in order to simplify our analysis <strong>without tweaking specific parameters</strong> making it <strong>independent from the function offset</strong>. I have already got good results experimenting with malware samples (e.g, Qbot) and custom binaries from CTFs as well as other samples that used some sort of obfuscation. Because of that, I decided to create this post to share this approach that could be useful for writing better scripts.</p><p>Generally speaking, approaching to these sample could be done through multiple perspective (e.g., starting with dynamic analysis and proceeding backwards), however, for the purpose of this blogpost I’m going to take a custom sample written by me, where strings are partially obfuscated with custom algorithm and I’m going to show an easy but effective method to write an ida-python script to <strong>locate and deobfuscate variables</strong>.</p><h2 id=practical-example>Practical example</h2><p>First go first. In order to deobfuscate a piece of code, it&rsquo;s still required to analyze the function that is going to perform this task and replicate its behavior implementing it within our script. For the purpose of this post, this step is out of scope, however, I’m going to directly analyze the assembly code in order to find out how to write the IDA-python script to collect all obfuscated variables to apply the proper routine.</p><p>The steps that we are going are pretty much the following:</p><ul><li>Find out the deobfuscation function;</li><li>Create a “signature” to retrieve all its references;</li><li>Collect the obfuscated parameters;</li><li>Apply the deobfuscation routine;</li></ul><h2 id=creating-function-signature>Creating function signature</h2><p>Since that sample it&rsquo;s actually very easy, finding the proper function it’s not so tricky. In fact, we could see that there is a DWORD that is going to be passed to a function called “<strong>DeobfuscateString</strong>”. However, what really matters here, is to create a signature of this function in order to locate it in multiple samples, independently from the offset that is going to be loaded.</p><p><img src=../../../../img/ida_python/function_overview.png alt="Figure 1 - Main function overview">
Figure 1 - Main function overview</p><p>To do so, it&rsquo;s possible to open the <strong>text</strong> view and explore the function to collect a few bytes that could be useful for this signature-like phase. I have chosen to get something related to the <strong>strcspn</strong> function that is part of the deobfuscation routine. More precisely, I have chosen to gather 16 bytes (<strong>8D 55 E0 52 8D 45 E4 50 FF 15 CC 20 40 00</strong>).</p><p><img src=../../../../img/ida_python/deob_function.png alt="Figure 2 - Deobfuscation routine">
Figure 2 - Deobfuscation routine</p><p>Now we could try to find out if our collected bytes are enough to identify this function. Let’s write a little script that checks this out.</p><h2 id=searching-for-the-function-characteristics>Searching for the function characteristics</h2><p>The first thing to do is to gather the <strong>.text</strong> segment and then, start to look for our signature. One of the easiest ways to get the segment requested is to iterate over all segments until the <strong>idc.get_segm_name</strong> contains the “<strong>.text”</strong> name:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_text_segment</span>(seg_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;.text&#34;</span>):
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> s <span style=color:#f92672>in</span> idautils<span style=color:#f92672>.</span>Segments():
</span></span><span style=display:flex><span>  start <span style=color:#f92672>=</span> idc<span style=color:#f92672>.</span>get_segm_start(s)
</span></span><span style=display:flex><span>  end <span style=color:#f92672>=</span> idc<span style=color:#f92672>.</span>get_segm_end(s)
</span></span><span style=display:flex><span>  name <span style=color:#f92672>=</span> idc<span style=color:#f92672>.</span>get_segm_name(s)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> name <span style=color:#f92672>==</span> seg_name:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> start, end
</span></span></code></pre></div><p>Then, we should write a function that is capable to locate our signature:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>patternSearch</span>(address_start, address_end):
</span></span><span style=display:flex><span>    pattern <span style=color:#f92672>=</span> idaapi<span style=color:#f92672>.</span>compiled_binpat_vec_t()
</span></span><span style=display:flex><span>    res <span style=color:#f92672>=</span> idaapi<span style=color:#f92672>.</span>parse_binpat_str(
</span></span><span style=display:flex><span>        pattern,
</span></span><span style=display:flex><span>        address_start,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;8D 55 E0 52 8D 45 E4 50 FF 15 CC 20 40 00&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>16</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> res <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;[!] Pattern not Found&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        ea <span style=color:#f92672>=</span> idaapi<span style=color:#f92672>.</span>bin_search(address_start, address_end, pattern, idaapi<span style=color:#f92672>.</span>BIN_SEARCH_CASE)
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;[+] Pattern found at: </span><span style=color:#e6db74>{0}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(hex(ea)))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ea
</span></span></code></pre></div><p>At first glance this code could seem a mess, but it’s easier than expected. Let’s do a deep dive. The parameters <strong>address_start</strong> | <strong>address_end</strong> are related to the text segment, since we are looking for the signature within the whole segment space. To understand the parameters passed to <strong>idaapi.parse_binpat_str</strong>, we could refer to its <a href=https://www.hex-rays.com/products/ida/support/idapython_docs/ida_bytes.html>documentation</a>. However, for interruption its signature is given here:</p><blockquote><p><strong>parse_binpat_str(out, ea, _in, radix, strlits_encoding=0) -> str</strong> (the odd variable could be represented by the out parameter. However it represents a vector of compiled binary patterns, that will be later used with bin_search()). Running those functions together it’s possible to observe few references related to the deobfuscation string used within the <strong>.text</strong> segment, then if we look for those references in IDA we could see that with those few bytes we were able to get all we needed to move forward to collect all the obfuscated parameters.</p></blockquote><p><img src=https://lh5.googleusercontent.com/4gWjUL1uVbmX1aIjD6h6emg_1IjrTWq7m9I8iUt5oaI7sOwSddMLk9LJj9usj0Zo4OeMkQfAIf8sqBzkwRJwXB_-7_adbxB0V3YZCtk_QS7Ar4ykqA1ovZYgEgDhEAniCKz569KUV5jBsiQw8VoQPSQ alt="Figure 3 - Code reference of deobfuscation routine">
Figure 3 - Code reference of deobfuscation routine</p><h2 id=collecting-parameters>Collecting parameters</h2><p>Now we have tested that our script successfully identifies the function within the <strong>.text</strong> segment, however, before proceeding collecting its parameters, it is important to also get information related to its usage. To do so, we could use the returning value from the <strong>bin_search</strong> function and use them as a parameter for <strong>idaapi.get_func()</strong> that will return the addresses where our deobfuscation routine is actually used. As a final step to locate all its references it’s possible to use the function <strong>idautils.XrefsTo</strong> as follow:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>locate_decrypt_function</span>(function_address):
</span></span><span style=display:flex><span>    xref_list <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> xref <span style=color:#f92672>in</span> idautils<span style=color:#f92672>.</span>XrefsTo(function_address):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> xref<span style=color:#f92672>.</span>frm <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> xref_list:
</span></span><span style=display:flex><span>            xref_list<span style=color:#f92672>.</span>append(xref<span style=color:#f92672>.</span>frm)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> list(xref_list)
</span></span></code></pre></div><p>Through this method I’ve just created a list that is going to contain all function references. From that list, it is possible to iterate all over the function call and retrieve the obfuscated string.</p><p><img src=https://lh6.googleusercontent.com/oeQLy6NE6GfIe-DTLErQgVmQwSBzaCf-EM5DB666-y--7RES2yKOYnQXaTQ8evd24clMhEvmhiKXYQvMUSohzaTWMmgqigSMNu74lr-6czaTyxRp8VL7mR82Ge9JKdXQq6FWMYOMb7dcSmGR91OdN_0 alt="Figure 4 - finding function code and its usage">
Figure 4 - finding function code and its usage</p><p>Now, in order to find out the parameters, it’s necessary to observe the pattern used by this sample to understand how to collect the obfuscated string. Observing all the occurrences retrieved, it’s possible to create a function that retrieves all parameters named “offset” with mnemonic push (opcode <strong>68</strong>).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>gather_string_offset</span>(xref_address):
</span></span><span style=display:flex><span>    function_start <span style=color:#f92672>=</span> idc<span style=color:#f92672>.</span>get_func_attr(xref_address, FUNCATTR_START)
</span></span><span style=display:flex><span>    new_address <span style=color:#f92672>=</span> xref_address
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>        prev_address <span style=color:#f92672>=</span> idc<span style=color:#f92672>.</span>prev_head(new_address)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> prev_address <span style=color:#f92672>&lt;=</span> function_start:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> idc<span style=color:#f92672>.</span>print_insn_mnem(prev_address) <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;push&#34;</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> idc<span style=color:#f92672>.</span>print_operand(prev_address,<span style=color:#ae81ff>0</span>)<span style=color:#f92672>.</span>split()[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;offset&#34;</span>: 
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> idc<span style=color:#f92672>.</span>get_operand_value(prev_address, <span style=color:#ae81ff>0</span>) 
</span></span><span style=display:flex><span>        new_address <span style=color:#f92672>=</span> prev_address
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;[!] Offset not found.&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span></code></pre></div><p>The function presented here, it’s pretty straightforward. It takes the <strong>fucntion_start</strong> parameters that represents the function block that contains the instruction <strong>call DeobfuscateString</strong> (since the code it’s all written within the main function, <strong>fucntion_start</strong> will be the first instruction in the main. However, in other example our DeobfuscateString function could be part of another subroutine and in that case, the function_start will point to the first instruction of that routine ) Then, from the function the instruction call DeobfuscateString, we start to move backward in order to find out the <strong>offset</strong> parameter that will point to our obfuscated string. It’s worth mentioning that the code <strong>prev_address &lt;= function_start it’s used to avoid going over the main function boundaries</strong> (it doest make any sense to go backward over that line, since our code should be located there).</p><p>Now that we have collected all string references related to each call, we are still required to get the whole obfuscated string. In fact, through our code we were able to get the first byte of each string but it’s required to get the whole reference to forward the string to the deobfuscation routine:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>retrive_string</span>(offset):
</span></span><span style=display:flex><span>    obfuscated_string <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>    counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> chr(idaapi<span style=color:#f92672>.</span>get_byte(offset <span style=color:#f92672>+</span> counter)) <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x00</span><span style=color:#e6db74>&#34;</span>:
</span></span><span style=display:flex><span>        obfuscated_string <span style=color:#f92672>+=</span> chr(idaapi<span style=color:#f92672>.</span>get_byte(offset <span style=color:#f92672>+</span> counter))
</span></span><span style=display:flex><span>        counter <span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> obfuscated_string
</span></span></code></pre></div><p>The script here, takes the first string byte and it starts to move forward until a NULL byte it’s located (In this case, the null byte represents the end of our string).</p><h2 id=deobfuscation-function>Deobfuscation function</h2><p>After retrieving the string, it’s a matter of implementing the deobfuscation routine and applying it to the collected strings. Implementation details are left as an exercise for curious reversers that would like to make it on their own. Since implementation of this specific case it’s actually pointless for a real case scenario, it will be skipped from this article and will be directly implemented within the final IDA-python script.</p><h2 id=script-testing>Script Testing</h2><p>To run our script it’s possible to go in <em>File > Script</em> <em>file</em>, selecting the proper <em>ida_python</em> script. Testing the script in IDA, it&rsquo;s possible to observe that all obfuscated strings have been correctly deobfuscated and a little comment has been added to the end of each string reference.</p><p><img src=https://lh6.googleusercontent.com/CZC2L6z-Ie0G8mb6v0Nutciep3hXx7AerWk-c6vr52u1QyEIicO-E76156SnByknVj8_JtB-m2lZCxuSB_NBst6miGqVh8vcz3zNg81m4raC4QCVV1can-KqGLdLRNp5YH1IzPm9MzhEANTWX-J4XFY alt="Figure 5 - Variable deobfuscated successfully">
Figure 5 - Variable deobfuscated successfully</p><h2 id=conclusion>Conclusion</h2><p>This post has been written to illustrate an effective and quite useful technique to locate interesting functions within a binary and to write a custom IDA-python script that is capable of finding all function occurrences. This approach it’s actually very helpful also to avoid configuration dependencies, giving to our script the ability to be shared <strong>without tweaking specific parameters</strong> that could rely on IDA instances.</p><h3 id=references>References</h3><ul><li>Ida-python script: <a href=https://github.com/Viuleeenz/Reversing_Notes/blob/main/IDA-python/function_search/fSearch.py>fSearch.py</a></li><li>source code: <a href=https://github.com/Viuleeenz/Reversing_Notes/blob/main/IDA-python/function_search/test/obfuscation.c>obfuscation.c</a></li><li>compiled sample: <a href=https://github.com/Viuleeenz/Reversing_Notes/blob/main/IDA-python/function_search/test/obfuscation.exe>obfuscation.exe</a></li></ul></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
1510 Words</p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2023-06-27 02:00</p></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2025</span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span></div></div></footer></div><script type=text/javascript src=../../../../bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc+cxaJzDdCYbAW0X1G+DgZYvtKFXe6MBex8jUJ2JT25mQx+YjACIng=="></script></body></html>