<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="map[name:Alessandro Strino]"><meta name=description content="Introduction Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary.
"><meta name=keywords content="malware,binary,digital forensics,exploit development,reverse engineering"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://Viuleeenz.github.io/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/><title>Dynamic Binary Instrumentation for Malware Analysis :: Security Undisguised
</title><link rel=stylesheet href=../../../../scss/main.c2f26a20d135ff7bc7091bb95e626c68bc9d8e4c0852d733dbfe9527448dfa92.css integrity="sha256-wvJqINE1/3vHCRu5XmJsaLydjkwIUtcz2/6VJ0SN+pI="><link rel=stylesheet type=text/css href=../../../../style.css><link rel=apple-touch-icon sizes=180x180 href=../../../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../../../favicon-16x16.png><link rel=manifest href=../../../../site.webmanifest><link rel=mask-icon href=../../../../safari-pinned-tab.svg color><link rel="shortcut icon" href=../../../../favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="Dynamic Binary Instrumentation for Malware Analysis"><meta itemprop=description content="Introduction Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary."><meta itemprop=datePublished content="2023-03-14T00:00:00+00:00"><meta itemprop=dateModified content="2023-03-14T00:00:00+00:00"><meta itemprop=wordCount content="862"><meta itemprop=image content="https://Viuleeenz.github.io/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://Viuleeenz.github.io/"><meta name=twitter:title content="Dynamic Binary Instrumentation for Malware Analysis"><meta name=twitter:description content="Introduction Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary."><meta property="og:url" content="https://Viuleeenz.github.io/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/"><meta property="og:site_name" content="Security Undisguised"><meta property="og:title" content="Dynamic Binary Instrumentation for Malware Analysis"><meta property="og:description" content="Introduction Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-14T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-14T00:00:00+00:00"><meta property="og:image" content="https://Viuleeenz.github.io/"><meta property="article:published_time" content="2023-03-14 00:00:00 +0000 UTC"></head><body><div class=container><header class=header><span class=header__inner><a href=../../../../ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>$ cd /home/Viuleeenz</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=../../../../about/>About</a></li><li><a href=../../../../posts/>Posts</a></li><li><a href=../../../../whitepapers>Whitepapers</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span><span class="theme-toggle not-selectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span>
</span></span><script async src="https://www.googletagmanager.com/gtag/js?id=G-XNKLBC4D9D"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XNKLBC4D9D")}</script></header><div class=content><main class=post><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
5 minutes</p></div><article><h1 class=post-title><a href=https://Viuleeenz.github.io/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/>Dynamic Binary Instrumentation for Malware Analysis</a></h1><div class=post-content><h2 id=introduction><strong>Introduction</strong></h2><p>Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary.</p><p>Since I would like to skip redundant topics that are already written all over the internet by people that are Jedi in this field, I’m going to limit this post linking references that would be nice to have to understand everything easily.</p><ul><li><a href=https://frida.re/docs/javascript-api/>Frida</a></li><li><a href=https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect>Windows API</a></li><li><a href=https://research.checkpoint.com/2020/gozi-the-malware-with-a-thousand-faces/>Ursnif/Gozi</a></li></ul><h2 id=intercepting-function-calls><strong>Intercepting function calls</strong></h2><p>Most of the time, malware, in order to write memory and run code from the newly allocated space, make use of two functions, such as: <strong>VirtualAlloc</strong> (<a href=https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc>ref.</a>) and <strong>VirtualProtect</strong> (<a href=https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect>ref</a>.). For the purpose of our task, I have chosen the VirtualProtect function, because at the time of its calling, the data (payload) should be already there and it would be easier to analyze.</p><p>So let’s start to write out the code that retrieves the <strong>reference</strong> of this function and the interceptor that is going to be used to monitor function calls entry and return. Thanks to Frida, it is possible to directly retrieve function arguments through the variable <strong>args</strong> and check their values. The most important parameter and the one that will be used for our purpose is the <strong>lpAddress</strong> that represents the address space that is involved in this function call.</p><p><img src=https://lh3.googleusercontent.com/mra9ne7fbva4FUzxVzhFwTz2QWCiv3W5nM6SvVJT-fMqx2VoyXA-SMrFV_5yx6mVkbWUiLNg9Xxx-c_uEuMRGFrVCGRDp5Cg7cPOOQ9V6lBUu592qFLb4ebOsaVA8ra1ykjAxnhz6F4nbZDjU-RwZqc alt="Figure 1 - References to VirtualProtect and call Interceptor"></p><p>Figure 1 - References to VirtualProtect and call Interceptor</p><p>Because of the purpose of the article we are not interested in all <strong>VirtualProtect</strong> calls but we would like to limit our scope to ones that contain a PE header.  To do this, it&rsquo;s possible to verify if <strong>lpAddress</strong> starts with “<strong>MZ</strong>” or “<strong>5d4a</strong>”. If so, we could print out some values in order to check them against the running executable using tools such as <strong>ProcessMonitor</strong> or <strong>ProcessHacker</strong>.</p><p><img src=https://lh6.googleusercontent.com/YwJkMozUWoo0bIKWP2QTX_Fr18F3LdGhRu4P2AznmONaPx305jNoDDQRHaAeHQExP96jrpxPjM6QDjxJ2IlFQfaN5oIbAYPImYP-Wq7JalzBHtuPWvcDBptVWvbiInjyAtFl5NUEE9XXvjsV8gE6Vkk alt="Figure 2 - Printing VirtualProtect arguments"></p><p>Figure 2 - Printing VirtualProtect arguments</p><h2 id=retrieving-the-payload><strong>Retrieving the payload</strong></h2><p>Now comes the tricky part. If we simply apply this technique to dump the memory that contains the <strong>MZ</strong>, it would be possible for us to also dump the binary that we originally started the infection with. However, analyzing Ursnif code, it&rsquo;s possible to see that it creates a dedicated memory space to write its final stage that is commonly referenced as a DLL. In order to avoid that, it&rsquo;s possible to use a function <em>findModuleByAddress</em> that belongs to the <em>Process</em> object.</p><p>As reported by Frida documentation:</p><blockquote><p>Process.findModuleByAddress(address) returns a <strong><a href=https://frida.re/docs/javascript-api/#module><code>Module</code></a></strong> whose <em>address</em> or <em>name</em> matches the one specified. In the event that no such module could be found, the <em>find</em>-prefixed functions return <em>null</em> whilst the <em>get</em>-prefixed functions throw an exception.</p></blockquote><p>In order to avoid exception handling stuff I have preferred to go with find prefix function and then checking if the Module returned is equal to null. Otherwise, we would have an existing module object and  module.base = image base.</p><p>Now, as a final step before moving on and dumping the actual payload, it&rsquo;s necessary to retrieve the page size to which  <strong>lpAddress</strong> belongs. That information could be retrieved using the findRangeByAddress that  return an object with details about the range (memory page) containing address.</p><p><img src=https://lh4.googleusercontent.com/disgHE5VRs6Ob1F0hCt2bKCsfuc3AsxUFViJkqkf_EfYYCmpsiUOILazwCz6asBUsj3paJZ5Libw9N0dYYGSzY60PQRmukGzwFTDfkONM_V2McgqX69kVVlUzrRksfiuM48oDS_GzsPzMQA9gz_GN5E alt=" Figure 3 - Checking for payload address"></p><p>Figure 3 - Checking for payload address</p><h2 id=dumping-config-file><strong>Dumping config file</strong></h2><p>Now that we have all the information required, it’s time to dump the actual Ursnif payload. In order to do this, it&rsquo;s possible to read the page related to <strong>lpAddress</strong> using the <em>readByteArray</em> using the <strong>module.size</strong>. Once the information has been stored, it’s possible to write it in a file that could be used later on for further manipulation and analysis.</p><p><img src=https://lh3.googleusercontent.com/ju4MZv16hQgyeT6Si6wn_Y6-ble6sl4Oq8L2Jx93vCt3OpxmJBjDvdRCDD9yDVsUIRueQSPksuWVEMsxNUppGE1DsNM5F_PGdanWV4_wqOSuNpUnst2UdLT7emcpaaJMYuLigwBKRvHzuTyY86E3q2U alt=" Figure 4 - Dumping Ursnif payload"></p><p>Figure 4 - Dumping Ursnif payload</p><p>It’s worth noting that before proceeding with the configuration extraction phase, it’s necessary to modify <code>Raw addresses</code> and <code>Virtual Addresses</code> of each section  header accordingly. This step is necessary because the payload was extracted directly from memory.</p><h2 id=script-testing><strong>Script Testing</strong></h2><p>Now that we have completed our script it&rsquo;s time for testing with a real case! Let’s take one of the recent samples delivered by the TA and see if it works. For this example I have chosen a publicly available sample on <a href=https://bazaar.abuse.ch/sample/83ece9c5d6ffe0e99276becec96bc1c181a731ebd2fb95eaef329d2fbbec7271/>MalwareBazar</a>.</p><p>Running the script against this sample with Frida as follow:</p><p><code>frida.exe &lt;mal_executable> -l &lt;your_script.js></code></p><p>It will produce a file called <strong>0x2cf0000_mz.bin</strong> (it may vary from the memory address allocation on your machine).</p><p><img src=../../../../img/dbi/extractionWithFrida.png alt="Figure 5 - Ursnif payload extraction with Frida"></p><p>Figure 5 - Ursnif payload extraction with Frida</p><p>If we open this file with PE-Bear, what should alert us, is the import table that contains unresolved information. This happens, because our code has been extracted directly from memory and before proceeding with our analysis it is necessary to map the raw sections addresses with their virtual counterparts (for brevity I have prepared a script that is going to perform these steps automatically). After having settled the addresses properly, it’s possible to proceed with configuration extraction through a custom script (that is out of the scope for this post).</p><h2 id=reference>Reference</h2><ul><li>DBI script: <a href=https://github.com/Viuleeenz/Reversing_Notes/blob/main/DynamicBinaryInstrumentation/mon.js>mon.py</a></li></ul></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
862 Words</p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2023-03-14 01:00</p></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2025</span>
<span><a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></span></div></div></footer></div><script type=text/javascript src=../../../../bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc+cxaJzDdCYbAW0X1G+DgZYvtKFXe6MBex8jUJ2JT25mQx+YjACIng=="></script></body></html>