<!DOCTYPE html>
<html lang="en">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="map[name:Alessandro Strino]">
<meta name="description" content="Introduction Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary.
" />
<meta name="keywords" content="malware, binary, digital forensics, exploit development, reverse engineering" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="http://localhost:1313/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/" />


    <title>
        
            Dynamic Binary Instrumentation for Malware Analysis :: Security Undisguised 
        
    </title>





    
        
        
        <link rel="stylesheet" href="../../../../scss/main.4c717a3dff5ec47ecfa7229b960ed715a5ad930b4079fbd0ed59f277863cf26c.css" integrity="sha256-THF6Pf9exH7PpyKblg7XFaWtkwtAefvQ7Vnyd4Y88mw=">
    



    
        <link rel="stylesheet" type="text/css" href="../../../../style.css">
    


    <link rel="apple-touch-icon" sizes="180x180" href="../../../../apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../../favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../../favicon-16x16.png">
    <link rel="manifest" href="../../../../site.webmanifest">
    <link rel="mask-icon" href="../../../../safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="../../../../favicon.ico">
    <meta name="msapplication-TileColor" content="">



  <meta itemprop="name" content="Dynamic Binary Instrumentation for Malware Analysis">
  <meta itemprop="description" content="Introduction Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary.">
  <meta itemprop="datePublished" content="2023-03-14T00:00:00+00:00">
  <meta itemprop="dateModified" content="2023-03-14T00:00:00+00:00">
  <meta itemprop="wordCount" content="862">
  <meta itemprop="image" content="http://localhost:1313/">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="http://localhost:1313/">
  <meta name="twitter:title" content="Dynamic Binary Instrumentation for Malware Analysis">
  <meta name="twitter:description" content="Introduction Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary.">


    <meta property="og:url" content="http://localhost:1313/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/">
  <meta property="og:site_name" content="Security Undisguised">
  <meta property="og:title" content="Dynamic Binary Instrumentation for Malware Analysis">
  <meta property="og:description" content="Introduction Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-03-14T00:00:00+00:00">
    <meta property="article:modified_time" content="2023-03-14T00:00:00+00:00">
    <meta property="og:image" content="http://localhost:1313/">






    <meta property="article:published_time" content="2023-03-14 00:00:00 &#43;0000 UTC" />









    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="../../../../" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">&gt;</span>
            <span class="logo__text ">
                $ cd /home/Viuleeenz</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>

        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="../../../../about/">About</a></li><li><a href="../../../../posts/">Posts</a></li><li><a href="../../../../whitepapers/">Whitepapers</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            
                <span class="theme-toggle not-selectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
   <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
   3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
   13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
 </svg></span>
        </span>
    </span>
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-XNKLBC4D9D"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-XNKLBC4D9D');
        }
      </script>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        5 minutes

        
      </p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="http://localhost:1313/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/">Dynamic Binary Instrumentation for Malware Analysis</a>
      </h1>

      

      

      

      <div class="post-content">
        <h2 id="introduction"><strong>Introduction</strong></h2>
<p>Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary.</p>
<p>Since I would like to skip redundant topics that are already written all over the internet by people that are Jedi in this field, I’m going to limit this post linking references that would be nice to have to understand everything easily.</p>
<ul>
<li><a href="https://frida.re/docs/javascript-api/">Frida</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">Windows API</a></li>
<li><a href="https://research.checkpoint.com/2020/gozi-the-malware-with-a-thousand-faces/">Ursnif/Gozi</a></li>
</ul>
<h2 id="intercepting-function-calls"><strong>Intercepting function calls</strong></h2>
<p>Most of the time, malware, in order to write memory and run code from the newly allocated space, make use of two functions, such as: <strong>VirtualAlloc</strong> (<a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">ref.</a>) and <strong>VirtualProtect</strong> (<a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">ref</a>.). For the purpose of our task, I have chosen the VirtualProtect function, because at the time of its calling, the data (payload) should be already there and it would be easier to analyze.</p>
<p>So let’s start to write out the code that retrieves the <strong>reference</strong> of this function and the interceptor that is going to be used to monitor function calls entry and return. Thanks to Frida, it is possible to directly retrieve function arguments through the variable <strong>args</strong> and check their values. The most important parameter and the one that will be used for our purpose is the <strong>lpAddress</strong> that represents the address space that is involved in this function call.</p>
<p><img src="https://lh3.googleusercontent.com/mra9ne7fbva4FUzxVzhFwTz2QWCiv3W5nM6SvVJT-fMqx2VoyXA-SMrFV_5yx6mVkbWUiLNg9Xxx-c_uEuMRGFrVCGRDp5Cg7cPOOQ9V6lBUu592qFLb4ebOsaVA8ra1ykjAxnhz6F4nbZDjU-RwZqc" alt="Figure 1 - References to VirtualProtect and call Interceptor"></p>
<p>Figure 1 - References to VirtualProtect and call Interceptor</p>
<p>Because of the purpose of the article we are not interested in all <strong>VirtualProtect</strong> calls but we would like to limit our scope to ones that contain a PE header.  To do this, it&rsquo;s possible to verify if <strong>lpAddress</strong> starts with “<strong>MZ</strong>” or “<strong>5d4a</strong>”. If so, we could print out some values in order to check them against the running executable using tools such as <strong>ProcessMonitor</strong> or <strong>ProcessHacker</strong>.</p>
<p><img src="https://lh6.googleusercontent.com/YwJkMozUWoo0bIKWP2QTX_Fr18F3LdGhRu4P2AznmONaPx305jNoDDQRHaAeHQExP96jrpxPjM6QDjxJ2IlFQfaN5oIbAYPImYP-Wq7JalzBHtuPWvcDBptVWvbiInjyAtFl5NUEE9XXvjsV8gE6Vkk" alt="Figure 2 - Printing VirtualProtect arguments"></p>
<p>Figure 2 - Printing VirtualProtect arguments</p>
<h2 id="retrieving-the-payload"><strong>Retrieving the payload</strong></h2>
<p>Now comes the tricky part. If we simply apply this technique to dump the memory that contains the <strong>MZ</strong>, it would be possible for us to also dump the binary that we originally started the infection with. However, analyzing Ursnif code, it&rsquo;s possible to see that it creates a dedicated memory space to write its final stage that is commonly referenced as a DLL. In order to avoid that, it&rsquo;s possible to use a function <em>findModuleByAddress</em> that belongs to the <em>Process</em> object.</p>
<p>As reported by Frida documentation:</p>
<blockquote>
<p>Process.findModuleByAddress(address) returns a <strong><a href="https://frida.re/docs/javascript-api/#module"><code>Module</code></a></strong> whose <em>address</em> or <em>name</em> matches the one specified. In the event that no such module could be found, the <em>find</em>-prefixed functions return <em>null</em> whilst the <em>get</em>-prefixed functions throw an exception.</p>
</blockquote>
<p>In order to avoid exception handling stuff I have preferred to go with find prefix function and then checking if the Module returned is equal to null. Otherwise, we would have an existing module object and  module.base = image base.</p>
<p>Now, as a final step before moving on and dumping the actual payload, it&rsquo;s necessary to retrieve the page size to which  <strong>lpAddress</strong> belongs. That information could be retrieved using the findRangeByAddress that  return an object with details about the range (memory page) containing address.</p>
<p><img src="https://lh4.googleusercontent.com/disgHE5VRs6Ob1F0hCt2bKCsfuc3AsxUFViJkqkf_EfYYCmpsiUOILazwCz6asBUsj3paJZ5Libw9N0dYYGSzY60PQRmukGzwFTDfkONM_V2McgqX69kVVlUzrRksfiuM48oDS_GzsPzMQA9gz_GN5E" alt=" Figure 3 - Checking for payload address"></p>
<p>Figure 3 - Checking for payload address</p>
<h2 id="dumping-config-file"><strong>Dumping config file</strong></h2>
<p>Now that we have all the information required, it’s time to dump the actual Ursnif payload. In order to do this, it&rsquo;s possible to read the page related to <strong>lpAddress</strong> using the <em>readByteArray</em> using the <strong>module.size</strong>. Once the information has been stored, it’s possible to write it in a file that could be used later on for further manipulation and analysis.</p>
<p><img src="https://lh3.googleusercontent.com/ju4MZv16hQgyeT6Si6wn_Y6-ble6sl4Oq8L2Jx93vCt3OpxmJBjDvdRCDD9yDVsUIRueQSPksuWVEMsxNUppGE1DsNM5F_PGdanWV4_wqOSuNpUnst2UdLT7emcpaaJMYuLigwBKRvHzuTyY86E3q2U" alt=" Figure 4 - Dumping Ursnif payload"></p>
<p>Figure 4 - Dumping Ursnif payload</p>
<p>It’s worth noting that before proceeding with the configuration extraction phase, it’s necessary to modify <code>Raw addresses</code> and <code>Virtual Addresses</code> of each section  header accordingly. This step is necessary because the payload was extracted directly from memory.</p>
<h2 id="script-testing"><strong>Script Testing</strong></h2>
<p>Now that we have completed our script it&rsquo;s time for testing with a real case! Let’s take one of the recent samples delivered by the TA and see if it works. For this example I have chosen a publicly available sample on <a href="https://bazaar.abuse.ch/sample/83ece9c5d6ffe0e99276becec96bc1c181a731ebd2fb95eaef329d2fbbec7271/">MalwareBazar</a>.</p>
<p>Running the script against this sample with Frida as follow:</p>
<p><code>frida.exe &lt;mal_executable&gt; -l &lt;your_script.js&gt;</code></p>
<p>It will produce a file called <strong>0x2cf0000_mz.bin</strong> (it may vary from the memory address allocation on your machine).</p>
<p><img src="../../../../img/dbi/extractionWithFrida.png" alt="Figure 5 - Ursnif payload extraction with Frida"></p>
<p>Figure 5 - Ursnif payload extraction with Frida</p>
<p>If we open this file with PE-Bear, what should alert us, is the import table that contains unresolved information. This happens, because our code has been extracted directly from memory and before proceeding with our analysis it is necessary to map the raw sections addresses with their virtual counterparts (for brevity I have prepared a script that is going to perform these steps automatically). After having settled the addresses properly, it’s possible to proceed with configuration extraction through a custom script (that is out of the scope for this post).</p>
<h2 id="reference">Reference</h2>
<ul>
<li>DBI script: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/DynamicBinaryInstrumentation/mon.js">mon.py</a></li>
</ul>

      </div>
    </article>

    <hr />

    <div class="post-info">
      
      

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        862 Words
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        
          2023-03-14 01:00
        

         
          
        
      </p>
    </div>

    


    

  </main>

            </div>

            
                <footer class="footer">
    
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2025</span>
            
            <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span>
            
            
        </div>
    </div>
    
    
</footer>

            
        </div>

        



<script type="text/javascript" src="../../../../bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js" integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc&#43;cxaJzDdCYbAW0X1G&#43;DgZYvtKFXe6MBex8jUJ2JT25mQx&#43;YjACIng=="></script>



    </body>
</html>
